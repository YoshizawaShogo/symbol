use data_encoding::DecodeError;
use hex;
use hex::FromHexError;
use std::array::TryFromSliceError;

#[derive(Debug)]
pub enum SymbolError {
    FromHexError(FromHexError),
    Base32DecodeError(DecodeError),
    TryFromSliceError(TryFromSliceError),
    SizeError { expect: usize, real: usize },
    ReservedIsNotZeroError(u32),
    EnumDecodeError(u32),
}

impl From<FromHexError> for SymbolError {
    fn from(err: FromHexError) -> Self {
        SymbolError::FromHexError(err)
    }
}

impl From<DecodeError> for SymbolError {
    fn from(err: DecodeError) -> Self {
        SymbolError::Base32DecodeError(err)
    }
}

impl From<TryFromSliceError> for SymbolError {
    fn from(err: TryFromSliceError) -> SymbolError {
        SymbolError::TryFromSliceError(err)
    }
}
///name: Amount
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Amount(pub u64);
impl Amount {
    const SIZE: usize = 8;
    pub fn new(amount: u64) -> Self {
        Self(amount)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: BlockDuration
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct BlockDuration(pub u64);
impl BlockDuration {
    const SIZE: usize = 8;
    pub fn new(blockduration: u64) -> Self {
        Self(blockduration)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: BlockFeeMultiplier
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint32
///    is_unsigned: True
///    size: 4
///    display_type: DisplayType.INTEGER
///    *name: uint32
///    *sizeref: None
///*is_unsigned: True
///*size: 4
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct BlockFeeMultiplier(pub u32);
impl BlockFeeMultiplier {
    const SIZE: usize = 4;
    pub fn new(blockfeemultiplier: u32) -> Self {
        Self(blockfeemultiplier)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:08x}", self.0)
    }
}
///name: Difficulty
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Difficulty(pub u64);
impl Difficulty {
    const SIZE: usize = 8;
    pub fn new(difficulty: u64) -> Self {
        Self(difficulty)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: FinalizationEpoch
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint32
///    is_unsigned: True
///    size: 4
///    display_type: DisplayType.INTEGER
///    *name: uint32
///    *sizeref: None
///*is_unsigned: True
///*size: 4
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct FinalizationEpoch(pub u32);
impl FinalizationEpoch {
    const SIZE: usize = 4;
    pub fn new(finalizationepoch: u32) -> Self {
        Self(finalizationepoch)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:08x}", self.0)
    }
}
///name: FinalizationPoint
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint32
///    is_unsigned: True
///    size: 4
///    display_type: DisplayType.INTEGER
///    *name: uint32
///    *sizeref: None
///*is_unsigned: True
///*size: 4
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct FinalizationPoint(pub u32);
impl FinalizationPoint {
    const SIZE: usize = 4;
    pub fn new(finalizationpoint: u32) -> Self {
        Self(finalizationpoint)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:08x}", self.0)
    }
}
///name: Height
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Height(pub u64);
impl Height {
    const SIZE: usize = 8;
    pub fn new(height: u64) -> Self {
        Self(height)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: Importance
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Importance(pub u64);
impl Importance {
    const SIZE: usize = 8;
    pub fn new(importance: u64) -> Self {
        Self(importance)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: ImportanceHeight
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ImportanceHeight(pub u64);
impl ImportanceHeight {
    const SIZE: usize = 8;
    pub fn new(importanceheight: u64) -> Self {
        Self(importanceheight)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: UnresolvedMosaicId
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct UnresolvedMosaicId(pub u64);
impl UnresolvedMosaicId {
    const SIZE: usize = 8;
    pub fn new(unresolvedmosaicid: u64) -> Self {
        Self(unresolvedmosaicid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: MosaicId
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicId(pub u64);
impl MosaicId {
    const SIZE: usize = 8;
    pub fn new(mosaicid: u64) -> Self {
        Self(mosaicid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: Timestamp
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Timestamp(pub u64);
impl Timestamp {
    const SIZE: usize = 8;
    pub fn new(timestamp: u64) -> Self {
        Self(timestamp)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: UnresolvedAddress
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 24
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(24)
///*is_unsigned: True
///*size: 24
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct UnresolvedAddress(pub [u8; 24]);
impl UnresolvedAddress {
    const SIZE: usize = 24;
    pub fn new(unresolvedaddress: [u8; 24]) -> Self {
        Self(unresolvedaddress)
    }
    pub fn default() -> Self {
        Self([0; 24])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: Address
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 24
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(24)
///*is_unsigned: True
///*size: 24
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Address(pub [u8; 24]);
impl Address {
    const SIZE: usize = 24;
    pub fn new(address: [u8; 24]) -> Self {
        Self(address)
    }
    pub fn default() -> Self {
        Self([0; 24])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: Hash256
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 32
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(32)
///*is_unsigned: True
///*size: 32
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Hash256(pub [u8; 32]);
impl Hash256 {
    const SIZE: usize = 32;
    pub fn new(hash256: [u8; 32]) -> Self {
        Self(hash256)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: Hash512
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 64
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(64)
///*is_unsigned: True
///*size: 64
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Hash512(pub [u8; 64]);
impl Hash512 {
    const SIZE: usize = 64;
    pub fn new(hash512: [u8; 64]) -> Self {
        Self(hash512)
    }
    pub fn default() -> Self {
        Self([0; 64])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: PublicKey
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 32
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(32)
///*is_unsigned: True
///*size: 32
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct PublicKey(pub [u8; 32]);
impl PublicKey {
    const SIZE: usize = 32;
    pub fn new(publickey: [u8; 32]) -> Self {
        Self(publickey)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: VotingPublicKey
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 32
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(32)
///*is_unsigned: True
///*size: 32
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VotingPublicKey(pub [u8; 32]);
impl VotingPublicKey {
    const SIZE: usize = 32;
    pub fn new(votingpublickey: [u8; 32]) -> Self {
        Self(votingpublickey)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: Signature
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 64
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(64)
///*is_unsigned: True
///*size: 64
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Signature(pub [u8; 64]);
impl Signature {
    const SIZE: usize = 64;
    pub fn new(signature: [u8; 64]) -> Self {
        Self(signature)
    }
    pub fn default() -> Self {
        Self([0; 64])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: Mosaic
///disposition: None
///fields: <class 'list'>
///    mosaic_id = MosaicId
///        name: mosaic_id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    amount = Amount
///        name: amount
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Mosaic {
    pub mosaic_id: MosaicId,
    pub amount: Amount,
}
impl Mosaic {
    pub fn new(mosaic_id: MosaicId, amount: Amount) -> Self {
        Self { mosaic_id, amount }
    }
    pub fn default() -> Self {
        Self {
            mosaic_id: MosaicId::default(),
            amount: Amount::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.mosaic_id.size();
        size += self.amount.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let amount;
        (amount, payload) = Amount::deserialize(payload)?;
        let self_ = Self { mosaic_id, amount };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let mosaic_id = self.mosaic_id.serialize();
        let amount = self.amount.serialize();
        [mosaic_id.iter(), amount.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: UnresolvedMosaic
///disposition: None
///fields: <class 'list'>
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    amount = Amount
///        name: amount
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct UnresolvedMosaic {
    pub mosaic_id: UnresolvedMosaicId,
    pub amount: Amount,
}
impl UnresolvedMosaic {
    pub fn new(mosaic_id: UnresolvedMosaicId, amount: Amount) -> Self {
        Self { mosaic_id, amount }
    }
    pub fn default() -> Self {
        Self {
            mosaic_id: UnresolvedMosaicId::default(),
            amount: Amount::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.mosaic_id.size();
        size += self.amount.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let amount;
        (amount, payload) = Amount::deserialize(payload)?;
        let self_ = Self { mosaic_id, amount };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let mosaic_id = self.mosaic_id.serialize();
        let amount = self.amount.serialize();
        [mosaic_id.iter(), amount.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: LinkAction
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    UNLINK = 0
///        name: UNLINK
///        value: 0
///    LINK = 1
///        name: LINK
///        value: 1
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum LinkAction {
    UNLINK = 0,
    LINK = 1,
}
impl LinkAction {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::UNLINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((LinkAction::UNLINK, rest)),
            1 => Ok((LinkAction::LINK, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("LinkAction::{:?}", self)
    }
}
///name: NetworkType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    MAINNET = 104
///        name: MAINNET
///        value: 104
///    TESTNET = 152
///        name: TESTNET
///        value: 152
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum NetworkType {
    MAINNET = 104,
    TESTNET = 152,
}
impl NetworkType {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::MAINNET
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            104 => Ok((NetworkType::MAINNET, rest)),
            152 => Ok((NetworkType::TESTNET, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("NetworkType::{:?}", self)
    }
}
///name: TransactionType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint16
///    is_unsigned: True
///    size: 2
///    display_type: DisplayType.INTEGER
///    *name: uint16
///    *sizeref: None
///values: <class 'list'>
///    ACCOUNT_KEY_LINK = 16716
///        name: ACCOUNT_KEY_LINK
///        value: 16716
///    NODE_KEY_LINK = 16972
///        name: NODE_KEY_LINK
///        value: 16972
///    AGGREGATE_COMPLETE = 16705
///        name: AGGREGATE_COMPLETE
///        value: 16705
///    AGGREGATE_BONDED = 16961
///        name: AGGREGATE_BONDED
///        value: 16961
///    VOTING_KEY_LINK = 16707
///        name: VOTING_KEY_LINK
///        value: 16707
///    VRF_KEY_LINK = 16963
///        name: VRF_KEY_LINK
///        value: 16963
///    HASH_LOCK = 16712
///        name: HASH_LOCK
///        value: 16712
///    SECRET_LOCK = 16722
///        name: SECRET_LOCK
///        value: 16722
///    SECRET_PROOF = 16978
///        name: SECRET_PROOF
///        value: 16978
///    ACCOUNT_METADATA = 16708
///        name: ACCOUNT_METADATA
///        value: 16708
///    MOSAIC_METADATA = 16964
///        name: MOSAIC_METADATA
///        value: 16964
///    NAMESPACE_METADATA = 17220
///        name: NAMESPACE_METADATA
///        value: 17220
///    MOSAIC_DEFINITION = 16717
///        name: MOSAIC_DEFINITION
///        value: 16717
///    MOSAIC_SUPPLY_CHANGE = 16973
///        name: MOSAIC_SUPPLY_CHANGE
///        value: 16973
///    MOSAIC_SUPPLY_REVOCATION = 17229
///        name: MOSAIC_SUPPLY_REVOCATION
///        value: 17229
///    MULTISIG_ACCOUNT_MODIFICATION = 16725
///        name: MULTISIG_ACCOUNT_MODIFICATION
///        value: 16725
///    ADDRESS_ALIAS = 16974
///        name: ADDRESS_ALIAS
///        value: 16974
///    MOSAIC_ALIAS = 17230
///        name: MOSAIC_ALIAS
///        value: 17230
///    NAMESPACE_REGISTRATION = 16718
///        name: NAMESPACE_REGISTRATION
///        value: 16718
///    ACCOUNT_ADDRESS_RESTRICTION = 16720
///        name: ACCOUNT_ADDRESS_RESTRICTION
///        value: 16720
///    ACCOUNT_MOSAIC_RESTRICTION = 16976
///        name: ACCOUNT_MOSAIC_RESTRICTION
///        value: 16976
///    ACCOUNT_OPERATION_RESTRICTION = 17232
///        name: ACCOUNT_OPERATION_RESTRICTION
///        value: 17232
///    MOSAIC_ADDRESS_RESTRICTION = 16977
///        name: MOSAIC_ADDRESS_RESTRICTION
///        value: 16977
///    MOSAIC_GLOBAL_RESTRICTION = 16721
///        name: MOSAIC_GLOBAL_RESTRICTION
///        value: 16721
///    TRANSFER = 16724
///        name: TRANSFER
///        value: 16724
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 2
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum TransactionType {
    ACCOUNT_KEY_LINK = 16716,
    NODE_KEY_LINK = 16972,
    AGGREGATE_COMPLETE = 16705,
    AGGREGATE_BONDED = 16961,
    VOTING_KEY_LINK = 16707,
    VRF_KEY_LINK = 16963,
    HASH_LOCK = 16712,
    SECRET_LOCK = 16722,
    SECRET_PROOF = 16978,
    ACCOUNT_METADATA = 16708,
    MOSAIC_METADATA = 16964,
    NAMESPACE_METADATA = 17220,
    MOSAIC_DEFINITION = 16717,
    MOSAIC_SUPPLY_CHANGE = 16973,
    MOSAIC_SUPPLY_REVOCATION = 17229,
    MULTISIG_ACCOUNT_MODIFICATION = 16725,
    ADDRESS_ALIAS = 16974,
    MOSAIC_ALIAS = 17230,
    NAMESPACE_REGISTRATION = 16718,
    ACCOUNT_ADDRESS_RESTRICTION = 16720,
    ACCOUNT_MOSAIC_RESTRICTION = 16976,
    ACCOUNT_OPERATION_RESTRICTION = 17232,
    MOSAIC_ADDRESS_RESTRICTION = 16977,
    MOSAIC_GLOBAL_RESTRICTION = 16721,
    TRANSFER = 16724,
}
impl TransactionType {
    const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::ACCOUNT_KEY_LINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            16716 => Ok((TransactionType::ACCOUNT_KEY_LINK, rest)),
            16972 => Ok((TransactionType::NODE_KEY_LINK, rest)),
            16705 => Ok((TransactionType::AGGREGATE_COMPLETE, rest)),
            16961 => Ok((TransactionType::AGGREGATE_BONDED, rest)),
            16707 => Ok((TransactionType::VOTING_KEY_LINK, rest)),
            16963 => Ok((TransactionType::VRF_KEY_LINK, rest)),
            16712 => Ok((TransactionType::HASH_LOCK, rest)),
            16722 => Ok((TransactionType::SECRET_LOCK, rest)),
            16978 => Ok((TransactionType::SECRET_PROOF, rest)),
            16708 => Ok((TransactionType::ACCOUNT_METADATA, rest)),
            16964 => Ok((TransactionType::MOSAIC_METADATA, rest)),
            17220 => Ok((TransactionType::NAMESPACE_METADATA, rest)),
            16717 => Ok((TransactionType::MOSAIC_DEFINITION, rest)),
            16973 => Ok((TransactionType::MOSAIC_SUPPLY_CHANGE, rest)),
            17229 => Ok((TransactionType::MOSAIC_SUPPLY_REVOCATION, rest)),
            16725 => Ok((TransactionType::MULTISIG_ACCOUNT_MODIFICATION, rest)),
            16974 => Ok((TransactionType::ADDRESS_ALIAS, rest)),
            17230 => Ok((TransactionType::MOSAIC_ALIAS, rest)),
            16718 => Ok((TransactionType::NAMESPACE_REGISTRATION, rest)),
            16720 => Ok((TransactionType::ACCOUNT_ADDRESS_RESTRICTION, rest)),
            16976 => Ok((TransactionType::ACCOUNT_MOSAIC_RESTRICTION, rest)),
            17232 => Ok((TransactionType::ACCOUNT_OPERATION_RESTRICTION, rest)),
            16977 => Ok((TransactionType::MOSAIC_ADDRESS_RESTRICTION, rest)),
            16721 => Ok((TransactionType::MOSAIC_GLOBAL_RESTRICTION, rest)),
            16724 => Ok((TransactionType::TRANSFER, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("TransactionType::{:?}", self)
    }
}
///name: Transaction
///disposition: abstract
///fields: <class 'list'>
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: True
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Transaction {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
}
impl Transaction {
    fn version(&self) -> u8 {
        u8::default()
    }
    fn type_(&self) -> TransactionType {
        TransactionType::default()
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedTransaction
///disposition: abstract
///fields: <class 'list'>
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: True
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedTransaction {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
}
impl EmbeddedTransaction {
    fn version(&self) -> u8 {
        u8::default()
    }
    fn type_(&self) -> TransactionType {
        TransactionType::default()
    }
    pub fn new(signer_public_key: PublicKey, network: NetworkType) -> Self {
        Self {
            signer_public_key,
            network,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: ProofGamma
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 32
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(32)
///*is_unsigned: True
///*size: 32
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ProofGamma(pub [u8; 32]);
impl ProofGamma {
    const SIZE: usize = 32;
    pub fn new(proofgamma: [u8; 32]) -> Self {
        Self(proofgamma)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: ProofVerificationHash
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 16
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(16)
///*is_unsigned: True
///*size: 16
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ProofVerificationHash(pub [u8; 16]);
impl ProofVerificationHash {
    const SIZE: usize = 16;
    pub fn new(proofverificationhash: [u8; 16]) -> Self {
        Self(proofverificationhash)
    }
    pub fn default() -> Self {
        Self([0; 16])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: ProofScalar
///linked_type: <class 'catparser.ast.FixedSizeBuffer'>
///    size: 32
///    is_unsigned: True
///    display_type: DisplayType.BYTE_ARRAY
///    *name: binary_fixed(32)
///*is_unsigned: True
///*size: 32
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ProofScalar(pub [u8; 32]);
impl ProofScalar {
    const SIZE: usize = 32;
    pub fn new(proofscalar: [u8; 32]) -> Self {
        Self(proofscalar)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self::new(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }
}
///name: BlockType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint16
///    is_unsigned: True
///    size: 2
///    display_type: DisplayType.INTEGER
///    *name: uint16
///    *sizeref: None
///values: <class 'list'>
///    NEMESIS = 32835
///        name: NEMESIS
///        value: 32835
///    NORMAL = 33091
///        name: NORMAL
///        value: 33091
///    IMPORTANCE = 33347
///        name: IMPORTANCE
///        value: 33347
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 2
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum BlockType {
    NEMESIS = 32835,
    NORMAL = 33091,
    IMPORTANCE = 33347,
}
impl BlockType {
    const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::NEMESIS
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            32835 => Ok((BlockType::NEMESIS, rest)),
            33091 => Ok((BlockType::NORMAL, rest)),
            33347 => Ok((BlockType::IMPORTANCE, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("BlockType::{:?}", self)
    }
}
///name: VrfProof
///disposition: None
///fields: <class 'list'>
///    gamma = ProofGamma
///        name: gamma
///        field_type: ProofGamma
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    verification_hash = ProofVerificationHash
///        name: verification_hash
///        field_type: ProofVerificationHash
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scalar = ProofScalar
///        name: scalar
///        field_type: ProofScalar
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VrfProof {
    pub gamma: ProofGamma,
    pub verification_hash: ProofVerificationHash,
    pub scalar: ProofScalar,
}
impl VrfProof {
    pub fn new(
        gamma: ProofGamma,
        verification_hash: ProofVerificationHash,
        scalar: ProofScalar,
    ) -> Self {
        Self {
            gamma,
            verification_hash,
            scalar,
        }
    }
    pub fn default() -> Self {
        Self {
            gamma: ProofGamma::default(),
            verification_hash: ProofVerificationHash::default(),
            scalar: ProofScalar::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.gamma.size();
        size += self.verification_hash.size();
        size += self.scalar.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let gamma;
        (gamma, payload) = ProofGamma::deserialize(payload)?;
        let verification_hash;
        (verification_hash, payload) = ProofVerificationHash::deserialize(payload)?;
        let scalar;
        (scalar, payload) = ProofScalar::deserialize(payload)?;
        let self_ = Self {
            gamma,
            verification_hash,
            scalar,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let gamma = self.gamma.serialize();
        let verification_hash = self.verification_hash.serialize();
        let scalar = self.scalar.serialize();
        [gamma.iter(), verification_hash.iter(), scalar.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: Block
///disposition: abstract
///fields: <class 'list'>
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = BlockType
///        name: type
///        field_type: BlockType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    height = Height
///        name: height
///        field_type: Height
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    timestamp = Timestamp
///        name: timestamp
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    difficulty = Difficulty
///        name: difficulty
///        field_type: Difficulty
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    generation_hash_proof = VrfProof
///        name: generation_hash_proof
///        field_type: VrfProof
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_block_hash = Hash256
///        name: previous_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    receipts_hash = Hash256
///        name: receipts_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    state_hash = Hash256
///        name: state_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    beneficiary_address = Address
///        name: beneficiary_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee_multiplier = BlockFeeMultiplier
///        name: fee_multiplier
///        field_type: BlockFeeMultiplier
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, BLOCK_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            BLOCK_VERSION
///    @initializes(type, BLOCK_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            BLOCK_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
///*is_abstract: True
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Block {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
}
impl Block {
    fn version(&self) -> u8 {
        u8::default()
    }
    fn type_(&self) -> BlockType {
        BlockType::default()
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NemesisBlockV1
///disposition: None
///fields: <class 'list'>
///    BLOCK_VERSION = make_const(uint8, 1)
///        name: BLOCK_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    BLOCK_TYPE = make_const(BlockType, NEMESIS)
///        name: BLOCK_TYPE
///        field_type: BlockType
///        value: NEMESIS
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = BlockType
///        name: type
///        field_type: BlockType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    height = Height
///        name: height
///        field_type: Height
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    timestamp = Timestamp
///        name: timestamp
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    difficulty = Difficulty
///        name: difficulty
///        field_type: Difficulty
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    generation_hash_proof = VrfProof
///        name: generation_hash_proof
///        field_type: VrfProof
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_block_hash = Hash256
///        name: previous_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    receipts_hash = Hash256
///        name: receipts_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    state_hash = Hash256
///        name: state_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    beneficiary_address = Address
///        name: beneficiary_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee_multiplier = BlockFeeMultiplier
///        name: fee_multiplier
///        field_type: BlockFeeMultiplier
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    voting_eligible_accounts_count = uint32
///        name: voting_eligible_accounts_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    harvesting_eligible_accounts_count = uint64
///        name: harvesting_eligible_accounts_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    total_voting_balance = Amount
///        name: total_voting_balance
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_importance_block_hash = Hash256
///        name: previous_importance_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Transaction
///            size: 0
///            *alignment: 8
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: False
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @alignment(8, not pad_last)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    not
///                    pad_last
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Block
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, BLOCK_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            BLOCK_VERSION
///    @initializes(type, BLOCK_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            BLOCK_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NemesisBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub voting_eligible_accounts_count: u32,
    pub harvesting_eligible_accounts_count: u64,
    pub total_voting_balance: Amount,
    pub previous_importance_block_hash: Hash256,
    pub transactions: Vec<Transaction>,
}
impl NemesisBlockV1 {
    const BLOCK_VERSION: u8 = 1;
    const BLOCK_TYPE: BlockType = BlockType::NEMESIS;
    fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        voting_eligible_accounts_count: u32,
        harvesting_eligible_accounts_count: u64,
        total_voting_balance: Amount,
        previous_importance_block_hash: Hash256,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            voting_eligible_accounts_count: u32::default(),
            harvesting_eligible_accounts_count: u64::default(),
            total_voting_balance: Amount::default(),
            previous_importance_block_hash: Hash256::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        size += 8;
        size += self.total_voting_balance.size();
        size += self.previous_importance_block_hash.size();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let voting_eligible_accounts_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let harvesting_eligible_accounts_count = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let total_voting_balance;
        (total_voting_balance, payload) = Amount::deserialize(payload)?;
        let previous_importance_block_hash;
        (previous_importance_block_hash, payload) = Hash256::deserialize(payload)?;
        let mut transactions = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let voting_eligible_accounts_count = self.voting_eligible_accounts_count.to_le_bytes();
        let harvesting_eligible_accounts_count =
            self.harvesting_eligible_accounts_count.to_le_bytes();
        let total_voting_balance = self.total_voting_balance.serialize();
        let previous_importance_block_hash = self.previous_importance_block_hash.serialize();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            voting_eligible_accounts_count.iter(),
            harvesting_eligible_accounts_count.iter(),
            total_voting_balance.iter(),
            previous_importance_block_hash.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NormalBlockV1
///disposition: None
///fields: <class 'list'>
///    BLOCK_VERSION = make_const(uint8, 1)
///        name: BLOCK_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    BLOCK_TYPE = make_const(BlockType, NORMAL)
///        name: BLOCK_TYPE
///        field_type: BlockType
///        value: NORMAL
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = BlockType
///        name: type
///        field_type: BlockType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    height = Height
///        name: height
///        field_type: Height
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    timestamp = Timestamp
///        name: timestamp
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    difficulty = Difficulty
///        name: difficulty
///        field_type: Difficulty
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    generation_hash_proof = VrfProof
///        name: generation_hash_proof
///        field_type: VrfProof
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_block_hash = Hash256
///        name: previous_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    receipts_hash = Hash256
///        name: receipts_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    state_hash = Hash256
///        name: state_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    beneficiary_address = Address
///        name: beneficiary_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee_multiplier = BlockFeeMultiplier
///        name: fee_multiplier
///        field_type: BlockFeeMultiplier
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    block_header_reserved_1 = make_reserved(uint32, 0)
///        name: block_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Transaction
///            size: 0
///            *alignment: 8
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: False
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @alignment(8, not pad_last)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    not
///                    pad_last
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Block
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, BLOCK_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            BLOCK_VERSION
///    @initializes(type, BLOCK_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            BLOCK_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NormalBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub transactions: Vec<Transaction>,
}
impl NormalBlockV1 {
    const BLOCK_VERSION: u8 = 1;
    const BLOCK_TYPE: BlockType = BlockType::NORMAL;
    fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let block_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if block_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                block_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let block_header_reserved_1 = 0u32.to_le_bytes();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            block_header_reserved_1.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: ImportanceBlockV1
///disposition: None
///fields: <class 'list'>
///    BLOCK_VERSION = make_const(uint8, 1)
///        name: BLOCK_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    BLOCK_TYPE = make_const(BlockType, IMPORTANCE)
///        name: BLOCK_TYPE
///        field_type: BlockType
///        value: IMPORTANCE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = BlockType
///        name: type
///        field_type: BlockType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    height = Height
///        name: height
///        field_type: Height
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    timestamp = Timestamp
///        name: timestamp
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    difficulty = Difficulty
///        name: difficulty
///        field_type: Difficulty
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    generation_hash_proof = VrfProof
///        name: generation_hash_proof
///        field_type: VrfProof
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_block_hash = Hash256
///        name: previous_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    receipts_hash = Hash256
///        name: receipts_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    state_hash = Hash256
///        name: state_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    beneficiary_address = Address
///        name: beneficiary_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee_multiplier = BlockFeeMultiplier
///        name: fee_multiplier
///        field_type: BlockFeeMultiplier
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    voting_eligible_accounts_count = uint32
///        name: voting_eligible_accounts_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    harvesting_eligible_accounts_count = uint64
///        name: harvesting_eligible_accounts_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    total_voting_balance = Amount
///        name: total_voting_balance
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    previous_importance_block_hash = Hash256
///        name: previous_importance_block_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Transaction
///            size: 0
///            *alignment: 8
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: False
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @alignment(8, not pad_last)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    not
///                    pad_last
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Block
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, BLOCK_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            BLOCK_VERSION
///    @initializes(type, BLOCK_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            BLOCK_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ImportanceBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub voting_eligible_accounts_count: u32,
    pub harvesting_eligible_accounts_count: u64,
    pub total_voting_balance: Amount,
    pub previous_importance_block_hash: Hash256,
    pub transactions: Vec<Transaction>,
}
impl ImportanceBlockV1 {
    const BLOCK_VERSION: u8 = 1;
    const BLOCK_TYPE: BlockType = BlockType::IMPORTANCE;
    fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        voting_eligible_accounts_count: u32,
        harvesting_eligible_accounts_count: u64,
        total_voting_balance: Amount,
        previous_importance_block_hash: Hash256,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            voting_eligible_accounts_count: u32::default(),
            harvesting_eligible_accounts_count: u64::default(),
            total_voting_balance: Amount::default(),
            previous_importance_block_hash: Hash256::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        size += 8;
        size += self.total_voting_balance.size();
        size += self.previous_importance_block_hash.size();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let voting_eligible_accounts_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let harvesting_eligible_accounts_count = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let total_voting_balance;
        (total_voting_balance, payload) = Amount::deserialize(payload)?;
        let previous_importance_block_hash;
        (previous_importance_block_hash, payload) = Hash256::deserialize(payload)?;
        let mut transactions = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let voting_eligible_accounts_count = self.voting_eligible_accounts_count.to_le_bytes();
        let harvesting_eligible_accounts_count =
            self.harvesting_eligible_accounts_count.to_le_bytes();
        let total_voting_balance = self.total_voting_balance.serialize();
        let previous_importance_block_hash = self.previous_importance_block_hash.serialize();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            voting_eligible_accounts_count.iter(),
            harvesting_eligible_accounts_count.iter(),
            total_voting_balance.iter(),
            previous_importance_block_hash.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: FinalizationRound
///disposition: None
///fields: <class 'list'>
///    epoch = FinalizationEpoch
///        name: epoch
///        field_type: FinalizationEpoch
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    point = FinalizationPoint
///        name: point
///        field_type: FinalizationPoint
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct FinalizationRound {
    pub epoch: FinalizationEpoch,
    pub point: FinalizationPoint,
}
impl FinalizationRound {
    pub fn new(epoch: FinalizationEpoch, point: FinalizationPoint) -> Self {
        Self { epoch, point }
    }
    pub fn default() -> Self {
        Self {
            epoch: FinalizationEpoch::default(),
            point: FinalizationPoint::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.epoch.size();
        size += self.point.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let epoch;
        (epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let point;
        (point, payload) = FinalizationPoint::deserialize(payload)?;
        let self_ = Self { epoch, point };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let epoch = self.epoch.serialize();
        let point = self.point.serialize();
        [epoch.iter(), point.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: FinalizedBlockHeader
///disposition: None
///fields: <class 'list'>
///    round = FinalizationRound
///        name: round
///        field_type: FinalizationRound
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    height = Height
///        name: height
///        field_type: Height
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    hash = Hash256
///        name: hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct FinalizedBlockHeader {
    pub round: FinalizationRound,
    pub height: Height,
    pub hash: Hash256,
}
impl FinalizedBlockHeader {
    pub fn new(round: FinalizationRound, height: Height, hash: Hash256) -> Self {
        Self {
            round,
            height,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            round: FinalizationRound::default(),
            height: Height::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.round.size();
        size += self.height.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let round;
        (round, payload) = FinalizationRound::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            round,
            height,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let round = self.round.serialize();
        let height = self.height.serialize();
        let hash = self.hash.serialize();
        [round.iter(), height.iter(), hash.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: ReceiptType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint16
///    is_unsigned: True
///    size: 2
///    display_type: DisplayType.INTEGER
///    *name: uint16
///    *sizeref: None
///values: <class 'list'>
///    MOSAIC_RENTAL_FEE = 4685
///        name: MOSAIC_RENTAL_FEE
///        value: 4685
///    NAMESPACE_RENTAL_FEE = 4942
///        name: NAMESPACE_RENTAL_FEE
///        value: 4942
///    HARVEST_FEE = 8515
///        name: HARVEST_FEE
///        value: 8515
///    LOCK_HASH_COMPLETED = 8776
///        name: LOCK_HASH_COMPLETED
///        value: 8776
///    LOCK_HASH_EXPIRED = 9032
///        name: LOCK_HASH_EXPIRED
///        value: 9032
///    LOCK_SECRET_COMPLETED = 8786
///        name: LOCK_SECRET_COMPLETED
///        value: 8786
///    LOCK_SECRET_EXPIRED = 9042
///        name: LOCK_SECRET_EXPIRED
///        value: 9042
///    LOCK_HASH_CREATED = 12616
///        name: LOCK_HASH_CREATED
///        value: 12616
///    LOCK_SECRET_CREATED = 12626
///        name: LOCK_SECRET_CREATED
///        value: 12626
///    MOSAIC_EXPIRED = 16717
///        name: MOSAIC_EXPIRED
///        value: 16717
///    NAMESPACE_EXPIRED = 16718
///        name: NAMESPACE_EXPIRED
///        value: 16718
///    NAMESPACE_DELETED = 16974
///        name: NAMESPACE_DELETED
///        value: 16974
///    INFLATION = 20803
///        name: INFLATION
///        value: 20803
///    TRANSACTION_GROUP = 57667
///        name: TRANSACTION_GROUP
///        value: 57667
///    ADDRESS_ALIAS_RESOLUTION = 61763
///        name: ADDRESS_ALIAS_RESOLUTION
///        value: 61763
///    MOSAIC_ALIAS_RESOLUTION = 62019
///        name: MOSAIC_ALIAS_RESOLUTION
///        value: 62019
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 2
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum ReceiptType {
    MOSAIC_RENTAL_FEE = 4685,
    NAMESPACE_RENTAL_FEE = 4942,
    HARVEST_FEE = 8515,
    LOCK_HASH_COMPLETED = 8776,
    LOCK_HASH_EXPIRED = 9032,
    LOCK_SECRET_COMPLETED = 8786,
    LOCK_SECRET_EXPIRED = 9042,
    LOCK_HASH_CREATED = 12616,
    LOCK_SECRET_CREATED = 12626,
    MOSAIC_EXPIRED = 16717,
    NAMESPACE_EXPIRED = 16718,
    NAMESPACE_DELETED = 16974,
    INFLATION = 20803,
    TRANSACTION_GROUP = 57667,
    ADDRESS_ALIAS_RESOLUTION = 61763,
    MOSAIC_ALIAS_RESOLUTION = 62019,
}
impl ReceiptType {
    const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::MOSAIC_RENTAL_FEE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            4685 => Ok((ReceiptType::MOSAIC_RENTAL_FEE, rest)),
            4942 => Ok((ReceiptType::NAMESPACE_RENTAL_FEE, rest)),
            8515 => Ok((ReceiptType::HARVEST_FEE, rest)),
            8776 => Ok((ReceiptType::LOCK_HASH_COMPLETED, rest)),
            9032 => Ok((ReceiptType::LOCK_HASH_EXPIRED, rest)),
            8786 => Ok((ReceiptType::LOCK_SECRET_COMPLETED, rest)),
            9042 => Ok((ReceiptType::LOCK_SECRET_EXPIRED, rest)),
            12616 => Ok((ReceiptType::LOCK_HASH_CREATED, rest)),
            12626 => Ok((ReceiptType::LOCK_SECRET_CREATED, rest)),
            16717 => Ok((ReceiptType::MOSAIC_EXPIRED, rest)),
            16718 => Ok((ReceiptType::NAMESPACE_EXPIRED, rest)),
            16974 => Ok((ReceiptType::NAMESPACE_DELETED, rest)),
            20803 => Ok((ReceiptType::INFLATION, rest)),
            57667 => Ok((ReceiptType::TRANSACTION_GROUP, rest)),
            61763 => Ok((ReceiptType::ADDRESS_ALIAS_RESOLUTION, rest)),
            62019 => Ok((ReceiptType::MOSAIC_ALIAS_RESOLUTION, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("ReceiptType::{:?}", self)
    }
}
///name: Receipt
///disposition: abstract
///fields: <class 'list'>
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: True
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Receipt {
    pub version: u16,
}
impl Receipt {
    fn type_(&self) -> ReceiptType {
        ReceiptType::default()
    }
    pub fn new(version: u16) -> Self {
        Self { version }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let self_ = Self { version };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        [size.iter(), version.iter(), type_.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: HarvestFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, HARVEST_FEE)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: HARVEST_FEE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct HarvestFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl HarvestFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::HARVEST_FEE;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: InflationReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, INFLATION)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: INFLATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct InflationReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
}
impl InflationReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::INFLATION;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic) -> Self {
        Self { version, mosaic }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let self_ = Self { version, mosaic };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        [size.iter(), version.iter(), type_.iter(), mosaic.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: LockHashCreatedFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_CREATED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_HASH_CREATED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockHashCreatedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashCreatedFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_CREATED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockHashCompletedFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_COMPLETED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_HASH_COMPLETED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockHashCompletedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashCompletedFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_COMPLETED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockHashExpiredFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_EXPIRED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_HASH_EXPIRED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockHashExpiredFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashExpiredFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_EXPIRED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockSecretCreatedFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_CREATED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_SECRET_CREATED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockSecretCreatedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretCreatedFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_CREATED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockSecretCompletedFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_COMPLETED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_SECRET_COMPLETED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockSecretCompletedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretCompletedFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_COMPLETED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockSecretExpiredFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_EXPIRED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: LOCK_SECRET_EXPIRED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = Address
///        name: target_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct LockSecretExpiredFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretExpiredFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_EXPIRED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicExpiredReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, MOSAIC_EXPIRED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: MOSAIC_EXPIRED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    artifact_id = MosaicId
///        name: artifact_id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicExpiredReceipt {
    pub version: u16,
    pub artifact_id: MosaicId,
}
impl MosaicExpiredReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_EXPIRED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: MosaicId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: MosaicId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = MosaicId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicRentalFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, MOSAIC_RENTAL_FEE)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: MOSAIC_RENTAL_FEE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    sender_address = Address
///        name: sender_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = Address
///        name: recipient_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicRentalFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub sender_address: Address,
    pub recipient_address: Address,
}
impl MosaicRentalFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_RENTAL_FEE;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(
        version: u16,
        mosaic: Mosaic,
        sender_address: Address,
        recipient_address: Address,
    ) -> Self {
        Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            sender_address: Address::default(),
            recipient_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.sender_address.size();
        size += self.recipient_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let sender_address;
        (sender_address, payload) = Address::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let sender_address = self.sender_address.serialize();
        let recipient_address = self.recipient_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            sender_address.iter(),
            recipient_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NamespaceId
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceId(pub u64);
impl NamespaceId {
    const SIZE: usize = 8;
    pub fn new(namespaceid: u64) -> Self {
        Self(namespaceid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: NamespaceRegistrationType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    ROOT = 0
///        name: ROOT
///        value: 0
///    CHILD = 1
///        name: CHILD
///        value: 1
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum NamespaceRegistrationType {
    ROOT = 0,
    CHILD = 1,
}
impl NamespaceRegistrationType {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::ROOT
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((NamespaceRegistrationType::ROOT, rest)),
            1 => Ok((NamespaceRegistrationType::CHILD, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("NamespaceRegistrationType::{:?}", self)
    }
}
///name: AliasAction
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    UNLINK = 0
///        name: UNLINK
///        value: 0
///    LINK = 1
///        name: LINK
///        value: 1
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum AliasAction {
    UNLINK = 0,
    LINK = 1,
}
impl AliasAction {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::UNLINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((AliasAction::UNLINK, rest)),
            1 => Ok((AliasAction::LINK, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("AliasAction::{:?}", self)
    }
}
///name: NamespaceExpiredReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_EXPIRED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: NAMESPACE_EXPIRED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    artifact_id = NamespaceId
///        name: artifact_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceExpiredReceipt {
    pub version: u16,
    pub artifact_id: NamespaceId,
}
impl NamespaceExpiredReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_EXPIRED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: NamespaceId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: NamespaceId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = NamespaceId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NamespaceDeletedReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_DELETED)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: NAMESPACE_DELETED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    artifact_id = NamespaceId
///        name: artifact_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceDeletedReceipt {
    pub version: u16,
    pub artifact_id: NamespaceId,
}
impl NamespaceDeletedReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_DELETED;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: NamespaceId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: NamespaceId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = NamespaceId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NamespaceRentalFeeReceipt
///disposition: None
///fields: <class 'list'>
///    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_RENTAL_FEE)
///        name: RECEIPT_TYPE
///        field_type: ReceiptType
///        value: NAMESPACE_RENTAL_FEE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint16
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    type = ReceiptType
///        name: type
///        field_type: ReceiptType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = Mosaic
///        name: mosaic
///        field_type: Mosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    sender_address = Address
///        name: sender_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = Address
///        name: recipient_address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Receipt
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(type, RECEIPT_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            RECEIPT_TYPE
///    @discriminator(type)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type']
///*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceRentalFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub sender_address: Address,
    pub recipient_address: Address,
}
impl NamespaceRentalFeeReceipt {
    const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_RENTAL_FEE;
    fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(
        version: u16,
        mosaic: Mosaic,
        sender_address: Address,
        recipient_address: Address,
    ) -> Self {
        Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            sender_address: Address::default(),
            recipient_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.sender_address.size();
        size += self.recipient_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type_;
        (_type_, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let sender_address;
        (sender_address, payload) = Address::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let sender_address = self.sender_address.serialize();
        let recipient_address = self.recipient_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            sender_address.iter(),
            recipient_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: ReceiptSource
///disposition: None
///fields: <class 'list'>
///    primary_id = uint32
///        name: primary_id
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    secondary_id = uint32
///        name: secondary_id
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ReceiptSource {
    pub primary_id: u32,
    pub secondary_id: u32,
}
impl ReceiptSource {
    pub fn new(primary_id: u32, secondary_id: u32) -> Self {
        Self {
            primary_id,
            secondary_id,
        }
    }
    pub fn default() -> Self {
        Self {
            primary_id: u32::default(),
            secondary_id: u32::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let primary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let secondary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let self_ = Self {
            primary_id,
            secondary_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let primary_id = self.primary_id.to_le_bytes();
        let secondary_id = self.secondary_id.to_le_bytes();
        [primary_id.iter(), secondary_id.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: AddressResolutionEntry
///disposition: None
///fields: <class 'list'>
///    source = ReceiptSource
///        name: source
///        field_type: ReceiptSource
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    resolved_value = Address
///        name: resolved_value
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AddressResolutionEntry {
    pub source: ReceiptSource,
    pub resolved_value: Address,
}
impl AddressResolutionEntry {
    pub fn new(source: ReceiptSource, resolved_value: Address) -> Self {
        Self {
            source,
            resolved_value,
        }
    }
    pub fn default() -> Self {
        Self {
            source: ReceiptSource::default(),
            resolved_value: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.source.size();
        size += self.resolved_value.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let source;
        (source, payload) = ReceiptSource::deserialize(payload)?;
        let resolved_value;
        (resolved_value, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            source,
            resolved_value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let source = self.source.serialize();
        let resolved_value = self.resolved_value.serialize();
        [source.iter(), resolved_value.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: AddressResolutionStatement
///disposition: None
///fields: <class 'list'>
///    unresolved = UnresolvedAddress
///        name: unresolved
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    resolution_entries_count = uint32
///        name: resolution_entries_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    resolution_entries = array(AddressResolutionEntry, resolution_entries_count)
///        name: resolution_entries
///        field_type: <class 'catparser.ast.Array'>
///            element_type: AddressResolutionEntry
///            size: resolution_entries_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: resolution_entries_count
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AddressResolutionStatement {
    pub unresolved: UnresolvedAddress,
    pub resolution_entries: Vec<AddressResolutionEntry>,
}
impl AddressResolutionStatement {
    pub fn new(
        unresolved: UnresolvedAddress,
        resolution_entries: Vec<AddressResolutionEntry>,
    ) -> Self {
        Self {
            unresolved,
            resolution_entries,
        }
    }
    pub fn default() -> Self {
        Self {
            unresolved: UnresolvedAddress::default(),
            resolution_entries: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.unresolved.size();
        size += 4;
        size += self
            .resolution_entries
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let unresolved;
        (unresolved, payload) = UnresolvedAddress::deserialize(payload)?;
        let resolution_entries_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut resolution_entries = Vec::new();
        for _ in 0..resolution_entries_count {
            let element;
            (element, payload) = AddressResolutionEntry::deserialize(payload)?;
            resolution_entries.push(element);
        }
        let self_ = Self {
            unresolved,
            resolution_entries,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let unresolved = self.unresolved.serialize();
        let resolution_entries_count = self.resolution_entries.len().to_le_bytes();
        let resolution_entries: Vec<u8> = self
            .resolution_entries
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            unresolved.iter(),
            resolution_entries_count.iter(),
            resolution_entries.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicResolutionEntry
///disposition: None
///fields: <class 'list'>
///    source = ReceiptSource
///        name: source
///        field_type: ReceiptSource
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    resolved_value = MosaicId
///        name: resolved_value
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicResolutionEntry {
    pub source: ReceiptSource,
    pub resolved_value: MosaicId,
}
impl MosaicResolutionEntry {
    pub fn new(source: ReceiptSource, resolved_value: MosaicId) -> Self {
        Self {
            source,
            resolved_value,
        }
    }
    pub fn default() -> Self {
        Self {
            source: ReceiptSource::default(),
            resolved_value: MosaicId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.source.size();
        size += self.resolved_value.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let source;
        (source, payload) = ReceiptSource::deserialize(payload)?;
        let resolved_value;
        (resolved_value, payload) = MosaicId::deserialize(payload)?;
        let self_ = Self {
            source,
            resolved_value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let source = self.source.serialize();
        let resolved_value = self.resolved_value.serialize();
        [source.iter(), resolved_value.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: MosaicResolutionStatement
///disposition: None
///fields: <class 'list'>
///    unresolved = UnresolvedMosaicId
///        name: unresolved
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    resolution_entries_count = uint32
///        name: resolution_entries_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    resolution_entries = array(MosaicResolutionEntry, resolution_entries_count)
///        name: resolution_entries
///        field_type: <class 'catparser.ast.Array'>
///            element_type: MosaicResolutionEntry
///            size: resolution_entries_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: resolution_entries_count
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicResolutionStatement {
    pub unresolved: UnresolvedMosaicId,
    pub resolution_entries: Vec<MosaicResolutionEntry>,
}
impl MosaicResolutionStatement {
    pub fn new(
        unresolved: UnresolvedMosaicId,
        resolution_entries: Vec<MosaicResolutionEntry>,
    ) -> Self {
        Self {
            unresolved,
            resolution_entries,
        }
    }
    pub fn default() -> Self {
        Self {
            unresolved: UnresolvedMosaicId::default(),
            resolution_entries: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.unresolved.size();
        size += 4;
        size += self
            .resolution_entries
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let unresolved;
        (unresolved, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let resolution_entries_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut resolution_entries = Vec::new();
        for _ in 0..resolution_entries_count {
            let element;
            (element, payload) = MosaicResolutionEntry::deserialize(payload)?;
            resolution_entries.push(element);
        }
        let self_ = Self {
            unresolved,
            resolution_entries,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let unresolved = self.unresolved.serialize();
        let resolution_entries_count = self.resolution_entries.len().to_le_bytes();
        let resolution_entries: Vec<u8> = self
            .resolution_entries
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            unresolved.iter(),
            resolution_entries_count.iter(),
            resolution_entries.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: TransactionStatement
///disposition: None
///fields: <class 'list'>
///    primary_id = uint32
///        name: primary_id
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    secondary_id = uint32
///        name: secondary_id
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    receipt_count = uint32
///        name: receipt_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    receipts = array(Receipt, receipt_count)
///        name: receipts
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Receipt
///            size: receipt_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: receipt_count
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct TransactionStatement {
    pub primary_id: u32,
    pub secondary_id: u32,
    pub receipts: Vec<Receipt>,
}
impl TransactionStatement {
    pub fn new(primary_id: u32, secondary_id: u32, receipts: Vec<Receipt>) -> Self {
        Self {
            primary_id,
            secondary_id,
            receipts,
        }
    }
    pub fn default() -> Self {
        Self {
            primary_id: u32::default(),
            secondary_id: u32::default(),
            receipts: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += 4;
        size += self.receipts.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let primary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let secondary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let receipt_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut receipts = Vec::new();
        for _ in 0..receipt_count {
            let element;
            (element, payload) = Receipt::deserialize(payload)?;
            receipts.push(element);
        }
        let self_ = Self {
            primary_id,
            secondary_id,
            receipts,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let primary_id = self.primary_id.to_le_bytes();
        let secondary_id = self.secondary_id.to_le_bytes();
        let receipt_count = self.receipts.len().to_le_bytes();
        let receipts: Vec<u8> = self.receipts.iter().flat_map(|x| x.serialize()).collect();
        [
            primary_id.iter(),
            secondary_id.iter(),
            receipt_count.iter(),
            receipts.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: BlockStatement
///disposition: None
///fields: <class 'list'>
///    transaction_statement_count = uint32
///        name: transaction_statement_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    transaction_statements = array(TransactionStatement, transaction_statement_count)
///        name: transaction_statements
///        field_type: <class 'catparser.ast.Array'>
///            element_type: TransactionStatement
///            size: transaction_statement_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: transaction_statement_count
///    address_resolution_statement_count = uint32
///        name: address_resolution_statement_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    address_resolution_statements = array(AddressResolutionStatement, address_resolution_statement_count)
///        name: address_resolution_statements
///        field_type: <class 'catparser.ast.Array'>
///            element_type: AddressResolutionStatement
///            size: address_resolution_statement_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: address_resolution_statement_count
///    mosaic_resolution_statement_count = uint32
///        name: mosaic_resolution_statement_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    mosaic_resolution_statements = array(MosaicResolutionStatement, mosaic_resolution_statement_count)
///        name: mosaic_resolution_statements
///        field_type: <class 'catparser.ast.Array'>
///            element_type: MosaicResolutionStatement
///            size: mosaic_resolution_statement_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: mosaic_resolution_statement_count
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: None
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: None
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct BlockStatement {
    pub transaction_statements: Vec<TransactionStatement>,
    pub address_resolution_statements: Vec<AddressResolutionStatement>,
    pub mosaic_resolution_statements: Vec<MosaicResolutionStatement>,
}
impl BlockStatement {
    pub fn new(
        transaction_statements: Vec<TransactionStatement>,
        address_resolution_statements: Vec<AddressResolutionStatement>,
        mosaic_resolution_statements: Vec<MosaicResolutionStatement>,
    ) -> Self {
        Self {
            transaction_statements,
            address_resolution_statements,
            mosaic_resolution_statements,
        }
    }
    pub fn default() -> Self {
        Self {
            transaction_statements: Vec::new(),
            address_resolution_statements: Vec::new(),
            mosaic_resolution_statements: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += self
            .transaction_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += 4;
        size += self
            .address_resolution_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += 4;
        size += self
            .mosaic_resolution_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let transaction_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut transaction_statements = Vec::new();
        for _ in 0..transaction_statement_count {
            let element;
            (element, payload) = TransactionStatement::deserialize(payload)?;
            transaction_statements.push(element);
        }
        let address_resolution_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut address_resolution_statements = Vec::new();
        for _ in 0..address_resolution_statement_count {
            let element;
            (element, payload) = AddressResolutionStatement::deserialize(payload)?;
            address_resolution_statements.push(element);
        }
        let mosaic_resolution_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut mosaic_resolution_statements = Vec::new();
        for _ in 0..mosaic_resolution_statement_count {
            let element;
            (element, payload) = MosaicResolutionStatement::deserialize(payload)?;
            mosaic_resolution_statements.push(element);
        }
        let self_ = Self {
            transaction_statements,
            address_resolution_statements,
            mosaic_resolution_statements,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let transaction_statement_count = self.transaction_statements.len().to_le_bytes();
        let transaction_statements: Vec<u8> = self
            .transaction_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_resolution_statement_count =
            self.address_resolution_statements.len().to_le_bytes();
        let address_resolution_statements: Vec<u8> = self
            .address_resolution_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let mosaic_resolution_statement_count =
            self.mosaic_resolution_statements.len().to_le_bytes();
        let mosaic_resolution_statements: Vec<u8> = self
            .mosaic_resolution_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            transaction_statement_count.iter(),
            transaction_statements.iter(),
            address_resolution_statement_count.iter(),
            address_resolution_statements.iter(),
            mosaic_resolution_statement_count.iter(),
            mosaic_resolution_statements.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AccountKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AccountKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl AccountKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAccountKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAccountKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedAccountKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NodeKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NODE_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NODE_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NodeKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl NodeKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedNodeKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NODE_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NODE_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedNodeKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedNodeKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: Cosignature
///disposition: None
///fields: <class 'list'>
///    version = uint64
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Cosignature {
    pub version: u64,
    pub signer_public_key: PublicKey,
    pub signature: Signature,
}
impl Cosignature {
    pub fn new(version: u64, signer_public_key: PublicKey, signature: Signature) -> Self {
        Self {
            version,
            signer_public_key,
            signature,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u64::default(),
            signer_public_key: PublicKey::default(),
            signature: Signature::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 8;
        size += self.signer_public_key.size();
        size += self.signature.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let version = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let self_ = Self {
            version,
            signer_public_key,
            signature,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let version = self.version.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let signature = self.signature.serialize();
        [version.iter(), signer_public_key.iter(), signature.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///name: DetachedCosignature
///disposition: None
///fields: <class 'list'>
///    version = uint64
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    parent_hash = Hash256
///        name: parent_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: None
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: None
///*initializers: []
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: None
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct DetachedCosignature {
    pub version: u64,
    pub signer_public_key: PublicKey,
    pub signature: Signature,
    pub parent_hash: Hash256,
}
impl DetachedCosignature {
    pub fn new(
        version: u64,
        signer_public_key: PublicKey,
        signature: Signature,
        parent_hash: Hash256,
    ) -> Self {
        Self {
            version,
            signer_public_key,
            signature,
            parent_hash,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u64::default(),
            signer_public_key: PublicKey::default(),
            signature: Signature::default(),
            parent_hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 8;
        size += self.signer_public_key.size();
        size += self.signature.size();
        size += self.parent_hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let version = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let parent_hash;
        (parent_hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            version,
            signer_public_key,
            signature,
            parent_hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let version = self.version.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let signature = self.signature.serialize();
        let parent_hash = self.parent_hash.serialize();
        [
            version.iter(),
            signer_public_key.iter(),
            signature.iter(),
            parent_hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AggregateCompleteTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_COMPLETE)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: AGGREGATE_COMPLETE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    payload_size = uint32
///        name: payload_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    aggregate_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: aggregate_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: EmbeddedTransaction
///            size: payload_size
///            *alignment: 8
///            *disposition: array sized
///            *is_byte_constrained: True
///            *is_expandable: False
///            *is_last_element_padded: True
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @is_byte_constrained
///                name: is_byte_constrained
///                is_flag: True
///                value: True
///                values: <class 'list'>
///            @alignment(8, None, None)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    None
///                    None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: payload_size
///    cosignatures = array(Cosignature, __FILL__)
///        name: cosignatures
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Cosignature
///            size: 0
///            *alignment: None
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AggregateCompleteTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += self.transactions.iter().map(|x| x.size()).sum::<usize>();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        for _ in 0..payload_size {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
        }
        let mut cosignatures = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = self.transactions.len().to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AggregateCompleteTransactionV2
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 2)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 2
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_COMPLETE)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: AGGREGATE_COMPLETE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    payload_size = uint32
///        name: payload_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    aggregate_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: aggregate_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: EmbeddedTransaction
///            size: payload_size
///            *alignment: 8
///            *disposition: array sized
///            *is_byte_constrained: True
///            *is_expandable: False
///            *is_last_element_padded: True
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @is_byte_constrained
///                name: is_byte_constrained
///                is_flag: True
///                value: True
///                values: <class 'list'>
///            @alignment(8, None, None)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    None
///                    None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: payload_size
///    cosignatures = array(Cosignature, __FILL__)
///        name: cosignatures
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Cosignature
///            size: 0
///            *alignment: None
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AggregateCompleteTransactionV2 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV2 {
    const TRANSACTION_VERSION: u8 = 2;
    const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += self.transactions.iter().map(|x| x.size()).sum::<usize>();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        for _ in 0..payload_size {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
        }
        let mut cosignatures = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = self.transactions.len().to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AggregateBondedTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_BONDED)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: AGGREGATE_BONDED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    payload_size = uint32
///        name: payload_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    aggregate_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: aggregate_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: EmbeddedTransaction
///            size: payload_size
///            *alignment: 8
///            *disposition: array sized
///            *is_byte_constrained: True
///            *is_expandable: False
///            *is_last_element_padded: True
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @is_byte_constrained
///                name: is_byte_constrained
///                is_flag: True
///                value: True
///                values: <class 'list'>
///            @alignment(8, None, None)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    None
///                    None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: payload_size
///    cosignatures = array(Cosignature, __FILL__)
///        name: cosignatures
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Cosignature
///            size: 0
///            *alignment: None
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AggregateBondedTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += self.transactions.iter().map(|x| x.size()).sum::<usize>();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        for _ in 0..payload_size {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
        }
        let mut cosignatures = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = self.transactions.len().to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AggregateBondedTransactionV2
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 2)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 2
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_BONDED)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: AGGREGATE_BONDED
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    transactions_hash = Hash256
///        name: transactions_hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    payload_size = uint32
///        name: payload_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    aggregate_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: aggregate_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
///        name: transactions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: EmbeddedTransaction
///            size: payload_size
///            *alignment: 8
///            *disposition: array sized
///            *is_byte_constrained: True
///            *is_expandable: False
///            *is_last_element_padded: True
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @is_byte_constrained
///                name: is_byte_constrained
///                is_flag: True
///                value: True
///                values: <class 'list'>
///            @alignment(8, None, None)
///                name: alignment
///                is_flag: False
///                value: 8
///                values: <class 'list'>
///                    8
///                    None
///                    None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: payload_size
///    cosignatures = array(Cosignature, __FILL__)
///        name: cosignatures
///        field_type: <class 'catparser.ast.Array'>
///            element_type: Cosignature
///            size: 0
///            *alignment: None
///            *disposition: array fill
///            *is_byte_constrained: False
///            *is_expandable: True
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: 0
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AggregateBondedTransactionV2 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV2 {
    const TRANSACTION_VERSION: u8 = 2;
    const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += self.transactions.iter().map(|x| x.size()).sum::<usize>();
        size += 0;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        for _ in 0..payload_size {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
        }
        let mut cosignatures = Vec::new();
        for _ in 0..0 {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = self.transactions.len().to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let transactions: Vec<u8> = self
            .transactions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: VotingKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, VOTING_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: VOTING_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = VotingPublicKey
///        name: linked_public_key
///        field_type: VotingPublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    start_epoch = FinalizationEpoch
///        name: start_epoch
///        field_type: FinalizationEpoch
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    end_epoch = FinalizationEpoch
///        name: end_epoch
///        field_type: FinalizationEpoch
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VotingKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: VotingPublicKey,
    pub start_epoch: FinalizationEpoch,
    pub end_epoch: FinalizationEpoch,
    pub link_action: LinkAction,
}
impl VotingKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: VotingPublicKey,
        start_epoch: FinalizationEpoch,
        end_epoch: FinalizationEpoch,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: VotingPublicKey::default(),
            start_epoch: FinalizationEpoch::default(),
            end_epoch: FinalizationEpoch::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.start_epoch.size();
        size += self.end_epoch.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = VotingPublicKey::deserialize(payload)?;
        let start_epoch;
        (start_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let end_epoch;
        (end_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let start_epoch = self.start_epoch.serialize();
        let end_epoch = self.end_epoch.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            start_epoch.iter(),
            end_epoch.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedVotingKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, VOTING_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: VOTING_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = VotingPublicKey
///        name: linked_public_key
///        field_type: VotingPublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    start_epoch = FinalizationEpoch
///        name: start_epoch
///        field_type: FinalizationEpoch
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    end_epoch = FinalizationEpoch
///        name: end_epoch
///        field_type: FinalizationEpoch
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedVotingKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: VotingPublicKey,
    pub start_epoch: FinalizationEpoch,
    pub end_epoch: FinalizationEpoch,
    pub link_action: LinkAction,
}
impl EmbeddedVotingKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: VotingPublicKey,
        start_epoch: FinalizationEpoch,
        end_epoch: FinalizationEpoch,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: VotingPublicKey::default(),
            start_epoch: FinalizationEpoch::default(),
            end_epoch: FinalizationEpoch::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.start_epoch.size();
        size += self.end_epoch.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = VotingPublicKey::deserialize(payload)?;
        let start_epoch;
        (start_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let end_epoch;
        (end_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let start_epoch = self.start_epoch.serialize();
        let end_epoch = self.end_epoch.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            start_epoch.iter(),
            end_epoch.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: VrfKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, VRF_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: VRF_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VrfKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl VrfKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedVrfKeyLinkTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, VRF_KEY_LINK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: VRF_KEY_LINK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    linked_public_key = PublicKey
///        name: linked_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    link_action = LinkAction
///        name: link_action
///        field_type: LinkAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedVrfKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedVrfKeyLinkTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: HashLockTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, HASH_LOCK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: HASH_LOCK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    hash = Hash256
///        name: hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct HashLockTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash: Hash256,
}
impl HashLockTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash: Hash256,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic,
            duration,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic,
            duration,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash = self.hash.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic.iter(),
            duration.iter(),
            hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedHashLockTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, HASH_LOCK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: HASH_LOCK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    hash = Hash256
///        name: hash
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedHashLockTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash: Hash256,
}
impl EmbeddedHashLockTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash: Hash256,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic,
            duration,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic,
            duration,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash = self.hash.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic.iter(),
            duration.iter(),
            hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: LockHashAlgorithm
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    SHA3_256 = 0
///        name: SHA3_256
///        value: 0
///    HASH_160 = 1
///        name: HASH_160
///        value: 1
///    HASH_256 = 2
///        name: HASH_256
///        value: 2
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum LockHashAlgorithm {
    SHA3_256 = 0,
    HASH_160 = 1,
    HASH_256 = 2,
}
impl LockHashAlgorithm {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::SHA3_256
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((LockHashAlgorithm::SHA3_256, rest)),
            1 => Ok((LockHashAlgorithm::HASH_160, rest)),
            2 => Ok((LockHashAlgorithm::HASH_256, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("LockHashAlgorithm::{:?}", self)
    }
}
///name: SecretLockTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, SECRET_LOCK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: SECRET_LOCK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    secret = Hash256
///        name: secret
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    hash_algorithm = LockHashAlgorithm
///        name: hash_algorithm
///        field_type: LockHashAlgorithm
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct SecretLockTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash_algorithm: LockHashAlgorithm,
}
impl SecretLockTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash_algorithm: LockHashAlgorithm,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash_algorithm: LockHashAlgorithm::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash_algorithm.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash_algorithm = self.hash_algorithm.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            secret.iter(),
            mosaic.iter(),
            duration.iter(),
            hash_algorithm.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedSecretLockTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, SECRET_LOCK)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: SECRET_LOCK
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    secret = Hash256
///        name: secret
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    hash_algorithm = LockHashAlgorithm
///        name: hash_algorithm
///        field_type: LockHashAlgorithm
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedSecretLockTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash_algorithm: LockHashAlgorithm,
}
impl EmbeddedSecretLockTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash_algorithm: LockHashAlgorithm,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash_algorithm: LockHashAlgorithm::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash_algorithm.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash_algorithm = self.hash_algorithm.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            secret.iter(),
            mosaic.iter(),
            duration.iter(),
            hash_algorithm.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: SecretProofTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, SECRET_PROOF)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: SECRET_PROOF
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    secret = Hash256
///        name: secret
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    proof_size = uint16
///        name: proof_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    hash_algorithm = LockHashAlgorithm
///        name: hash_algorithm
///        field_type: LockHashAlgorithm
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    proof = array(uint8, proof_size)
///        name: proof
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: proof_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: proof_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct SecretProofTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub hash_algorithm: LockHashAlgorithm,
    pub proof: Vec<u8>,
}
impl SecretProofTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        hash_algorithm: LockHashAlgorithm,
        proof: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            hash_algorithm: LockHashAlgorithm::default(),
            proof: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += 2;
        size += self.hash_algorithm.size();
        size += 1 * self.proof.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let proof_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let mut proof = Vec::new();
        for _ in 0..proof_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            proof.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let proof_size = self.proof.len().to_le_bytes();
        let hash_algorithm = self.hash_algorithm.serialize();
        let proof: Vec<u8> = self.proof.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            secret.iter(),
            proof_size.iter(),
            hash_algorithm.iter(),
            proof.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedSecretProofTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, SECRET_PROOF)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: SECRET_PROOF
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    secret = Hash256
///        name: secret
///        field_type: Hash256
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    proof_size = uint16
///        name: proof_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    hash_algorithm = LockHashAlgorithm
///        name: hash_algorithm
///        field_type: LockHashAlgorithm
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    proof = array(uint8, proof_size)
///        name: proof
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: proof_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: proof_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedSecretProofTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub hash_algorithm: LockHashAlgorithm,
    pub proof: Vec<u8>,
}
impl EmbeddedSecretProofTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        hash_algorithm: LockHashAlgorithm,
        proof: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            hash_algorithm: LockHashAlgorithm::default(),
            proof: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += 2;
        size += self.hash_algorithm.size();
        size += 1 * self.proof.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let proof_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let mut proof = Vec::new();
        for _ in 0..proof_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            proof.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let proof_size = self.proof.len().to_le_bytes();
        let hash_algorithm = self.hash_algorithm.serialize();
        let proof: Vec<u8> = self.proof.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            secret.iter(),
            proof_size.iter(),
            hash_algorithm.iter(),
            proof.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AccountMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AccountMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl AccountMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAccountMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAccountMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedAccountMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_mosaic_id = UnresolvedMosaicId
///        name: target_mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_mosaic_id: UnresolvedMosaicId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl MosaicMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_mosaic_id: UnresolvedMosaicId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_mosaic_id: UnresolvedMosaicId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += self.target_mosaic_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_mosaic_id;
        (target_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_mosaic_id = self.target_mosaic_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_mosaic_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_mosaic_id = UnresolvedMosaicId
///        name: target_mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_mosaic_id: UnresolvedMosaicId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedMosaicMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_mosaic_id: UnresolvedMosaicId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_mosaic_id: UnresolvedMosaicId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += self.target_mosaic_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_mosaic_id;
        (target_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_mosaic_id = self.target_mosaic_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_mosaic_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NamespaceMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NAMESPACE_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_namespace_id = NamespaceId
///        name: target_namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_namespace_id: NamespaceId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl NamespaceMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_namespace_id: NamespaceId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_namespace_id: NamespaceId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += self.target_namespace_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_namespace_id;
        (target_namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_namespace_id = self.target_namespace_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_namespace_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedNamespaceMetadataTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_METADATA)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NAMESPACE_METADATA
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    scoped_metadata_key = uint64
///        name: scoped_metadata_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_namespace_id = NamespaceId
///        name: target_namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    value_size_delta = int16
///        name: value_size_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int16
///            is_unsigned: False
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: int16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 2
///    value_size = uint16
///        name: value_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    value = array(uint8, value_size)
///        name: value
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: value_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: value_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedNamespaceMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_namespace_id: NamespaceId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedNamespaceMetadataTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_namespace_id: NamespaceId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_namespace_id: NamespaceId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += self.target_namespace_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_namespace_id;
        (target_namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_namespace_id = self.target_namespace_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = self.value.len().to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_namespace_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicNonce
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint32
///    is_unsigned: True
///    size: 4
///    display_type: DisplayType.INTEGER
///    *name: uint32
///    *sizeref: None
///*is_unsigned: True
///*size: 4
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicNonce(pub u32);
impl MosaicNonce {
    const SIZE: usize = 4;
    pub fn new(mosaicnonce: u32) -> Self {
        Self(mosaicnonce)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:08x}", self.0)
    }
}
///name: MosaicFlags
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    NONE = 0
///        name: NONE
///        value: 0
///    SUPPLY_MUTABLE = 1
///        name: SUPPLY_MUTABLE
///        value: 1
///    TRANSFERABLE = 2
///        name: TRANSFERABLE
///        value: 2
///    RESTRICTABLE = 4
///        name: RESTRICTABLE
///        value: 4
///    REVOKABLE = 8
///        name: REVOKABLE
///        value: 8
///display_type: DisplayType.ENUM
///attributes: <class 'list'>
///    @is_bitwise
///        name: is_bitwise
///        is_flag: True
///        value: True
///        values: <class 'list'>
///*is_bitwise: True
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum MosaicFlags {
    NONE = 0,
    SUPPLY_MUTABLE = 1,
    TRANSFERABLE = 2,
    RESTRICTABLE = 4,
    REVOKABLE = 8,
}
impl MosaicFlags {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::NONE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicFlags::NONE, rest)),
            1 => Ok((MosaicFlags::SUPPLY_MUTABLE, rest)),
            2 => Ok((MosaicFlags::TRANSFERABLE, rest)),
            4 => Ok((MosaicFlags::RESTRICTABLE, rest)),
            8 => Ok((MosaicFlags::REVOKABLE, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("MosaicFlags::{:?}", self)
    }
}
///name: MosaicSupplyChangeAction
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    DECREASE = 0
///        name: DECREASE
///        value: 0
///    INCREASE = 1
///        name: INCREASE
///        value: 1
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum MosaicSupplyChangeAction {
    DECREASE = 0,
    INCREASE = 1,
}
impl MosaicSupplyChangeAction {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::DECREASE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicSupplyChangeAction::DECREASE, rest)),
            1 => Ok((MosaicSupplyChangeAction::INCREASE, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("MosaicSupplyChangeAction::{:?}", self)
    }
}
///name: MosaicDefinitionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_DEFINITION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_DEFINITION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    id = MosaicId
///        name: id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    nonce = MosaicNonce
///        name: nonce
///        field_type: MosaicNonce
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    flags = MosaicFlags
///        name: flags
///        field_type: MosaicFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    divisibility = uint8
///        name: divisibility
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicDefinitionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub id: MosaicId,
    pub duration: BlockDuration,
    pub nonce: MosaicNonce,
    pub flags: MosaicFlags,
    pub divisibility: u8,
}
impl MosaicDefinitionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        id: MosaicId,
        duration: BlockDuration,
        nonce: MosaicNonce,
        flags: MosaicFlags,
        divisibility: u8,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            id: MosaicId::default(),
            duration: BlockDuration::default(),
            nonce: MosaicNonce::default(),
            flags: MosaicFlags::default(),
            divisibility: u8::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.id.size();
        size += self.duration.size();
        size += self.nonce.size();
        size += self.flags.size();
        size += 1;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let id;
        (id, payload) = MosaicId::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let nonce;
        (nonce, payload) = MosaicNonce::deserialize(payload)?;
        let flags;
        (flags, payload) = MosaicFlags::deserialize(payload)?;
        let divisibility = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let id = self.id.serialize();
        let duration = self.duration.serialize();
        let nonce = self.nonce.serialize();
        let flags = self.flags.serialize();
        let divisibility = self.divisibility.to_le_bytes();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            id.iter(),
            duration.iter(),
            nonce.iter(),
            flags.iter(),
            divisibility.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicDefinitionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_DEFINITION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_DEFINITION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    id = MosaicId
///        name: id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration
///        name: duration
///        field_type: BlockDuration
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    nonce = MosaicNonce
///        name: nonce
///        field_type: MosaicNonce
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    flags = MosaicFlags
///        name: flags
///        field_type: MosaicFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    divisibility = uint8
///        name: divisibility
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicDefinitionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub id: MosaicId,
    pub duration: BlockDuration,
    pub nonce: MosaicNonce,
    pub flags: MosaicFlags,
    pub divisibility: u8,
}
impl EmbeddedMosaicDefinitionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        id: MosaicId,
        duration: BlockDuration,
        nonce: MosaicNonce,
        flags: MosaicFlags,
        divisibility: u8,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            id: MosaicId::default(),
            duration: BlockDuration::default(),
            nonce: MosaicNonce::default(),
            flags: MosaicFlags::default(),
            divisibility: u8::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.id.size();
        size += self.duration.size();
        size += self.nonce.size();
        size += self.flags.size();
        size += 1;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let id;
        (id, payload) = MosaicId::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let nonce;
        (nonce, payload) = MosaicNonce::deserialize(payload)?;
        let flags;
        (flags, payload) = MosaicFlags::deserialize(payload)?;
        let divisibility = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let self_ = Self {
            signer_public_key,
            network,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let id = self.id.serialize();
        let duration = self.duration.serialize();
        let nonce = self.nonce.serialize();
        let flags = self.flags.serialize();
        let divisibility = self.divisibility.to_le_bytes();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            id.iter(),
            duration.iter(),
            nonce.iter(),
            flags.iter(),
            divisibility.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicSupplyChangeTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_CHANGE)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_SUPPLY_CHANGE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    delta = Amount
///        name: delta
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    action = MosaicSupplyChangeAction
///        name: action
///        field_type: MosaicSupplyChangeAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicSupplyChangeTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub delta: Amount,
    pub action: MosaicSupplyChangeAction,
}
impl MosaicSupplyChangeTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        delta: Amount,
        action: MosaicSupplyChangeAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            delta,
            action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            delta: Amount::default(),
            action: MosaicSupplyChangeAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += self.delta.size();
        size += self.action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let delta;
        (delta, payload) = Amount::deserialize(payload)?;
        let action;
        (action, payload) = MosaicSupplyChangeAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            delta,
            action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let delta = self.delta.serialize();
        let action = self.action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            delta.iter(),
            action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicSupplyChangeTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_CHANGE)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_SUPPLY_CHANGE
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    delta = Amount
///        name: delta
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    action = MosaicSupplyChangeAction
///        name: action
///        field_type: MosaicSupplyChangeAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicSupplyChangeTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub delta: Amount,
    pub action: MosaicSupplyChangeAction,
}
impl EmbeddedMosaicSupplyChangeTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        delta: Amount,
        action: MosaicSupplyChangeAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            delta,
            action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            delta: Amount::default(),
            action: MosaicSupplyChangeAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += self.delta.size();
        size += self.action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let delta;
        (delta, payload) = Amount::deserialize(payload)?;
        let action;
        (action, payload) = MosaicSupplyChangeAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            delta,
            action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let delta = self.delta.serialize();
        let action = self.action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            delta.iter(),
            action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicSupplyRevocationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_REVOCATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_SUPPLY_REVOCATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    source_address = UnresolvedAddress
///        name: source_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicSupplyRevocationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub source_address: UnresolvedAddress,
    pub mosaic: UnresolvedMosaic,
}
impl MosaicSupplyRevocationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        source_address: UnresolvedAddress,
        mosaic: UnresolvedMosaic,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            source_address,
            mosaic,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            source_address: UnresolvedAddress::default(),
            mosaic: UnresolvedMosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.source_address.size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let source_address;
        (source_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            source_address,
            mosaic,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let source_address = self.source_address.serialize();
        let mosaic = self.mosaic.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            source_address.iter(),
            mosaic.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicSupplyRevocationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_REVOCATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_SUPPLY_REVOCATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    source_address = UnresolvedAddress
///        name: source_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic = UnresolvedMosaic
///        name: mosaic
///        field_type: UnresolvedMosaic
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicSupplyRevocationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub source_address: UnresolvedAddress,
    pub mosaic: UnresolvedMosaic,
}
impl EmbeddedMosaicSupplyRevocationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        source_address: UnresolvedAddress,
        mosaic: UnresolvedMosaic,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            source_address,
            mosaic,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            source_address: UnresolvedAddress::default(),
            mosaic: UnresolvedMosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.source_address.size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let source_address;
        (source_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            source_address,
            mosaic,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let source_address = self.source_address.serialize();
        let mosaic = self.mosaic.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            source_address.iter(),
            mosaic.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MultisigAccountModificationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MULTISIG_ACCOUNT_MODIFICATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MULTISIG_ACCOUNT_MODIFICATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    min_removal_delta = int8
///        name: min_removal_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int8
///            is_unsigned: False
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: int8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 1
///    min_approval_delta = int8
///        name: min_approval_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int8
///            is_unsigned: False
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: int8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 1
///    address_additions_count = uint8
///        name: address_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    address_deletions_count = uint8
///        name: address_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    multisig_account_modification_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: multisig_account_modification_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    address_additions = array(UnresolvedAddress, address_additions_count)
///        name: address_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: address_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: address_additions_count
///    address_deletions = array(UnresolvedAddress, address_deletions_count)
///        name: address_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: address_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: address_deletions_count
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MultisigAccountModificationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub min_removal_delta: i8,
    pub min_approval_delta: i8,
    pub address_additions: Vec<UnresolvedAddress>,
    pub address_deletions: Vec<UnresolvedAddress>,
}
impl MultisigAccountModificationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        min_removal_delta: i8,
        min_approval_delta: i8,
        address_additions: Vec<UnresolvedAddress>,
        address_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            min_removal_delta: i8::default(),
            min_approval_delta: i8::default(),
            address_additions: Vec::new(),
            address_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        size += 4;
        size += self
            .address_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .address_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let min_removal_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let min_approval_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let multisig_account_modification_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if multisig_account_modification_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                multisig_account_modification_transaction_body_reserved_1 as u32,
            ));
        }
        let mut address_additions = Vec::new();
        for _ in 0..address_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_additions.push(element);
        }
        let mut address_deletions = Vec::new();
        for _ in 0..address_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let min_removal_delta = self.min_removal_delta.to_le_bytes();
        let min_approval_delta = self.min_approval_delta.to_le_bytes();
        let address_additions_count = self.address_additions.len().to_le_bytes();
        let address_deletions_count = self.address_deletions.len().to_le_bytes();
        let multisig_account_modification_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let address_additions: Vec<u8> = self
            .address_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_deletions: Vec<u8> = self
            .address_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            min_removal_delta.iter(),
            min_approval_delta.iter(),
            address_additions_count.iter(),
            address_deletions_count.iter(),
            multisig_account_modification_transaction_body_reserved_1.iter(),
            address_additions.iter(),
            address_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMultisigAccountModificationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MULTISIG_ACCOUNT_MODIFICATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MULTISIG_ACCOUNT_MODIFICATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    min_removal_delta = int8
///        name: min_removal_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int8
///            is_unsigned: False
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: int8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 1
///    min_approval_delta = int8
///        name: min_approval_delta
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: int8
///            is_unsigned: False
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: int8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: False
///        *size: 1
///    address_additions_count = uint8
///        name: address_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    address_deletions_count = uint8
///        name: address_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    multisig_account_modification_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: multisig_account_modification_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    address_additions = array(UnresolvedAddress, address_additions_count)
///        name: address_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: address_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: address_additions_count
///    address_deletions = array(UnresolvedAddress, address_deletions_count)
///        name: address_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: address_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: address_deletions_count
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMultisigAccountModificationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub min_removal_delta: i8,
    pub min_approval_delta: i8,
    pub address_additions: Vec<UnresolvedAddress>,
    pub address_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedMultisigAccountModificationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        min_removal_delta: i8,
        min_approval_delta: i8,
        address_additions: Vec<UnresolvedAddress>,
        address_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            min_removal_delta: i8::default(),
            min_approval_delta: i8::default(),
            address_additions: Vec::new(),
            address_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        size += 4;
        size += self
            .address_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .address_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let min_removal_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let min_approval_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let multisig_account_modification_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if multisig_account_modification_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                multisig_account_modification_transaction_body_reserved_1 as u32,
            ));
        }
        let mut address_additions = Vec::new();
        for _ in 0..address_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_additions.push(element);
        }
        let mut address_deletions = Vec::new();
        for _ in 0..address_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let min_removal_delta = self.min_removal_delta.to_le_bytes();
        let min_approval_delta = self.min_approval_delta.to_le_bytes();
        let address_additions_count = self.address_additions.len().to_le_bytes();
        let address_deletions_count = self.address_deletions.len().to_le_bytes();
        let multisig_account_modification_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let address_additions: Vec<u8> = self
            .address_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_deletions: Vec<u8> = self
            .address_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            min_removal_delta.iter(),
            min_approval_delta.iter(),
            address_additions_count.iter(),
            address_deletions_count.iter(),
            multisig_account_modification_transaction_body_reserved_1.iter(),
            address_additions.iter(),
            address_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AddressAliasTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ADDRESS_ALIAS)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ADDRESS_ALIAS
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    namespace_id = NamespaceId
///        name: namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    address = Address
///        name: address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    alias_action = AliasAction
///        name: alias_action
///        field_type: AliasAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AddressAliasTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub namespace_id: NamespaceId,
    pub address: Address,
    pub alias_action: AliasAction,
}
impl AddressAliasTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        namespace_id: NamespaceId,
        address: Address,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            address,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            namespace_id: NamespaceId::default(),
            address: Address::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.namespace_id.size();
        size += self.address.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let address;
        (address, payload) = Address::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            address,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let namespace_id = self.namespace_id.serialize();
        let address = self.address.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            namespace_id.iter(),
            address.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAddressAliasTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ADDRESS_ALIAS)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ADDRESS_ALIAS
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    namespace_id = NamespaceId
///        name: namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    address = Address
///        name: address
///        field_type: Address
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    alias_action = AliasAction
///        name: alias_action
///        field_type: AliasAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAddressAliasTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub namespace_id: NamespaceId,
    pub address: Address,
    pub alias_action: AliasAction,
}
impl EmbeddedAddressAliasTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        namespace_id: NamespaceId,
        address: Address,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            namespace_id,
            address,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            namespace_id: NamespaceId::default(),
            address: Address::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.namespace_id.size();
        size += self.address.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let address;
        (address, payload) = Address::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            namespace_id,
            address,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let namespace_id = self.namespace_id.serialize();
        let address = self.address.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            namespace_id.iter(),
            address.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicAliasTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ALIAS)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_ALIAS
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    namespace_id = NamespaceId
///        name: namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = MosaicId
///        name: mosaic_id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    alias_action = AliasAction
///        name: alias_action
///        field_type: AliasAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicAliasTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub namespace_id: NamespaceId,
    pub mosaic_id: MosaicId,
    pub alias_action: AliasAction,
}
impl MosaicAliasTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        namespace_id: NamespaceId,
        mosaic_id: MosaicId,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            mosaic_id,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            namespace_id: NamespaceId::default(),
            mosaic_id: MosaicId::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.namespace_id.size();
        size += self.mosaic_id.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            mosaic_id,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let namespace_id = self.namespace_id.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            namespace_id.iter(),
            mosaic_id.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicAliasTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ALIAS)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_ALIAS
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    namespace_id = NamespaceId
///        name: namespace_id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = MosaicId
///        name: mosaic_id
///        field_type: MosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    alias_action = AliasAction
///        name: alias_action
///        field_type: AliasAction
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicAliasTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub namespace_id: NamespaceId,
    pub mosaic_id: MosaicId,
    pub alias_action: AliasAction,
}
impl EmbeddedMosaicAliasTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        namespace_id: NamespaceId,
        mosaic_id: MosaicId,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            namespace_id,
            mosaic_id,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            namespace_id: NamespaceId::default(),
            mosaic_id: MosaicId::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.namespace_id.size();
        size += self.mosaic_id.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            namespace_id,
            mosaic_id,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let namespace_id = self.namespace_id.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            namespace_id.iter(),
            mosaic_id.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: NamespaceRegistrationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_REGISTRATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NAMESPACE_REGISTRATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration if ROOT equals registration_type
///        name: duration
///        field_type: BlockDuration
///        value: <class 'catparser.ast.Conditional'>
///            linked_field_name: registration_type
///            operation: equals
///            value: ROOT
///        disposition: None
///        attributes: None
///        *is_conditional: True
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    parent_id = NamespaceId if CHILD equals registration_type
///        name: parent_id
///        field_type: NamespaceId
///        value: <class 'catparser.ast.Conditional'>
///            linked_field_name: registration_type
///            operation: equals
///            value: CHILD
///        disposition: None
///        attributes: None
///        *is_conditional: True
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    id = NamespaceId
///        name: id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    registration_type = NamespaceRegistrationType
///        name: registration_type
///        field_type: NamespaceRegistrationType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    name_size = uint8
///        name: name_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    name = array(uint8, name_size)
///        name: name
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: name_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: name_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct NamespaceRegistrationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub duration: BlockDuration,
    pub parent_id: NamespaceId,
    pub id: NamespaceId,
    pub registration_type_: NamespaceRegistrationType,
    pub name: Vec<u8>,
}
impl NamespaceRegistrationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        duration: BlockDuration,
        parent_id: NamespaceId,
        id: NamespaceId,
        registration_type_: NamespaceRegistrationType,
        name: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            duration,
            parent_id,
            id,
            registration_type_,
            name,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            duration: BlockDuration::default(),
            parent_id: NamespaceId::default(),
            id: NamespaceId::default(),
            registration_type_: NamespaceRegistrationType::default(),
            name: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.duration.size();
        size += self.parent_id.size();
        size += self.id.size();
        size += self.registration_type_.size();
        size += 1;
        size += 1 * self.name.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let parent_id;
        (parent_id, payload) = NamespaceId::deserialize(payload)?;
        let id;
        (id, payload) = NamespaceId::deserialize(payload)?;
        let registration_type_;
        (registration_type_, payload) = NamespaceRegistrationType::deserialize(payload)?;
        let name_size = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let mut name = Vec::new();
        for _ in 0..name_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            name.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            duration,
            parent_id,
            id,
            registration_type_,
            name,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let duration = self.duration.serialize();
        let parent_id = self.parent_id.serialize();
        let id = self.id.serialize();
        let registration_type_ = self.registration_type_.serialize();
        let name_size = self.name.len().to_le_bytes();
        let name: Vec<u8> = self.name.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            duration.iter(),
            parent_id.iter(),
            id.iter(),
            registration_type_.iter(),
            name_size.iter(),
            name.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedNamespaceRegistrationTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_REGISTRATION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: NAMESPACE_REGISTRATION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    duration = BlockDuration if ROOT equals registration_type
///        name: duration
///        field_type: BlockDuration
///        value: <class 'catparser.ast.Conditional'>
///            linked_field_name: registration_type
///            operation: equals
///            value: ROOT
///        disposition: None
///        attributes: None
///        *is_conditional: True
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    parent_id = NamespaceId if CHILD equals registration_type
///        name: parent_id
///        field_type: NamespaceId
///        value: <class 'catparser.ast.Conditional'>
///            linked_field_name: registration_type
///            operation: equals
///            value: CHILD
///        disposition: None
///        attributes: None
///        *is_conditional: True
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    id = NamespaceId
///        name: id
///        field_type: NamespaceId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    registration_type = NamespaceRegistrationType
///        name: registration_type
///        field_type: NamespaceRegistrationType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    name_size = uint8
///        name: name_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    name = array(uint8, name_size)
///        name: name
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: name_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: name_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedNamespaceRegistrationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub duration: BlockDuration,
    pub parent_id: NamespaceId,
    pub id: NamespaceId,
    pub registration_type_: NamespaceRegistrationType,
    pub name: Vec<u8>,
}
impl EmbeddedNamespaceRegistrationTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        duration: BlockDuration,
        parent_id: NamespaceId,
        id: NamespaceId,
        registration_type_: NamespaceRegistrationType,
        name: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            duration,
            parent_id,
            id,
            registration_type_,
            name,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            duration: BlockDuration::default(),
            parent_id: NamespaceId::default(),
            id: NamespaceId::default(),
            registration_type_: NamespaceRegistrationType::default(),
            name: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.duration.size();
        size += self.parent_id.size();
        size += self.id.size();
        size += self.registration_type_.size();
        size += 1;
        size += 1 * self.name.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let parent_id;
        (parent_id, payload) = NamespaceId::deserialize(payload)?;
        let id;
        (id, payload) = NamespaceId::deserialize(payload)?;
        let registration_type_;
        (registration_type_, payload) = NamespaceRegistrationType::deserialize(payload)?;
        let name_size = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let mut name = Vec::new();
        for _ in 0..name_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            name.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            duration,
            parent_id,
            id,
            registration_type_,
            name,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let duration = self.duration.serialize();
        let parent_id = self.parent_id.serialize();
        let id = self.id.serialize();
        let registration_type_ = self.registration_type_.serialize();
        let name_size = self.name.len().to_le_bytes();
        let name: Vec<u8> = self.name.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            duration.iter(),
            parent_id.iter(),
            id.iter(),
            registration_type_.iter(),
            name_size.iter(),
            name.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AccountRestrictionFlags
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint16
///    is_unsigned: True
///    size: 2
///    display_type: DisplayType.INTEGER
///    *name: uint16
///    *sizeref: None
///values: <class 'list'>
///    ADDRESS = 1
///        name: ADDRESS
///        value: 1
///    MOSAIC_ID = 2
///        name: MOSAIC_ID
///        value: 2
///    TRANSACTION_TYPE = 4
///        name: TRANSACTION_TYPE
///        value: 4
///    OUTGOING = 16384
///        name: OUTGOING
///        value: 16384
///    BLOCK = 32768
///        name: BLOCK
///        value: 32768
///display_type: DisplayType.ENUM
///attributes: <class 'list'>
///    @is_bitwise
///        name: is_bitwise
///        is_flag: True
///        value: True
///        values: <class 'list'>
///*is_bitwise: True
///*is_unsigned: True
///*size: 2
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum AccountRestrictionFlags {
    ADDRESS = 1,
    MOSAIC_ID = 2,
    TRANSACTION_TYPE = 4,
    OUTGOING = 16384,
    BLOCK = 32768,
}
impl AccountRestrictionFlags {
    const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::ADDRESS
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            1 => Ok((AccountRestrictionFlags::ADDRESS, rest)),
            2 => Ok((AccountRestrictionFlags::MOSAIC_ID, rest)),
            4 => Ok((AccountRestrictionFlags::TRANSACTION_TYPE, rest)),
            16384 => Ok((AccountRestrictionFlags::OUTGOING, rest)),
            32768 => Ok((AccountRestrictionFlags::BLOCK, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("AccountRestrictionFlags::{:?}", self)
    }
}
///name: AccountAddressRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_ADDRESS_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_ADDRESS_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(UnresolvedAddress, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(UnresolvedAddress, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AccountAddressRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedAddress>,
    pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl AccountAddressRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedAddress>,
        restriction_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAccountAddressRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_ADDRESS_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_ADDRESS_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(UnresolvedAddress, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(UnresolvedAddress, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedAddress
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAccountAddressRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedAddress>,
    pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedAccountAddressRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedAddress>,
        restriction_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AccountMosaicRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_MOSAIC_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_MOSAIC_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(UnresolvedMosaicId, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaicId
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(UnresolvedMosaicId, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaicId
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AccountMosaicRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedMosaicId>,
    pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl AccountMosaicRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedMosaicId>,
        restriction_deletions: Vec<UnresolvedMosaicId>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAccountMosaicRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_MOSAIC_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_MOSAIC_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(UnresolvedMosaicId, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaicId
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(UnresolvedMosaicId, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaicId
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAccountMosaicRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedMosaicId>,
    pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl EmbeddedAccountMosaicRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedMosaicId>,
        restriction_deletions: Vec<UnresolvedMosaicId>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: AccountOperationRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_OPERATION_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_OPERATION_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(TransactionType, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: TransactionType
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(TransactionType, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: TransactionType
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct AccountOperationRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<TransactionType>,
    pub restriction_deletions: Vec<TransactionType>,
}
impl AccountOperationRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<TransactionType>,
        restriction_deletions: Vec<TransactionType>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedAccountOperationRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_OPERATION_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: ACCOUNT_OPERATION_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_flags = AccountRestrictionFlags
///        name: restriction_flags
///        field_type: AccountRestrictionFlags
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_additions_count = uint8
///        name: restriction_additions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    restriction_deletions_count = uint8
///        name: restriction_deletions_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    account_restriction_transaction_body_reserved_1 = make_reserved(uint32, 0)
///        name: account_restriction_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    restriction_additions = array(TransactionType, restriction_additions_count)
///        name: restriction_additions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: TransactionType
///            size: restriction_additions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_additions_count
///    restriction_deletions = array(TransactionType, restriction_deletions_count)
///        name: restriction_deletions
///        field_type: <class 'catparser.ast.Array'>
///            element_type: TransactionType
///            size: restriction_deletions_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: restriction_deletions_count
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedAccountOperationRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<TransactionType>,
    pub restriction_deletions: Vec<TransactionType>,
}
impl EmbeddedAccountOperationRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<TransactionType>,
        restriction_deletions: Vec<TransactionType>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = self.restriction_additions.len().to_le_bytes();
        let restriction_deletions_count = self.restriction_deletions.len().to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicAddressRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ADDRESS_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_ADDRESS_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_key = uint64
///        name: restriction_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_value = uint64
///        name: previous_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    new_restriction_value = uint64
///        name: new_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicAddressRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub target_address: UnresolvedAddress,
}
impl MosaicAddressRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        target_address: UnresolvedAddress,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            target_address: UnresolvedAddress::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicAddressRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ADDRESS_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_ADDRESS_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_key = uint64
///        name: restriction_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_value = uint64
///        name: previous_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    new_restriction_value = uint64
///        name: new_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    target_address = UnresolvedAddress
///        name: target_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicAddressRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub target_address: UnresolvedAddress,
}
impl EmbeddedMosaicAddressRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        target_address: UnresolvedAddress,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            target_address: UnresolvedAddress::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: MosaicRestrictionKey
///linked_type: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint64
///    is_unsigned: True
///    size: 8
///    display_type: DisplayType.INTEGER
///    *name: uint64
///    *sizeref: None
///*is_unsigned: True
///*size: 8
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicRestrictionKey(pub u64);
impl MosaicRestrictionKey {
    const SIZE: usize = 8;
    pub fn new(mosaicrestrictionkey: u64) -> Self {
        Self(mosaicrestrictionkey)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self::new(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("0x{:016x}", self.0)
    }
}
///name: MosaicRestrictionType
///base: <class 'catparser.ast.FixedSizeInteger'>
///    short_name: uint8
///    is_unsigned: True
///    size: 1
///    display_type: DisplayType.INTEGER
///    *name: uint8
///    *sizeref: None
///values: <class 'list'>
///    NONE = 0
///        name: NONE
///        value: 0
///    EQ = 1
///        name: EQ
///        value: 1
///    NE = 2
///        name: NE
///        value: 2
///    LT = 3
///        name: LT
///        value: 3
///    LE = 4
///        name: LE
///        value: 4
///    GT = 5
///        name: GT
///        value: 5
///    GE = 6
///        name: GE
///        value: 6
///display_type: DisplayType.ENUM
///attributes: None
///*is_bitwise: None
///*is_unsigned: True
///*size: 1
#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[allow(non_camel_case_types)]
pub enum MosaicRestrictionType {
    NONE = 0,
    EQ = 1,
    NE = 2,
    LT = 3,
    LE = 4,
    GT = 5,
    GE = 6,
}
impl MosaicRestrictionType {
    const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::NONE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: Self::SIZE,
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicRestrictionType::NONE, rest)),
            1 => Ok((MosaicRestrictionType::EQ, rest)),
            2 => Ok((MosaicRestrictionType::NE, rest)),
            3 => Ok((MosaicRestrictionType::LT, rest)),
            4 => Ok((MosaicRestrictionType::LE, rest)),
            5 => Ok((MosaicRestrictionType::GT, rest)),
            6 => Ok((MosaicRestrictionType::GE, rest)),
            other => Err(SymbolError::EnumDecodeError(other as u32)),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
    pub fn to_string(&self) -> String {
        format!("MosaicRestrictionType::{:?}", self)
    }
}
///name: MosaicGlobalRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_GLOBAL_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_GLOBAL_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    reference_mosaic_id = UnresolvedMosaicId
///        name: reference_mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_key = uint64
///        name: restriction_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_value = uint64
///        name: previous_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    new_restriction_value = uint64
///        name: new_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_type = MosaicRestrictionType
///        name: previous_restriction_type
///        field_type: MosaicRestrictionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    new_restriction_type = MosaicRestrictionType
///        name: new_restriction_type
///        field_type: MosaicRestrictionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct MosaicGlobalRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub reference_mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub previous_restriction_type_: MosaicRestrictionType,
    pub new_restriction_type_: MosaicRestrictionType,
}
impl MosaicGlobalRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        reference_mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        previous_restriction_type_: MosaicRestrictionType,
        new_restriction_type_: MosaicRestrictionType,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type_,
            new_restriction_type_,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            reference_mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            previous_restriction_type_: MosaicRestrictionType::default(),
            new_restriction_type_: MosaicRestrictionType::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += self.reference_mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.previous_restriction_type_.size();
        size += self.new_restriction_type_.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let reference_mosaic_id;
        (reference_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_type_;
        (previous_restriction_type_, payload) = MosaicRestrictionType::deserialize(payload)?;
        let new_restriction_type_;
        (new_restriction_type_, payload) = MosaicRestrictionType::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type_,
            new_restriction_type_,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let reference_mosaic_id = self.reference_mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let previous_restriction_type_ = self.previous_restriction_type_.serialize();
        let new_restriction_type_ = self.new_restriction_type_.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            reference_mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            previous_restriction_type_.iter(),
            new_restriction_type_.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedMosaicGlobalRestrictionTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_GLOBAL_RESTRICTION)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: MOSAIC_GLOBAL_RESTRICTION
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    mosaic_id = UnresolvedMosaicId
///        name: mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    reference_mosaic_id = UnresolvedMosaicId
///        name: reference_mosaic_id
///        field_type: UnresolvedMosaicId
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    restriction_key = uint64
///        name: restriction_key
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_value = uint64
///        name: previous_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    new_restriction_value = uint64
///        name: new_restriction_value
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint64
///            is_unsigned: True
///            size: 8
///            display_type: DisplayType.INTEGER
///            *name: uint64
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 8
///    previous_restriction_type = MosaicRestrictionType
///        name: previous_restriction_type
///        field_type: MosaicRestrictionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    new_restriction_type = MosaicRestrictionType
///        name: new_restriction_type
///        field_type: MosaicRestrictionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedMosaicGlobalRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub reference_mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub previous_restriction_type_: MosaicRestrictionType,
    pub new_restriction_type_: MosaicRestrictionType,
}
impl EmbeddedMosaicGlobalRestrictionTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        reference_mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        previous_restriction_type_: MosaicRestrictionType,
        new_restriction_type_: MosaicRestrictionType,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type_,
            new_restriction_type_,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            reference_mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            previous_restriction_type_: MosaicRestrictionType::default(),
            new_restriction_type_: MosaicRestrictionType::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += self.reference_mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.previous_restriction_type_.size();
        size += self.new_restriction_type_.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let reference_mosaic_id;
        (reference_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_type_;
        (previous_restriction_type_, payload) = MosaicRestrictionType::deserialize(payload)?;
        let new_restriction_type_;
        (new_restriction_type_, payload) = MosaicRestrictionType::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type_,
            new_restriction_type_,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let reference_mosaic_id = self.reference_mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let previous_restriction_type_ = self.previous_restriction_type_.serialize();
        let new_restriction_type_ = self.new_restriction_type_.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            reference_mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            previous_restriction_type_.iter(),
            new_restriction_type_.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: TransferTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, TRANSFER)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: TRANSFER
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    verifiable_entity_header_reserved_1 = make_reserved(uint32, 0)
///        name: verifiable_entity_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signature = Signature
///        name: signature
///        field_type: Signature
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    fee = Amount
///        name: fee
///        field_type: Amount
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    deadline = Timestamp
///        name: deadline
///        field_type: Timestamp
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    message_size = uint16
///        name: message_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    mosaics_count = uint8
///        name: mosaics_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    transfer_transaction_body_reserved_1 = make_reserved(uint8, 0)
///        name: transfer_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    transfer_transaction_body_reserved_2 = make_reserved(uint32, 0)
///        name: transfer_transaction_body_reserved_2
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @sort_key(mosaic_id) mosaics = array(UnresolvedMosaic, mosaics_count)
///        name: mosaics
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaic
///            size: mosaics_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: mosaic_id
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @sort_key(mosaic_id)
///                name: sort_key
///                is_flag: False
///                value: mosaic_id
///                values: <class 'list'>
///                    mosaic_id
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: mosaics_count
///    message = array(uint8, message_size)
///        name: message
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: message_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: message_size
///factory_type: Transaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct TransferTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub mosaics: Vec<UnresolvedMosaic>,
    pub message: Vec<u8>,
}
impl TransferTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signature: Signature,
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        mosaics: Vec<UnresolvedMosaic>,
        message: Vec<u8>,
    ) -> Self {
        Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            mosaics,
            message,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            mosaics: Vec::new(),
            message: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        size += self.mosaics.iter().map(|x| x.size()).sum::<usize>();
        size += 1 * self.message.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let message_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mosaics_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let transfer_transaction_body_reserved_1 = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        if transfer_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_1 as u32,
            ));
        }
        let transfer_transaction_body_reserved_2 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if transfer_transaction_body_reserved_2 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_2 as u32,
            ));
        }
        let mut mosaics = Vec::new();
        for _ in 0..mosaics_count {
            let element;
            (element, payload) = UnresolvedMosaic::deserialize(payload)?;
            mosaics.push(element);
        }
        let mut message = Vec::new();
        for _ in 0..message_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            message.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            mosaics,
            message,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let message_size = self.message.len().to_le_bytes();
        let mosaics_count = self.mosaics.len().to_le_bytes();
        let transfer_transaction_body_reserved_1 = 0u8.to_le_bytes();
        let transfer_transaction_body_reserved_2 = 0u32.to_le_bytes();
        let mosaics: Vec<u8> = self.mosaics.iter().flat_map(|x| x.serialize()).collect();
        let message: Vec<u8> = self.message.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            message_size.iter(),
            mosaics_count.iter(),
            transfer_transaction_body_reserved_1.iter(),
            transfer_transaction_body_reserved_2.iter(),
            mosaics.iter(),
            message.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///name: EmbeddedTransferTransactionV1
///disposition: None
///fields: <class 'list'>
///    TRANSACTION_VERSION = make_const(uint8, 1)
///        name: TRANSACTION_VERSION
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 1
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    TRANSACTION_TYPE = make_const(TransactionType, TRANSFER)
///        name: TRANSACTION_TYPE
///        field_type: TransactionType
///        value: TRANSFER
///        disposition: const
///        attributes: None
///        *is_conditional: False
///        *is_const: True
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    size = uint32
///        name: size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    embedded_transaction_header_reserved_1 = make_reserved(uint32, 0)
///        name: embedded_transaction_header_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    signer_public_key = PublicKey
///        name: signer_public_key
///        field_type: PublicKey
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    entity_body_reserved_1 = make_reserved(uint32, 0)
///        name: entity_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    version = uint8
///        name: version
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    network = NetworkType
///        name: network
///        field_type: NetworkType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    type = TransactionType
///        name: type
///        field_type: TransactionType
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    recipient_address = UnresolvedAddress
///        name: recipient_address
///        field_type: UnresolvedAddress
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: None
///    message_size = uint16
///        name: message_size
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint16
///            is_unsigned: True
///            size: 2
///            display_type: DisplayType.INTEGER
///            *name: uint16
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 2
///    mosaics_count = uint8
///        name: mosaics_count
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    transfer_transaction_body_reserved_1 = make_reserved(uint8, 0)
///        name: transfer_transaction_body_reserved_1
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint8
///            is_unsigned: True
///            size: 1
///            display_type: DisplayType.INTEGER
///            *name: uint8
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 1
///    transfer_transaction_body_reserved_2 = make_reserved(uint32, 0)
///        name: transfer_transaction_body_reserved_2
///        field_type: <class 'catparser.ast.FixedSizeInteger'>
///            short_name: uint32
///            is_unsigned: True
///            size: 4
///            display_type: DisplayType.INTEGER
///            *name: uint32
///            *sizeref: None
///        value: 0
///        disposition: reserved
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: True
///        *is_size_reference: False
///        *is_unsigned: True
///        *size: 4
///    @sort_key(mosaic_id) mosaics = array(UnresolvedMosaic, mosaics_count)
///        name: mosaics
///        field_type: <class 'catparser.ast.Array'>
///            element_type: UnresolvedMosaic
///            size: mosaics_count
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: mosaic_id
///        value: None
///        disposition: None
///        attributes: <class 'list'>
///            @sort_key(mosaic_id)
///                name: sort_key
///                is_flag: False
///                value: mosaic_id
///                values: <class 'list'>
///                    mosaic_id
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: mosaics_count
///    message = array(uint8, message_size)
///        name: message
///        field_type: <class 'catparser.ast.Array'>
///            element_type: <class 'catparser.ast.FixedSizeInteger'>
///                short_name: uint8
///                is_unsigned: True
///                size: 1
///                display_type: DisplayType.INTEGER
///                *name: uint8
///                *sizeref: None
///            size: message_size
///            *alignment: None
///            *disposition: array
///            *is_byte_constrained: False
///            *is_expandable: False
///            *is_last_element_padded: None
///            *sort_key: None
///        value: None
///        disposition: None
///        attributes: None
///        *is_conditional: False
///        *is_const: False
///        *is_reserved: False
///        *is_size_reference: False
///        *is_unsigned: None
///        *size: message_size
///factory_type: EmbeddedTransaction
///display_type: DisplayType.STRUCT
///attributes: <class 'list'>
///    @size(size)
///        name: size
///        is_flag: False
///        value: size
///        values: <class 'list'>
///            size
///    @initializes(version, TRANSACTION_VERSION)
///        name: initializes
///        is_flag: False
///        value: version
///        values: <class 'list'>
///            version
///            TRANSACTION_VERSION
///    @initializes(type, TRANSACTION_TYPE)
///        name: initializes
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            TRANSACTION_TYPE
///    @discriminator(type, version)
///        name: discriminator
///        is_flag: False
///        value: type
///        values: <class 'list'>
///            type
///            version
///    @is_aligned
///        name: is_aligned
///        is_flag: True
///        value: True
///        values: <class 'list'>
///requires_unaligned: False
///*comparer: None
///*discriminator: ['type', 'version']
///*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
///*is_abstract: False
///*is_aligned: True
///*is_inline: False
///*is_size_implicit: None
///*size: size
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct EmbeddedTransferTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub mosaics: Vec<UnresolvedMosaic>,
    pub message: Vec<u8>,
}
impl EmbeddedTransferTransactionV1 {
    const TRANSACTION_VERSION: u8 = 1;
    const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
    fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        mosaics: Vec<UnresolvedMosaic>,
        message: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            mosaics,
            message,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            mosaics: Vec::new(),
            message: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        size += self.mosaics.iter().map(|x| x.size()).sum::<usize>();
        size += 1 * self.message.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: 4,
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize >= payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: size as usize,
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type_;
        (_type_, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let message_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mosaics_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let transfer_transaction_body_reserved_1 = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        if transfer_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_1 as u32,
            ));
        }
        let transfer_transaction_body_reserved_2 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if transfer_transaction_body_reserved_2 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_2 as u32,
            ));
        }
        let mut mosaics = Vec::new();
        for _ in 0..mosaics_count {
            let element;
            (element, payload) = UnresolvedMosaic::deserialize(payload)?;
            mosaics.push(element);
        }
        let mut message = Vec::new();
        for _ in 0..message_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(payload);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            message.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            mosaics,
            message,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = self.size().to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = self.version().to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let message_size = self.message.len().to_le_bytes();
        let mosaics_count = self.mosaics.len().to_le_bytes();
        let transfer_transaction_body_reserved_1 = 0u8.to_le_bytes();
        let transfer_transaction_body_reserved_2 = 0u32.to_le_bytes();
        let mosaics: Vec<u8> = self.mosaics.iter().flat_map(|x| x.serialize()).collect();
        let message: Vec<u8> = self.message.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            message_size.iter(),
            mosaics_count.iter(),
            transfer_transaction_body_reserved_1.iter(),
            transfer_transaction_body_reserved_2.iter(),
            mosaics.iter(),
            message.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
