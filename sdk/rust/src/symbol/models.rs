//! This file was generated by running script
//! symbol/sdk/rust/scripts/run_catbuffer_generator.sh.

pub use crate::symbol::models_header::*;
use std::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};

pub trait TraitSignature {
    fn get_signature(&self) -> &Signature;
    fn set_signature(&mut self, signature: Signature);
}

pub trait TraitSignerPublicKey {
    fn get_signer_public_key(&self) -> &PublicKey;
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey);
}

pub trait TraitMessage {
    fn get_message(&self) -> &Vec<u8>;
    fn set_message(&mut self, message: Vec<u8>);
}

///A quantity of mosaics in [absolute units](/concepts/mosaic.html#divisibility).
///It can only be positive or zero. Negative quantities must be indicated by other means (See for example MosaicSupplyChangeTransaction and MosaicSupplyChangeAction).
//name: Amount
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct Amount(pub u64);
impl Amount {
    pub const SIZE: usize = 8;
    pub fn new(amount: u64) -> Self {
        Self(amount)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///A time lapse, expressed in number of blocks.
//name: BlockDuration
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct BlockDuration(pub u64);
impl BlockDuration {
    pub const SIZE: usize = 8;
    pub fn new(blockduration: u64) -> Self {
        Self(blockduration)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Multiplier applied to the size of a transaction to obtain its fee, in [absolute units](/concepts/mosaic.html#divisibility).
///See the [fees documentation](/concepts/fees.html).
//name: BlockFeeMultiplier
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint32
//    is_unsigned: True
//    size: 4
//    display_type: DisplayType.INTEGER
//    *name: uint32
//    *sizeref: None
//*is_unsigned: True
//*size: 4
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct BlockFeeMultiplier(pub u32);
impl BlockFeeMultiplier {
    pub const SIZE: usize = 4;
    pub fn new(blockfeemultiplier: u32) -> Self {
        Self(blockfeemultiplier)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///How hard it was to harvest this block.
///The initial value is 1e14 and it will remain like this as long as blocks are generated every `blockGenerationTargetTime` seconds ([network property](/guides/network/configuring-network-properties.html)).
///If blocks start taking more or less time than the configured value, the difficulty will be adjusted (in the range of 1e13 to 1e15) to try to hit the target time.
///See the [Technical Reference](/symbol-technicalref/main.pdf) section 8.1.
//name: Difficulty
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct Difficulty(pub u64);
impl Difficulty {
    pub const SIZE: usize = 8;
    pub fn new(difficulty: u64) -> Self {
        Self(difficulty)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Index of a [finalization](/concepts/block.html#finalization) epoch.
///The first epoch is number 1 and contains only the first block (the [Nemesis](/concepts/block.html#block-creation) block). Epoch duration (in blocks) is defined by the `votingSetGrouping` network property.
//name: FinalizationEpoch
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint32
//    is_unsigned: True
//    size: 4
//    display_type: DisplayType.INTEGER
//    *name: uint32
//    *sizeref: None
//*is_unsigned: True
//*size: 4
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct FinalizationEpoch(pub u32);
impl FinalizationEpoch {
    pub const SIZE: usize = 4;
    pub fn new(finalizationepoch: u32) -> Self {
        Self(finalizationepoch)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///A particular point in time inside a [finalization](/concepts/block.html#finalization) epoch.
///See the [Technical Reference](/symbol-technicalref/main.pdf) section 15.2.
//name: FinalizationPoint
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint32
//    is_unsigned: True
//    size: 4
//    display_type: DisplayType.INTEGER
//    *name: uint32
//    *sizeref: None
//*is_unsigned: True
//*size: 4
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct FinalizationPoint(pub u32);
impl FinalizationPoint {
    pub const SIZE: usize = 4;
    pub fn new(finalizationpoint: u32) -> Self {
        Self(finalizationpoint)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Index of a block in the blockchain.
///The first block (the [Nemesis](/concepts/block.html#block-creation) block) has height 1 and each subsequent block increases height by 1.
//name: Height
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct Height(pub u64);
impl Height {
    pub const SIZE: usize = 8;
    pub fn new(height: u64) -> Self {
        Self(height)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///[Importance score](/concepts/consensus-algorithm.html#importance-score) for an account.
///See also ImportanceHeight and ImportanceSnapshot.
//name: Importance
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct Importance(pub u64);
impl Importance {
    pub const SIZE: usize = 8;
    pub fn new(importance: u64) -> Self {
        Self(importance)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Block height at which an Importance was calculated.
//name: ImportanceHeight
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct ImportanceHeight(pub u64);
impl ImportanceHeight {
    pub const SIZE: usize = 8;
    pub fn new(importanceheight: u64) -> Self {
        Self(importanceheight)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Either a MosaicId or a NamespaceId.
///The **most**-significant bit of the first byte is 0 for MosaicId's and 1 for NamespaceId's.
//name: UnresolvedMosaicId
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct UnresolvedMosaicId(pub u64);
impl UnresolvedMosaicId {
    pub const SIZE: usize = 8;
    pub fn new(unresolvedmosaicid: u64) -> Self {
        Self(unresolvedmosaicid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///A [Mosaic](/concepts/mosaic.html) identifier.
//name: MosaicId
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct MosaicId(pub u64);
impl MosaicId {
    pub const SIZE: usize = 8;
    pub fn new(mosaicid: u64) -> Self {
        Self(mosaicid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Number of milliseconds elapsed since the creation of the [Nemesis](/concepts/block.html#block-creation) block.
///The Nemesis block creation time can be found in the `epochAdjustment` field returned by the [/network/properties](/symbol-openapi/v1.0.1/#operation/getNetworkProperties) REST endpoint. This is the number of seconds elapsed since the [UNIX epoch](https://en.wikipedia.org/wiki/Unix_time) and it is always 1615853185 for Symbol's MAINNET.
//name: Timestamp
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct Timestamp(pub u64);
impl Timestamp {
    pub const SIZE: usize = 8;
    pub fn new(timestamp: u64) -> Self {
        Self(timestamp)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Either an Address or a NamespaceId.
///The **least**-significant bit of the first byte is 0 for Addresses and 1 for NamespaceId's.
//name: UnresolvedAddress
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 24
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(24)
//*is_unsigned: True
//*size: 24
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct UnresolvedAddress(pub [u8; 24]);
impl UnresolvedAddress {
    pub const SIZE: usize = 24;
    pub fn new(unresolvedaddress: [u8; 24]) -> Self {
        Self(unresolvedaddress)
    }
    pub fn default() -> Self {
        Self([0; 24])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///An [address](/concepts/cryptography.html#address) identifies an account and is derived from its PublicKey.
//name: Address
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 24
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(24)
//*is_unsigned: True
//*size: 24
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct Address(pub [u8; 24]);
impl Address {
    pub const SIZE: usize = 24;
    pub fn new(address: [u8; 24]) -> Self {
        Self(address)
    }
    pub fn default() -> Self {
        Self([0; 24])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A 32-byte (256 bit) hash.
///The exact algorithm is unspecified as it can change depending on where it is used.
//name: Hash256
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 32
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(32)
//*is_unsigned: True
//*size: 32
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct Hash256(pub [u8; 32]);
impl Hash256 {
    pub const SIZE: usize = 32;
    pub fn new(hash256: [u8; 32]) -> Self {
        Self(hash256)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A 64-byte (512 bit) hash.
///The exact algorithm is unspecified as it can change depending on where it is used.
//name: Hash512
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 64
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(64)
//*is_unsigned: True
//*size: 64
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct Hash512(pub [u8; 64]);
impl Hash512 {
    pub const SIZE: usize = 64;
    pub fn new(hash512: [u8; 64]) -> Self {
        Self(hash512)
    }
    pub fn default() -> Self {
        Self([0; 64])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A 32-byte (256 bit) integer derived from a private key.
///It serves as the public identifier of the [key pair](/concepts/cryptography.html#key-pair) and can be disseminated widely. It is used to prove that an entity was signed with the paired private key.
//name: PublicKey
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 32
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(32)
//*is_unsigned: True
//*size: 32
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct PublicKey(pub [u8; 32]);
impl PublicKey {
    pub const SIZE: usize = 32;
    pub fn new(publickey: [u8; 32]) -> Self {
        Self(publickey)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A PublicKey used for voting during the [finalization process](/concepts/block.html#finalization).
//name: VotingPublicKey
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 32
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(32)
//*is_unsigned: True
//*size: 32
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct VotingPublicKey(pub [u8; 32]);
impl VotingPublicKey {
    pub const SIZE: usize = 32;
    pub fn new(votingpublickey: [u8; 32]) -> Self {
        Self(votingpublickey)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A 64-byte (512 bit) array certifying that the signed data has not been modified.
///Symbol currently uses [Ed25519](https://ed25519.cr.yp.to/) signatures.
//name: Signature
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 64
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(64)
//*is_unsigned: True
//*size: 64
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct Signature(pub [u8; 64]);
impl Signature {
    pub const SIZE: usize = 64;
    pub fn new(signature: [u8; 64]) -> Self {
        Self(signature)
    }
    pub fn default() -> Self {
        Self([0; 64])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///A quantity of a certain mosaic.
//name: Mosaic
//disposition: None
//fields: <class 'list'>
//    mosaic_id = MosaicId
//        name: mosaic_id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    amount = Amount
//        name: amount
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
#[derive(PartialOrd, Ord)]
pub struct Mosaic {
    pub mosaic_id: MosaicId,
    pub amount: Amount,
}
impl Mosaic {
    pub fn new(mosaic_id: MosaicId, amount: Amount) -> Self {
        Self { mosaic_id, amount }
    }
    pub fn default() -> Self {
        Self {
            mosaic_id: MosaicId::default(),
            amount: Amount::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.mosaic_id.size();
        size += self.amount.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let amount;
        (amount, payload) = Amount::deserialize(payload)?;
        let self_ = Self { mosaic_id, amount };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let mosaic_id = self.mosaic_id.serialize();
        let amount = self.amount.serialize();
        [mosaic_id.iter(), amount.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///A quantity of a certain mosaic, specified either through a MosaicId or an alias.
//name: UnresolvedMosaic
//disposition: None
//fields: <class 'list'>
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    amount = Amount
//        name: amount
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
#[derive(PartialOrd, Ord)]
pub struct UnresolvedMosaic {
    pub mosaic_id: UnresolvedMosaicId,
    pub amount: Amount,
}
impl UnresolvedMosaic {
    pub fn new(mosaic_id: UnresolvedMosaicId, amount: Amount) -> Self {
        Self { mosaic_id, amount }
    }
    pub fn default() -> Self {
        Self {
            mosaic_id: UnresolvedMosaicId::default(),
            amount: Amount::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.mosaic_id.size();
        size += self.amount.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let amount;
        (amount, payload) = Amount::deserialize(payload)?;
        let self_ = Self { mosaic_id, amount };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let mosaic_id = self.mosaic_id.serialize();
        let amount = self.amount.serialize();
        [mosaic_id.iter(), amount.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///Link actions.
//name: LinkAction
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    UNLINK = 0
//        name: UNLINK
//        value: 0
//    LINK = 1
//        name: LINK
//        value: 1
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum LinkAction {
    UNLINK = 0,
    LINK = 1,
}
impl LinkAction {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::UNLINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((LinkAction::UNLINK, rest)),
            1 => Ok((LinkAction::LINK, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "LinkAction".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Enumeration of network types.
//name: NetworkType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    MAINNET = 104
//        name: MAINNET
//        value: 104
//    TESTNET = 152
//        name: TESTNET
//        value: 152
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
#[cfg(not(feature = "private_network"))]
pub enum NetworkType {
    MAINNET = 104,
    TESTNET = 152,
}
#[cfg(not(feature = "private_network"))]
impl NetworkType {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::MAINNET
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            104 => Ok((NetworkType::MAINNET, rest)),
            152 => Ok((NetworkType::TESTNET, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "NetworkType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Enumeration of Transaction types
//name: TransactionType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint16
//    is_unsigned: True
//    size: 2
//    display_type: DisplayType.INTEGER
//    *name: uint16
//    *sizeref: None
//values: <class 'list'>
//    ACCOUNT_KEY_LINK = 16716
//        name: ACCOUNT_KEY_LINK
//        value: 16716
//    NODE_KEY_LINK = 16972
//        name: NODE_KEY_LINK
//        value: 16972
//    AGGREGATE_COMPLETE = 16705
//        name: AGGREGATE_COMPLETE
//        value: 16705
//    AGGREGATE_BONDED = 16961
//        name: AGGREGATE_BONDED
//        value: 16961
//    VOTING_KEY_LINK = 16707
//        name: VOTING_KEY_LINK
//        value: 16707
//    VRF_KEY_LINK = 16963
//        name: VRF_KEY_LINK
//        value: 16963
//    HASH_LOCK = 16712
//        name: HASH_LOCK
//        value: 16712
//    SECRET_LOCK = 16722
//        name: SECRET_LOCK
//        value: 16722
//    SECRET_PROOF = 16978
//        name: SECRET_PROOF
//        value: 16978
//    ACCOUNT_METADATA = 16708
//        name: ACCOUNT_METADATA
//        value: 16708
//    MOSAIC_METADATA = 16964
//        name: MOSAIC_METADATA
//        value: 16964
//    NAMESPACE_METADATA = 17220
//        name: NAMESPACE_METADATA
//        value: 17220
//    MOSAIC_DEFINITION = 16717
//        name: MOSAIC_DEFINITION
//        value: 16717
//    MOSAIC_SUPPLY_CHANGE = 16973
//        name: MOSAIC_SUPPLY_CHANGE
//        value: 16973
//    MOSAIC_SUPPLY_REVOCATION = 17229
//        name: MOSAIC_SUPPLY_REVOCATION
//        value: 17229
//    MULTISIG_ACCOUNT_MODIFICATION = 16725
//        name: MULTISIG_ACCOUNT_MODIFICATION
//        value: 16725
//    ADDRESS_ALIAS = 16974
//        name: ADDRESS_ALIAS
//        value: 16974
//    MOSAIC_ALIAS = 17230
//        name: MOSAIC_ALIAS
//        value: 17230
//    NAMESPACE_REGISTRATION = 16718
//        name: NAMESPACE_REGISTRATION
//        value: 16718
//    ACCOUNT_ADDRESS_RESTRICTION = 16720
//        name: ACCOUNT_ADDRESS_RESTRICTION
//        value: 16720
//    ACCOUNT_MOSAIC_RESTRICTION = 16976
//        name: ACCOUNT_MOSAIC_RESTRICTION
//        value: 16976
//    ACCOUNT_OPERATION_RESTRICTION = 17232
//        name: ACCOUNT_OPERATION_RESTRICTION
//        value: 17232
//    MOSAIC_ADDRESS_RESTRICTION = 16977
//        name: MOSAIC_ADDRESS_RESTRICTION
//        value: 16977
//    MOSAIC_GLOBAL_RESTRICTION = 16721
//        name: MOSAIC_GLOBAL_RESTRICTION
//        value: 16721
//    TRANSFER = 16724
//        name: TRANSFER
//        value: 16724
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 2
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u16)]
pub enum TransactionType {
    ACCOUNT_KEY_LINK = 16716,
    NODE_KEY_LINK = 16972,
    AGGREGATE_COMPLETE = 16705,
    AGGREGATE_BONDED = 16961,
    VOTING_KEY_LINK = 16707,
    VRF_KEY_LINK = 16963,
    HASH_LOCK = 16712,
    SECRET_LOCK = 16722,
    SECRET_PROOF = 16978,
    ACCOUNT_METADATA = 16708,
    MOSAIC_METADATA = 16964,
    NAMESPACE_METADATA = 17220,
    MOSAIC_DEFINITION = 16717,
    MOSAIC_SUPPLY_CHANGE = 16973,
    MOSAIC_SUPPLY_REVOCATION = 17229,
    MULTISIG_ACCOUNT_MODIFICATION = 16725,
    ADDRESS_ALIAS = 16974,
    MOSAIC_ALIAS = 17230,
    NAMESPACE_REGISTRATION = 16718,
    ACCOUNT_ADDRESS_RESTRICTION = 16720,
    ACCOUNT_MOSAIC_RESTRICTION = 16976,
    ACCOUNT_OPERATION_RESTRICTION = 17232,
    MOSAIC_ADDRESS_RESTRICTION = 16977,
    MOSAIC_GLOBAL_RESTRICTION = 16721,
    TRANSFER = 16724,
}
impl TransactionType {
    pub const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::ACCOUNT_KEY_LINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            16716 => Ok((TransactionType::ACCOUNT_KEY_LINK, rest)),
            16972 => Ok((TransactionType::NODE_KEY_LINK, rest)),
            16705 => Ok((TransactionType::AGGREGATE_COMPLETE, rest)),
            16961 => Ok((TransactionType::AGGREGATE_BONDED, rest)),
            16707 => Ok((TransactionType::VOTING_KEY_LINK, rest)),
            16963 => Ok((TransactionType::VRF_KEY_LINK, rest)),
            16712 => Ok((TransactionType::HASH_LOCK, rest)),
            16722 => Ok((TransactionType::SECRET_LOCK, rest)),
            16978 => Ok((TransactionType::SECRET_PROOF, rest)),
            16708 => Ok((TransactionType::ACCOUNT_METADATA, rest)),
            16964 => Ok((TransactionType::MOSAIC_METADATA, rest)),
            17220 => Ok((TransactionType::NAMESPACE_METADATA, rest)),
            16717 => Ok((TransactionType::MOSAIC_DEFINITION, rest)),
            16973 => Ok((TransactionType::MOSAIC_SUPPLY_CHANGE, rest)),
            17229 => Ok((TransactionType::MOSAIC_SUPPLY_REVOCATION, rest)),
            16725 => Ok((TransactionType::MULTISIG_ACCOUNT_MODIFICATION, rest)),
            16974 => Ok((TransactionType::ADDRESS_ALIAS, rest)),
            17230 => Ok((TransactionType::MOSAIC_ALIAS, rest)),
            16718 => Ok((TransactionType::NAMESPACE_REGISTRATION, rest)),
            16720 => Ok((TransactionType::ACCOUNT_ADDRESS_RESTRICTION, rest)),
            16976 => Ok((TransactionType::ACCOUNT_MOSAIC_RESTRICTION, rest)),
            17232 => Ok((TransactionType::ACCOUNT_OPERATION_RESTRICTION, rest)),
            16977 => Ok((TransactionType::MOSAIC_ADDRESS_RESTRICTION, rest)),
            16721 => Ok((TransactionType::MOSAIC_GLOBAL_RESTRICTION, rest)),
            16724 => Ok((TransactionType::TRANSFER, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "TransactionType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
}
///binary layout for a transaction
//name: Transaction
//disposition: abstract
//fields: <class 'list'>
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: True
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_factory()
pub enum Transaction {
    AccountKeyLinkTransactionV1(AccountKeyLinkTransactionV1),
    NodeKeyLinkTransactionV1(NodeKeyLinkTransactionV1),
    AggregateCompleteTransactionV1(AggregateCompleteTransactionV1),
    AggregateCompleteTransactionV2(AggregateCompleteTransactionV2),
    AggregateBondedTransactionV1(AggregateBondedTransactionV1),
    AggregateBondedTransactionV2(AggregateBondedTransactionV2),
    VotingKeyLinkTransactionV1(VotingKeyLinkTransactionV1),
    VrfKeyLinkTransactionV1(VrfKeyLinkTransactionV1),
    HashLockTransactionV1(HashLockTransactionV1),
    SecretLockTransactionV1(SecretLockTransactionV1),
    SecretProofTransactionV1(SecretProofTransactionV1),
    AccountMetadataTransactionV1(AccountMetadataTransactionV1),
    MosaicMetadataTransactionV1(MosaicMetadataTransactionV1),
    NamespaceMetadataTransactionV1(NamespaceMetadataTransactionV1),
    MosaicDefinitionTransactionV1(MosaicDefinitionTransactionV1),
    MosaicSupplyChangeTransactionV1(MosaicSupplyChangeTransactionV1),
    MosaicSupplyRevocationTransactionV1(MosaicSupplyRevocationTransactionV1),
    MultisigAccountModificationTransactionV1(MultisigAccountModificationTransactionV1),
    AddressAliasTransactionV1(AddressAliasTransactionV1),
    MosaicAliasTransactionV1(MosaicAliasTransactionV1),
    NamespaceRegistrationTransactionV1(NamespaceRegistrationTransactionV1),
    AccountAddressRestrictionTransactionV1(AccountAddressRestrictionTransactionV1),
    AccountMosaicRestrictionTransactionV1(AccountMosaicRestrictionTransactionV1),
    AccountOperationRestrictionTransactionV1(AccountOperationRestrictionTransactionV1),
    MosaicAddressRestrictionTransactionV1(MosaicAddressRestrictionTransactionV1),
    MosaicGlobalRestrictionTransactionV1(MosaicGlobalRestrictionTransactionV1),
    TransferTransactionV1(TransferTransactionV1),
}
#[allow(unreachable_patterns)]
impl Transaction {
    pub fn size(&self) -> usize {
        match self {
            Self::AccountKeyLinkTransactionV1(x) => x.size(),
            Self::NodeKeyLinkTransactionV1(x) => x.size(),
            Self::AggregateCompleteTransactionV1(x) => x.size(),
            Self::AggregateCompleteTransactionV2(x) => x.size(),
            Self::AggregateBondedTransactionV1(x) => x.size(),
            Self::AggregateBondedTransactionV2(x) => x.size(),
            Self::VotingKeyLinkTransactionV1(x) => x.size(),
            Self::VrfKeyLinkTransactionV1(x) => x.size(),
            Self::HashLockTransactionV1(x) => x.size(),
            Self::SecretLockTransactionV1(x) => x.size(),
            Self::SecretProofTransactionV1(x) => x.size(),
            Self::AccountMetadataTransactionV1(x) => x.size(),
            Self::MosaicMetadataTransactionV1(x) => x.size(),
            Self::NamespaceMetadataTransactionV1(x) => x.size(),
            Self::MosaicDefinitionTransactionV1(x) => x.size(),
            Self::MosaicSupplyChangeTransactionV1(x) => x.size(),
            Self::MosaicSupplyRevocationTransactionV1(x) => x.size(),
            Self::MultisigAccountModificationTransactionV1(x) => x.size(),
            Self::AddressAliasTransactionV1(x) => x.size(),
            Self::MosaicAliasTransactionV1(x) => x.size(),
            Self::NamespaceRegistrationTransactionV1(x) => x.size(),
            Self::AccountAddressRestrictionTransactionV1(x) => x.size(),
            Self::AccountMosaicRestrictionTransactionV1(x) => x.size(),
            Self::AccountOperationRestrictionTransactionV1(x) => x.size(),
            Self::MosaicAddressRestrictionTransactionV1(x) => x.size(),
            Self::MosaicGlobalRestrictionTransactionV1(x) => x.size(),
            Self::TransferTransactionV1(x) => x.size(),
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mut _tmp_payload = payload;
        if _tmp_payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: _tmp_payload.len(),
            });
        }
        let _size = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _size as usize > _tmp_payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![_size as usize],
                real: _tmp_payload.len() + 4,
            });
        }
        let _verifiable_entity_header_reserved_1 =
            u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let _signature;
        (_signature, _tmp_payload) = Signature::deserialize(_tmp_payload)?;
        let _signer_public_key;
        (_signer_public_key, _tmp_payload) = PublicKey::deserialize(_tmp_payload)?;
        let _entity_body_reserved_1 = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(_tmp_payload[..1].try_into()?);
        _tmp_payload = &_tmp_payload[1..];
        let _network;
        (_network, _tmp_payload) = NetworkType::deserialize(_tmp_payload)?;
        let _type;
        (_type, _tmp_payload) = TransactionType::deserialize(_tmp_payload)?;
        let _fee;
        (_fee, _tmp_payload) = Amount::deserialize(_tmp_payload)?;
        let _deadline;
        (_deadline, _tmp_payload) = Timestamp::deserialize(_tmp_payload)?;
        match (_type, _version) {
            (
                AccountKeyLinkTransactionV1::TRANSACTION_TYPE,
                AccountKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AccountKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::AccountKeyLinkTransactionV1(product), payload))
            }
            (
                NodeKeyLinkTransactionV1::TRANSACTION_TYPE,
                NodeKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = NodeKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::NodeKeyLinkTransactionV1(product), payload))
            }
            (
                AggregateCompleteTransactionV1::TRANSACTION_TYPE,
                AggregateCompleteTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AggregateCompleteTransactionV1::deserialize(payload)?;
                Ok((Self::AggregateCompleteTransactionV1(product), payload))
            }
            (
                AggregateCompleteTransactionV2::TRANSACTION_TYPE,
                AggregateCompleteTransactionV2::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AggregateCompleteTransactionV2::deserialize(payload)?;
                Ok((Self::AggregateCompleteTransactionV2(product), payload))
            }
            (
                AggregateBondedTransactionV1::TRANSACTION_TYPE,
                AggregateBondedTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AggregateBondedTransactionV1::deserialize(payload)?;
                Ok((Self::AggregateBondedTransactionV1(product), payload))
            }
            (
                AggregateBondedTransactionV2::TRANSACTION_TYPE,
                AggregateBondedTransactionV2::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AggregateBondedTransactionV2::deserialize(payload)?;
                Ok((Self::AggregateBondedTransactionV2(product), payload))
            }
            (
                VotingKeyLinkTransactionV1::TRANSACTION_TYPE,
                VotingKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = VotingKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::VotingKeyLinkTransactionV1(product), payload))
            }
            (
                VrfKeyLinkTransactionV1::TRANSACTION_TYPE,
                VrfKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = VrfKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::VrfKeyLinkTransactionV1(product), payload))
            }
            (
                HashLockTransactionV1::TRANSACTION_TYPE,
                HashLockTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = HashLockTransactionV1::deserialize(payload)?;
                Ok((Self::HashLockTransactionV1(product), payload))
            }
            (
                SecretLockTransactionV1::TRANSACTION_TYPE,
                SecretLockTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = SecretLockTransactionV1::deserialize(payload)?;
                Ok((Self::SecretLockTransactionV1(product), payload))
            }
            (
                SecretProofTransactionV1::TRANSACTION_TYPE,
                SecretProofTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = SecretProofTransactionV1::deserialize(payload)?;
                Ok((Self::SecretProofTransactionV1(product), payload))
            }
            (
                AccountMetadataTransactionV1::TRANSACTION_TYPE,
                AccountMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AccountMetadataTransactionV1::deserialize(payload)?;
                Ok((Self::AccountMetadataTransactionV1(product), payload))
            }
            (
                MosaicMetadataTransactionV1::TRANSACTION_TYPE,
                MosaicMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = MosaicMetadataTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicMetadataTransactionV1(product), payload))
            }
            (
                NamespaceMetadataTransactionV1::TRANSACTION_TYPE,
                NamespaceMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = NamespaceMetadataTransactionV1::deserialize(payload)?;
                Ok((Self::NamespaceMetadataTransactionV1(product), payload))
            }
            (
                MosaicDefinitionTransactionV1::TRANSACTION_TYPE,
                MosaicDefinitionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = MosaicDefinitionTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicDefinitionTransactionV1(product), payload))
            }
            (
                MosaicSupplyChangeTransactionV1::TRANSACTION_TYPE,
                MosaicSupplyChangeTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = MosaicSupplyChangeTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicSupplyChangeTransactionV1(product), payload))
            }
            (
                MosaicSupplyRevocationTransactionV1::TRANSACTION_TYPE,
                MosaicSupplyRevocationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = MosaicSupplyRevocationTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicSupplyRevocationTransactionV1(product), payload))
            }
            (
                MultisigAccountModificationTransactionV1::TRANSACTION_TYPE,
                MultisigAccountModificationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    MultisigAccountModificationTransactionV1::deserialize(payload)?;
                Ok((
                    Self::MultisigAccountModificationTransactionV1(product),
                    payload,
                ))
            }
            (
                AddressAliasTransactionV1::TRANSACTION_TYPE,
                AddressAliasTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = AddressAliasTransactionV1::deserialize(payload)?;
                Ok((Self::AddressAliasTransactionV1(product), payload))
            }
            (
                MosaicAliasTransactionV1::TRANSACTION_TYPE,
                MosaicAliasTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = MosaicAliasTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicAliasTransactionV1(product), payload))
            }
            (
                NamespaceRegistrationTransactionV1::TRANSACTION_TYPE,
                NamespaceRegistrationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = NamespaceRegistrationTransactionV1::deserialize(payload)?;
                Ok((Self::NamespaceRegistrationTransactionV1(product), payload))
            }
            (
                AccountAddressRestrictionTransactionV1::TRANSACTION_TYPE,
                AccountAddressRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    AccountAddressRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::AccountAddressRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                AccountMosaicRestrictionTransactionV1::TRANSACTION_TYPE,
                AccountMosaicRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    AccountMosaicRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::AccountMosaicRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                AccountOperationRestrictionTransactionV1::TRANSACTION_TYPE,
                AccountOperationRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    AccountOperationRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::AccountOperationRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                MosaicAddressRestrictionTransactionV1::TRANSACTION_TYPE,
                MosaicAddressRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    MosaicAddressRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::MosaicAddressRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                MosaicGlobalRestrictionTransactionV1::TRANSACTION_TYPE,
                MosaicGlobalRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    MosaicGlobalRestrictionTransactionV1::deserialize(payload)?;
                Ok((Self::MosaicGlobalRestrictionTransactionV1(product), payload))
            }
            (
                TransferTransactionV1::TRANSACTION_TYPE,
                TransferTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = TransferTransactionV1::deserialize(payload)?;
                Ok((Self::TransferTransactionV1(product), payload))
            }
            (other_type, other_version) => Err(SymbolError::MismatchError {
                pattern: vec![other_type as u32, other_version as u32],
                place: "Transaction".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::AccountKeyLinkTransactionV1(x) => x.serialize(),
            Self::NodeKeyLinkTransactionV1(x) => x.serialize(),
            Self::AggregateCompleteTransactionV1(x) => x.serialize(),
            Self::AggregateCompleteTransactionV2(x) => x.serialize(),
            Self::AggregateBondedTransactionV1(x) => x.serialize(),
            Self::AggregateBondedTransactionV2(x) => x.serialize(),
            Self::VotingKeyLinkTransactionV1(x) => x.serialize(),
            Self::VrfKeyLinkTransactionV1(x) => x.serialize(),
            Self::HashLockTransactionV1(x) => x.serialize(),
            Self::SecretLockTransactionV1(x) => x.serialize(),
            Self::SecretProofTransactionV1(x) => x.serialize(),
            Self::AccountMetadataTransactionV1(x) => x.serialize(),
            Self::MosaicMetadataTransactionV1(x) => x.serialize(),
            Self::NamespaceMetadataTransactionV1(x) => x.serialize(),
            Self::MosaicDefinitionTransactionV1(x) => x.serialize(),
            Self::MosaicSupplyChangeTransactionV1(x) => x.serialize(),
            Self::MosaicSupplyRevocationTransactionV1(x) => x.serialize(),
            Self::MultisigAccountModificationTransactionV1(x) => x.serialize(),
            Self::AddressAliasTransactionV1(x) => x.serialize(),
            Self::MosaicAliasTransactionV1(x) => x.serialize(),
            Self::NamespaceRegistrationTransactionV1(x) => x.serialize(),
            Self::AccountAddressRestrictionTransactionV1(x) => x.serialize(),
            Self::AccountMosaicRestrictionTransactionV1(x) => x.serialize(),
            Self::AccountOperationRestrictionTransactionV1(x) => x.serialize(),
            Self::MosaicAddressRestrictionTransactionV1(x) => x.serialize(),
            Self::MosaicGlobalRestrictionTransactionV1(x) => x.serialize(),
            Self::TransferTransactionV1(x) => x.serialize(),
        }
    }
}
impl From<AccountKeyLinkTransactionV1> for Transaction {
    fn from(value: AccountKeyLinkTransactionV1) -> Self {
        Self::AccountKeyLinkTransactionV1(value)
    }
}
impl From<NodeKeyLinkTransactionV1> for Transaction {
    fn from(value: NodeKeyLinkTransactionV1) -> Self {
        Self::NodeKeyLinkTransactionV1(value)
    }
}
impl From<AggregateCompleteTransactionV1> for Transaction {
    fn from(value: AggregateCompleteTransactionV1) -> Self {
        Self::AggregateCompleteTransactionV1(value)
    }
}
impl From<AggregateCompleteTransactionV2> for Transaction {
    fn from(value: AggregateCompleteTransactionV2) -> Self {
        Self::AggregateCompleteTransactionV2(value)
    }
}
impl From<AggregateBondedTransactionV1> for Transaction {
    fn from(value: AggregateBondedTransactionV1) -> Self {
        Self::AggregateBondedTransactionV1(value)
    }
}
impl From<AggregateBondedTransactionV2> for Transaction {
    fn from(value: AggregateBondedTransactionV2) -> Self {
        Self::AggregateBondedTransactionV2(value)
    }
}
impl From<VotingKeyLinkTransactionV1> for Transaction {
    fn from(value: VotingKeyLinkTransactionV1) -> Self {
        Self::VotingKeyLinkTransactionV1(value)
    }
}
impl From<VrfKeyLinkTransactionV1> for Transaction {
    fn from(value: VrfKeyLinkTransactionV1) -> Self {
        Self::VrfKeyLinkTransactionV1(value)
    }
}
impl From<HashLockTransactionV1> for Transaction {
    fn from(value: HashLockTransactionV1) -> Self {
        Self::HashLockTransactionV1(value)
    }
}
impl From<SecretLockTransactionV1> for Transaction {
    fn from(value: SecretLockTransactionV1) -> Self {
        Self::SecretLockTransactionV1(value)
    }
}
impl From<SecretProofTransactionV1> for Transaction {
    fn from(value: SecretProofTransactionV1) -> Self {
        Self::SecretProofTransactionV1(value)
    }
}
impl From<AccountMetadataTransactionV1> for Transaction {
    fn from(value: AccountMetadataTransactionV1) -> Self {
        Self::AccountMetadataTransactionV1(value)
    }
}
impl From<MosaicMetadataTransactionV1> for Transaction {
    fn from(value: MosaicMetadataTransactionV1) -> Self {
        Self::MosaicMetadataTransactionV1(value)
    }
}
impl From<NamespaceMetadataTransactionV1> for Transaction {
    fn from(value: NamespaceMetadataTransactionV1) -> Self {
        Self::NamespaceMetadataTransactionV1(value)
    }
}
impl From<MosaicDefinitionTransactionV1> for Transaction {
    fn from(value: MosaicDefinitionTransactionV1) -> Self {
        Self::MosaicDefinitionTransactionV1(value)
    }
}
impl From<MosaicSupplyChangeTransactionV1> for Transaction {
    fn from(value: MosaicSupplyChangeTransactionV1) -> Self {
        Self::MosaicSupplyChangeTransactionV1(value)
    }
}
impl From<MosaicSupplyRevocationTransactionV1> for Transaction {
    fn from(value: MosaicSupplyRevocationTransactionV1) -> Self {
        Self::MosaicSupplyRevocationTransactionV1(value)
    }
}
impl From<MultisigAccountModificationTransactionV1> for Transaction {
    fn from(value: MultisigAccountModificationTransactionV1) -> Self {
        Self::MultisigAccountModificationTransactionV1(value)
    }
}
impl From<AddressAliasTransactionV1> for Transaction {
    fn from(value: AddressAliasTransactionV1) -> Self {
        Self::AddressAliasTransactionV1(value)
    }
}
impl From<MosaicAliasTransactionV1> for Transaction {
    fn from(value: MosaicAliasTransactionV1) -> Self {
        Self::MosaicAliasTransactionV1(value)
    }
}
impl From<NamespaceRegistrationTransactionV1> for Transaction {
    fn from(value: NamespaceRegistrationTransactionV1) -> Self {
        Self::NamespaceRegistrationTransactionV1(value)
    }
}
impl From<AccountAddressRestrictionTransactionV1> for Transaction {
    fn from(value: AccountAddressRestrictionTransactionV1) -> Self {
        Self::AccountAddressRestrictionTransactionV1(value)
    }
}
impl From<AccountMosaicRestrictionTransactionV1> for Transaction {
    fn from(value: AccountMosaicRestrictionTransactionV1) -> Self {
        Self::AccountMosaicRestrictionTransactionV1(value)
    }
}
impl From<AccountOperationRestrictionTransactionV1> for Transaction {
    fn from(value: AccountOperationRestrictionTransactionV1) -> Self {
        Self::AccountOperationRestrictionTransactionV1(value)
    }
}
impl From<MosaicAddressRestrictionTransactionV1> for Transaction {
    fn from(value: MosaicAddressRestrictionTransactionV1) -> Self {
        Self::MosaicAddressRestrictionTransactionV1(value)
    }
}
impl From<MosaicGlobalRestrictionTransactionV1> for Transaction {
    fn from(value: MosaicGlobalRestrictionTransactionV1) -> Self {
        Self::MosaicGlobalRestrictionTransactionV1(value)
    }
}
impl From<TransferTransactionV1> for Transaction {
    fn from(value: TransferTransactionV1) -> Self {
        Self::TransferTransactionV1(value)
    }
}
///binary layout for an embedded transaction
//name: EmbeddedTransaction
//disposition: abstract
//fields: <class 'list'>
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: True
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_factory()
pub enum EmbeddedTransaction {
    EmbeddedAccountKeyLinkTransactionV1(EmbeddedAccountKeyLinkTransactionV1),
    EmbeddedNodeKeyLinkTransactionV1(EmbeddedNodeKeyLinkTransactionV1),
    EmbeddedVotingKeyLinkTransactionV1(EmbeddedVotingKeyLinkTransactionV1),
    EmbeddedVrfKeyLinkTransactionV1(EmbeddedVrfKeyLinkTransactionV1),
    EmbeddedHashLockTransactionV1(EmbeddedHashLockTransactionV1),
    EmbeddedSecretLockTransactionV1(EmbeddedSecretLockTransactionV1),
    EmbeddedSecretProofTransactionV1(EmbeddedSecretProofTransactionV1),
    EmbeddedAccountMetadataTransactionV1(EmbeddedAccountMetadataTransactionV1),
    EmbeddedMosaicMetadataTransactionV1(EmbeddedMosaicMetadataTransactionV1),
    EmbeddedNamespaceMetadataTransactionV1(EmbeddedNamespaceMetadataTransactionV1),
    EmbeddedMosaicDefinitionTransactionV1(EmbeddedMosaicDefinitionTransactionV1),
    EmbeddedMosaicSupplyChangeTransactionV1(EmbeddedMosaicSupplyChangeTransactionV1),
    EmbeddedMosaicSupplyRevocationTransactionV1(EmbeddedMosaicSupplyRevocationTransactionV1),
    EmbeddedMultisigAccountModificationTransactionV1(
        EmbeddedMultisigAccountModificationTransactionV1,
    ),
    EmbeddedAddressAliasTransactionV1(EmbeddedAddressAliasTransactionV1),
    EmbeddedMosaicAliasTransactionV1(EmbeddedMosaicAliasTransactionV1),
    EmbeddedNamespaceRegistrationTransactionV1(EmbeddedNamespaceRegistrationTransactionV1),
    EmbeddedAccountAddressRestrictionTransactionV1(EmbeddedAccountAddressRestrictionTransactionV1),
    EmbeddedAccountMosaicRestrictionTransactionV1(EmbeddedAccountMosaicRestrictionTransactionV1),
    EmbeddedAccountOperationRestrictionTransactionV1(
        EmbeddedAccountOperationRestrictionTransactionV1,
    ),
    EmbeddedMosaicAddressRestrictionTransactionV1(EmbeddedMosaicAddressRestrictionTransactionV1),
    EmbeddedMosaicGlobalRestrictionTransactionV1(EmbeddedMosaicGlobalRestrictionTransactionV1),
    EmbeddedTransferTransactionV1(EmbeddedTransferTransactionV1),
}
#[allow(unreachable_patterns)]
impl EmbeddedTransaction {
    pub fn size(&self) -> usize {
        match self {
            Self::EmbeddedAccountKeyLinkTransactionV1(x) => x.size(),
            Self::EmbeddedNodeKeyLinkTransactionV1(x) => x.size(),
            Self::EmbeddedVotingKeyLinkTransactionV1(x) => x.size(),
            Self::EmbeddedVrfKeyLinkTransactionV1(x) => x.size(),
            Self::EmbeddedHashLockTransactionV1(x) => x.size(),
            Self::EmbeddedSecretLockTransactionV1(x) => x.size(),
            Self::EmbeddedSecretProofTransactionV1(x) => x.size(),
            Self::EmbeddedAccountMetadataTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicMetadataTransactionV1(x) => x.size(),
            Self::EmbeddedNamespaceMetadataTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicDefinitionTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicSupplyChangeTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicSupplyRevocationTransactionV1(x) => x.size(),
            Self::EmbeddedMultisigAccountModificationTransactionV1(x) => x.size(),
            Self::EmbeddedAddressAliasTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicAliasTransactionV1(x) => x.size(),
            Self::EmbeddedNamespaceRegistrationTransactionV1(x) => x.size(),
            Self::EmbeddedAccountAddressRestrictionTransactionV1(x) => x.size(),
            Self::EmbeddedAccountMosaicRestrictionTransactionV1(x) => x.size(),
            Self::EmbeddedAccountOperationRestrictionTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicAddressRestrictionTransactionV1(x) => x.size(),
            Self::EmbeddedMosaicGlobalRestrictionTransactionV1(x) => x.size(),
            Self::EmbeddedTransferTransactionV1(x) => x.size(),
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mut _tmp_payload = payload;
        if _tmp_payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: _tmp_payload.len(),
            });
        }
        let _size = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _size as usize > _tmp_payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![_size as usize],
                real: _tmp_payload.len() + 4,
            });
        }
        let _embedded_transaction_header_reserved_1 =
            u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let _signer_public_key;
        (_signer_public_key, _tmp_payload) = PublicKey::deserialize(_tmp_payload)?;
        let _entity_body_reserved_1 = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(_tmp_payload[..1].try_into()?);
        _tmp_payload = &_tmp_payload[1..];
        let _network;
        (_network, _tmp_payload) = NetworkType::deserialize(_tmp_payload)?;
        let _type;
        (_type, _tmp_payload) = TransactionType::deserialize(_tmp_payload)?;
        match (_type, _version) {
            (
                EmbeddedAccountKeyLinkTransactionV1::TRANSACTION_TYPE,
                EmbeddedAccountKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedAccountKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedAccountKeyLinkTransactionV1(product), payload))
            }
            (
                EmbeddedNodeKeyLinkTransactionV1::TRANSACTION_TYPE,
                EmbeddedNodeKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedNodeKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedNodeKeyLinkTransactionV1(product), payload))
            }
            (
                EmbeddedVotingKeyLinkTransactionV1::TRANSACTION_TYPE,
                EmbeddedVotingKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedVotingKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedVotingKeyLinkTransactionV1(product), payload))
            }
            (
                EmbeddedVrfKeyLinkTransactionV1::TRANSACTION_TYPE,
                EmbeddedVrfKeyLinkTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedVrfKeyLinkTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedVrfKeyLinkTransactionV1(product), payload))
            }
            (
                EmbeddedHashLockTransactionV1::TRANSACTION_TYPE,
                EmbeddedHashLockTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedHashLockTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedHashLockTransactionV1(product), payload))
            }
            (
                EmbeddedSecretLockTransactionV1::TRANSACTION_TYPE,
                EmbeddedSecretLockTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedSecretLockTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedSecretLockTransactionV1(product), payload))
            }
            (
                EmbeddedSecretProofTransactionV1::TRANSACTION_TYPE,
                EmbeddedSecretProofTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedSecretProofTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedSecretProofTransactionV1(product), payload))
            }
            (
                EmbeddedAccountMetadataTransactionV1::TRANSACTION_TYPE,
                EmbeddedAccountMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedAccountMetadataTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedAccountMetadataTransactionV1(product), payload))
            }
            (
                EmbeddedMosaicMetadataTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedMosaicMetadataTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedMosaicMetadataTransactionV1(product), payload))
            }
            (
                EmbeddedNamespaceMetadataTransactionV1::TRANSACTION_TYPE,
                EmbeddedNamespaceMetadataTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedNamespaceMetadataTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedNamespaceMetadataTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMosaicDefinitionTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicDefinitionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMosaicDefinitionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMosaicDefinitionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMosaicSupplyChangeTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicSupplyChangeTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMosaicSupplyChangeTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMosaicSupplyChangeTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMosaicSupplyRevocationTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicSupplyRevocationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMosaicSupplyRevocationTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMosaicSupplyRevocationTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMultisigAccountModificationTransactionV1::TRANSACTION_TYPE,
                EmbeddedMultisigAccountModificationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMultisigAccountModificationTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMultisigAccountModificationTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedAddressAliasTransactionV1::TRANSACTION_TYPE,
                EmbeddedAddressAliasTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedAddressAliasTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedAddressAliasTransactionV1(product), payload))
            }
            (
                EmbeddedMosaicAliasTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicAliasTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedMosaicAliasTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedMosaicAliasTransactionV1(product), payload))
            }
            (
                EmbeddedNamespaceRegistrationTransactionV1::TRANSACTION_TYPE,
                EmbeddedNamespaceRegistrationTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedNamespaceRegistrationTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedNamespaceRegistrationTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedAccountAddressRestrictionTransactionV1::TRANSACTION_TYPE,
                EmbeddedAccountAddressRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedAccountAddressRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedAccountAddressRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedAccountMosaicRestrictionTransactionV1::TRANSACTION_TYPE,
                EmbeddedAccountMosaicRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedAccountMosaicRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedAccountMosaicRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedAccountOperationRestrictionTransactionV1::TRANSACTION_TYPE,
                EmbeddedAccountOperationRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedAccountOperationRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedAccountOperationRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMosaicAddressRestrictionTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicAddressRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMosaicAddressRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMosaicAddressRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedMosaicGlobalRestrictionTransactionV1::TRANSACTION_TYPE,
                EmbeddedMosaicGlobalRestrictionTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) =
                    EmbeddedMosaicGlobalRestrictionTransactionV1::deserialize(payload)?;
                Ok((
                    Self::EmbeddedMosaicGlobalRestrictionTransactionV1(product),
                    payload,
                ))
            }
            (
                EmbeddedTransferTransactionV1::TRANSACTION_TYPE,
                EmbeddedTransferTransactionV1::TRANSACTION_VERSION,
            ) => {
                let (product, payload) = EmbeddedTransferTransactionV1::deserialize(payload)?;
                Ok((Self::EmbeddedTransferTransactionV1(product), payload))
            }
            (other_type, other_version) => Err(SymbolError::MismatchError {
                pattern: vec![other_type as u32, other_version as u32],
                place: "EmbeddedTransaction".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::EmbeddedAccountKeyLinkTransactionV1(x) => x.serialize(),
            Self::EmbeddedNodeKeyLinkTransactionV1(x) => x.serialize(),
            Self::EmbeddedVotingKeyLinkTransactionV1(x) => x.serialize(),
            Self::EmbeddedVrfKeyLinkTransactionV1(x) => x.serialize(),
            Self::EmbeddedHashLockTransactionV1(x) => x.serialize(),
            Self::EmbeddedSecretLockTransactionV1(x) => x.serialize(),
            Self::EmbeddedSecretProofTransactionV1(x) => x.serialize(),
            Self::EmbeddedAccountMetadataTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicMetadataTransactionV1(x) => x.serialize(),
            Self::EmbeddedNamespaceMetadataTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicDefinitionTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicSupplyChangeTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicSupplyRevocationTransactionV1(x) => x.serialize(),
            Self::EmbeddedMultisigAccountModificationTransactionV1(x) => x.serialize(),
            Self::EmbeddedAddressAliasTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicAliasTransactionV1(x) => x.serialize(),
            Self::EmbeddedNamespaceRegistrationTransactionV1(x) => x.serialize(),
            Self::EmbeddedAccountAddressRestrictionTransactionV1(x) => x.serialize(),
            Self::EmbeddedAccountMosaicRestrictionTransactionV1(x) => x.serialize(),
            Self::EmbeddedAccountOperationRestrictionTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicAddressRestrictionTransactionV1(x) => x.serialize(),
            Self::EmbeddedMosaicGlobalRestrictionTransactionV1(x) => x.serialize(),
            Self::EmbeddedTransferTransactionV1(x) => x.serialize(),
        }
    }
}
impl From<EmbeddedAccountKeyLinkTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAccountKeyLinkTransactionV1) -> Self {
        Self::EmbeddedAccountKeyLinkTransactionV1(value)
    }
}
impl From<EmbeddedNodeKeyLinkTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedNodeKeyLinkTransactionV1) -> Self {
        Self::EmbeddedNodeKeyLinkTransactionV1(value)
    }
}
impl From<EmbeddedVotingKeyLinkTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedVotingKeyLinkTransactionV1) -> Self {
        Self::EmbeddedVotingKeyLinkTransactionV1(value)
    }
}
impl From<EmbeddedVrfKeyLinkTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedVrfKeyLinkTransactionV1) -> Self {
        Self::EmbeddedVrfKeyLinkTransactionV1(value)
    }
}
impl From<EmbeddedHashLockTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedHashLockTransactionV1) -> Self {
        Self::EmbeddedHashLockTransactionV1(value)
    }
}
impl From<EmbeddedSecretLockTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedSecretLockTransactionV1) -> Self {
        Self::EmbeddedSecretLockTransactionV1(value)
    }
}
impl From<EmbeddedSecretProofTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedSecretProofTransactionV1) -> Self {
        Self::EmbeddedSecretProofTransactionV1(value)
    }
}
impl From<EmbeddedAccountMetadataTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAccountMetadataTransactionV1) -> Self {
        Self::EmbeddedAccountMetadataTransactionV1(value)
    }
}
impl From<EmbeddedMosaicMetadataTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicMetadataTransactionV1) -> Self {
        Self::EmbeddedMosaicMetadataTransactionV1(value)
    }
}
impl From<EmbeddedNamespaceMetadataTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedNamespaceMetadataTransactionV1) -> Self {
        Self::EmbeddedNamespaceMetadataTransactionV1(value)
    }
}
impl From<EmbeddedMosaicDefinitionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicDefinitionTransactionV1) -> Self {
        Self::EmbeddedMosaicDefinitionTransactionV1(value)
    }
}
impl From<EmbeddedMosaicSupplyChangeTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicSupplyChangeTransactionV1) -> Self {
        Self::EmbeddedMosaicSupplyChangeTransactionV1(value)
    }
}
impl From<EmbeddedMosaicSupplyRevocationTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicSupplyRevocationTransactionV1) -> Self {
        Self::EmbeddedMosaicSupplyRevocationTransactionV1(value)
    }
}
impl From<EmbeddedMultisigAccountModificationTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMultisigAccountModificationTransactionV1) -> Self {
        Self::EmbeddedMultisigAccountModificationTransactionV1(value)
    }
}
impl From<EmbeddedAddressAliasTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAddressAliasTransactionV1) -> Self {
        Self::EmbeddedAddressAliasTransactionV1(value)
    }
}
impl From<EmbeddedMosaicAliasTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicAliasTransactionV1) -> Self {
        Self::EmbeddedMosaicAliasTransactionV1(value)
    }
}
impl From<EmbeddedNamespaceRegistrationTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedNamespaceRegistrationTransactionV1) -> Self {
        Self::EmbeddedNamespaceRegistrationTransactionV1(value)
    }
}
impl From<EmbeddedAccountAddressRestrictionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAccountAddressRestrictionTransactionV1) -> Self {
        Self::EmbeddedAccountAddressRestrictionTransactionV1(value)
    }
}
impl From<EmbeddedAccountMosaicRestrictionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAccountMosaicRestrictionTransactionV1) -> Self {
        Self::EmbeddedAccountMosaicRestrictionTransactionV1(value)
    }
}
impl From<EmbeddedAccountOperationRestrictionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedAccountOperationRestrictionTransactionV1) -> Self {
        Self::EmbeddedAccountOperationRestrictionTransactionV1(value)
    }
}
impl From<EmbeddedMosaicAddressRestrictionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicAddressRestrictionTransactionV1) -> Self {
        Self::EmbeddedMosaicAddressRestrictionTransactionV1(value)
    }
}
impl From<EmbeddedMosaicGlobalRestrictionTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedMosaicGlobalRestrictionTransactionV1) -> Self {
        Self::EmbeddedMosaicGlobalRestrictionTransactionV1(value)
    }
}
impl From<EmbeddedTransferTransactionV1> for EmbeddedTransaction {
    fn from(value: EmbeddedTransferTransactionV1) -> Self {
        Self::EmbeddedTransferTransactionV1(value)
    }
}
//name: ProofGamma
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 32
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(32)
//*is_unsigned: True
//*size: 32
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct ProofGamma(pub [u8; 32]);
impl ProofGamma {
    pub const SIZE: usize = 32;
    pub fn new(proofgamma: [u8; 32]) -> Self {
        Self(proofgamma)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

//name: ProofVerificationHash
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 16
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(16)
//*is_unsigned: True
//*size: 16
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct ProofVerificationHash(pub [u8; 16]);
impl ProofVerificationHash {
    pub const SIZE: usize = 16;
    pub fn new(proofverificationhash: [u8; 16]) -> Self {
        Self(proofverificationhash)
    }
    pub fn default() -> Self {
        Self([0; 16])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

//name: ProofScalar
//linked_type: <class 'catparser.ast.FixedSizeBuffer'>
//    size: 32
//    is_unsigned: True
//    display_type: DisplayType.BYTE_ARRAY
//    *name: binary_fixed(32)
//*is_unsigned: True
//*size: 32
#[derive(Debug, Clone, PartialEq, Eq)]

// generated from generate_bytearray()
pub struct ProofScalar(pub [u8; 32]);
impl ProofScalar {
    pub const SIZE: usize = 32;
    pub fn new(proofscalar: [u8; 32]) -> Self {
        Self(proofscalar)
    }
    pub fn default() -> Self {
        Self([0; 32])
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        Ok((Self(bytes.try_into()?), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

///enumeration of block types
//name: BlockType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint16
//    is_unsigned: True
//    size: 2
//    display_type: DisplayType.INTEGER
//    *name: uint16
//    *sizeref: None
//values: <class 'list'>
//    NEMESIS = 32835
//        name: NEMESIS
//        value: 32835
//    NORMAL = 33091
//        name: NORMAL
//        value: 33091
//    IMPORTANCE = 33347
//        name: IMPORTANCE
//        value: 33347
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 2
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u16)]
pub enum BlockType {
    NEMESIS = 32835,
    NORMAL = 33091,
    IMPORTANCE = 33347,
}
impl BlockType {
    pub const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::NEMESIS
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            32835 => Ok((BlockType::NEMESIS, rest)),
            33091 => Ok((BlockType::NORMAL, rest)),
            33347 => Ok((BlockType::IMPORTANCE, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "BlockType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
}
///verfiable random function proof
//name: VrfProof
//disposition: None
//fields: <class 'list'>
//    gamma = ProofGamma
//        name: gamma
//        field_type: ProofGamma
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    verification_hash = ProofVerificationHash
//        name: verification_hash
//        field_type: ProofVerificationHash
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scalar = ProofScalar
//        name: scalar
//        field_type: ProofScalar
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct VrfProof {
    pub gamma: ProofGamma,
    pub verification_hash: ProofVerificationHash,
    pub scalar: ProofScalar,
}
impl VrfProof {
    pub fn new(
        gamma: ProofGamma,
        verification_hash: ProofVerificationHash,
        scalar: ProofScalar,
    ) -> Self {
        Self {
            gamma,
            verification_hash,
            scalar,
        }
    }
    pub fn default() -> Self {
        Self {
            gamma: ProofGamma::default(),
            verification_hash: ProofVerificationHash::default(),
            scalar: ProofScalar::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.gamma.size();
        size += self.verification_hash.size();
        size += self.scalar.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let gamma;
        (gamma, payload) = ProofGamma::deserialize(payload)?;
        let verification_hash;
        (verification_hash, payload) = ProofVerificationHash::deserialize(payload)?;
        let scalar;
        (scalar, payload) = ProofScalar::deserialize(payload)?;
        let self_ = Self {
            gamma,
            verification_hash,
            scalar,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let gamma = self.gamma.serialize();
        let verification_hash = self.verification_hash.serialize();
        let scalar = self.scalar.serialize();
        [gamma.iter(), verification_hash.iter(), scalar.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///binary layout for a block
//name: Block
//disposition: abstract
//fields: <class 'list'>
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = BlockType
//        name: type
//        field_type: BlockType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    height = Height
//        name: height
//        field_type: Height
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    timestamp = Timestamp
//        name: timestamp
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    difficulty = Difficulty
//        name: difficulty
//        field_type: Difficulty
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    generation_hash_proof = VrfProof
//        name: generation_hash_proof
//        field_type: VrfProof
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_block_hash = Hash256
//        name: previous_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    receipts_hash = Hash256
//        name: receipts_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    state_hash = Hash256
//        name: state_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    beneficiary_address = Address
//        name: beneficiary_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee_multiplier = BlockFeeMultiplier
//        name: fee_multiplier
//        field_type: BlockFeeMultiplier
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, BLOCK_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            BLOCK_VERSION
//    @initializes(type, BLOCK_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            BLOCK_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
//*is_abstract: True
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_factory()
pub enum Block {
    NemesisBlockV1(NemesisBlockV1),
    NormalBlockV1(NormalBlockV1),
    ImportanceBlockV1(ImportanceBlockV1),
}
#[allow(unreachable_patterns)]
impl Block {
    pub fn size(&self) -> usize {
        match self {
            Self::NemesisBlockV1(x) => x.size(),
            Self::NormalBlockV1(x) => x.size(),
            Self::ImportanceBlockV1(x) => x.size(),
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mut _tmp_payload = payload;
        if _tmp_payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: _tmp_payload.len(),
            });
        }
        let _size = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _size as usize > _tmp_payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![_size as usize],
                real: _tmp_payload.len() + 4,
            });
        }
        let _verifiable_entity_header_reserved_1 =
            u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let _signature;
        (_signature, _tmp_payload) = Signature::deserialize(_tmp_payload)?;
        let _signer_public_key;
        (_signer_public_key, _tmp_payload) = PublicKey::deserialize(_tmp_payload)?;
        let _entity_body_reserved_1 = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                _entity_body_reserved_1 as u32,
            ));
        }
        let __version = u8::from_le_bytes(_tmp_payload[..1].try_into()?);
        _tmp_payload = &_tmp_payload[1..];
        let _network;
        (_network, _tmp_payload) = NetworkType::deserialize(_tmp_payload)?;
        let _type;
        (_type, _tmp_payload) = BlockType::deserialize(_tmp_payload)?;
        let _height;
        (_height, _tmp_payload) = Height::deserialize(_tmp_payload)?;
        let _timestamp;
        (_timestamp, _tmp_payload) = Timestamp::deserialize(_tmp_payload)?;
        let _difficulty;
        (_difficulty, _tmp_payload) = Difficulty::deserialize(_tmp_payload)?;
        let _generation_hash_proof;
        (_generation_hash_proof, _tmp_payload) = VrfProof::deserialize(_tmp_payload)?;
        let _previous_block_hash;
        (_previous_block_hash, _tmp_payload) = Hash256::deserialize(_tmp_payload)?;
        let _transactions_hash;
        (_transactions_hash, _tmp_payload) = Hash256::deserialize(_tmp_payload)?;
        let _receipts_hash;
        (_receipts_hash, _tmp_payload) = Hash256::deserialize(_tmp_payload)?;
        let _state_hash;
        (_state_hash, _tmp_payload) = Hash256::deserialize(_tmp_payload)?;
        let _beneficiary_address;
        (_beneficiary_address, _tmp_payload) = Address::deserialize(_tmp_payload)?;
        let _fee_multiplier;
        (_fee_multiplier, _tmp_payload) = BlockFeeMultiplier::deserialize(_tmp_payload)?;
        match (_type,) {
            (NemesisBlockV1::BLOCK_TYPE,) => {
                let (product, payload) = NemesisBlockV1::deserialize(payload)?;
                Ok((Self::NemesisBlockV1(product), payload))
            }
            (NormalBlockV1::BLOCK_TYPE,) => {
                let (product, payload) = NormalBlockV1::deserialize(payload)?;
                Ok((Self::NormalBlockV1(product), payload))
            }
            (ImportanceBlockV1::BLOCK_TYPE,) => {
                let (product, payload) = ImportanceBlockV1::deserialize(payload)?;
                Ok((Self::ImportanceBlockV1(product), payload))
            }
            (other_type,) => Err(SymbolError::MismatchError {
                pattern: vec![other_type as u32],
                place: "Block".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::NemesisBlockV1(x) => x.serialize(),
            Self::NormalBlockV1(x) => x.serialize(),
            Self::ImportanceBlockV1(x) => x.serialize(),
        }
    }
}
impl From<NemesisBlockV1> for Block {
    fn from(value: NemesisBlockV1) -> Self {
        Self::NemesisBlockV1(value)
    }
}
impl From<NormalBlockV1> for Block {
    fn from(value: NormalBlockV1) -> Self {
        Self::NormalBlockV1(value)
    }
}
impl From<ImportanceBlockV1> for Block {
    fn from(value: ImportanceBlockV1) -> Self {
        Self::ImportanceBlockV1(value)
    }
}
///binary layout for a nemesis block header
//name: NemesisBlockV1
//disposition: None
//fields: <class 'list'>
//    BLOCK_VERSION = make_const(u8, 1)
//        name: BLOCK_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    BLOCK_TYPE = make_const(BlockType, NEMESIS)
//        name: BLOCK_TYPE
//        field_type: BlockType
//        value: NEMESIS
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = BlockType
//        name: type
//        field_type: BlockType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    height = Height
//        name: height
//        field_type: Height
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    timestamp = Timestamp
//        name: timestamp
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    difficulty = Difficulty
//        name: difficulty
//        field_type: Difficulty
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    generation_hash_proof = VrfProof
//        name: generation_hash_proof
//        field_type: VrfProof
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_block_hash = Hash256
//        name: previous_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    receipts_hash = Hash256
//        name: receipts_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    state_hash = Hash256
//        name: state_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    beneficiary_address = Address
//        name: beneficiary_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee_multiplier = BlockFeeMultiplier
//        name: fee_multiplier
//        field_type: BlockFeeMultiplier
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    voting_eligible_accounts_count = u32
//        name: voting_eligible_accounts_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    harvesting_eligible_accounts_count = u64
//        name: harvesting_eligible_accounts_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    total_voting_balance = Amount
//        name: total_voting_balance
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_importance_block_hash = Hash256
//        name: previous_importance_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Transaction
//            size: 0
//            *alignment: 8
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: False
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @alignment(8, not pad_last)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    not
//                    pad_last
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Block
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, BLOCK_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            BLOCK_VERSION
//    @initializes(type, BLOCK_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            BLOCK_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NemesisBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub voting_eligible_accounts_count: u32,
    pub harvesting_eligible_accounts_count: u64,
    pub total_voting_balance: Amount,
    pub previous_importance_block_hash: Hash256,
    pub transactions: Vec<Transaction>,
}
impl NemesisBlockV1 {
    pub const BLOCK_VERSION: u8 = 1;
    pub const BLOCK_TYPE: BlockType = BlockType::NEMESIS;
    pub fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    pub fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        voting_eligible_accounts_count: u32,
        harvesting_eligible_accounts_count: u64,
        total_voting_balance: Amount,
        previous_importance_block_hash: Hash256,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            voting_eligible_accounts_count: u32::default(),
            harvesting_eligible_accounts_count: u64::default(),
            total_voting_balance: Amount::default(),
            previous_importance_block_hash: Hash256::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        size += 8;
        size += self.total_voting_balance.size();
        size += self.previous_importance_block_hash.size();
        for i in 0..self.transactions.len() {
            let x = &self.transactions[i];
            if i + 1 == self.transactions.len() {
                size += x.size();
                break;
            }
            size += (x.size() + 7) & !7;
        }
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let voting_eligible_accounts_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let harvesting_eligible_accounts_count = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let total_voting_balance;
        (total_voting_balance, payload) = Amount::deserialize(payload)?;
        let previous_importance_block_hash;
        (previous_importance_block_hash, payload) = Hash256::deserialize(payload)?;
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
            if payload.len() == 0 {
                break;
            };
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let voting_eligible_accounts_count = self.voting_eligible_accounts_count.to_le_bytes();
        let harvesting_eligible_accounts_count =
            self.harvesting_eligible_accounts_count.to_le_bytes();
        let total_voting_balance = self.total_voting_balance.serialize();
        let previous_importance_block_hash = self.previous_importance_block_hash.serialize();
        let mut transactions = Vec::new();
        let transactions_len = self.transactions.len();
        for i in 0..transactions_len {
            let x = &self.transactions[i];
            transactions.extend_from_slice(&x.serialize());
            if transactions_len == i + 1 {
                break;
            }
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            voting_eligible_accounts_count.iter(),
            harvesting_eligible_accounts_count.iter(),
            total_voting_balance.iter(),
            previous_importance_block_hash.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for NemesisBlockV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for NemesisBlockV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///binary layout for a normal block header
//name: NormalBlockV1
//disposition: None
//fields: <class 'list'>
//    BLOCK_VERSION = make_const(u8, 1)
//        name: BLOCK_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    BLOCK_TYPE = make_const(BlockType, NORMAL)
//        name: BLOCK_TYPE
//        field_type: BlockType
//        value: NORMAL
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = BlockType
//        name: type
//        field_type: BlockType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    height = Height
//        name: height
//        field_type: Height
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    timestamp = Timestamp
//        name: timestamp
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    difficulty = Difficulty
//        name: difficulty
//        field_type: Difficulty
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    generation_hash_proof = VrfProof
//        name: generation_hash_proof
//        field_type: VrfProof
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_block_hash = Hash256
//        name: previous_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    receipts_hash = Hash256
//        name: receipts_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    state_hash = Hash256
//        name: state_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    beneficiary_address = Address
//        name: beneficiary_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee_multiplier = BlockFeeMultiplier
//        name: fee_multiplier
//        field_type: BlockFeeMultiplier
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    block_header_reserved_1 = make_reserved(u32, 0)
//        name: block_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Transaction
//            size: 0
//            *alignment: 8
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: False
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @alignment(8, not pad_last)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    not
//                    pad_last
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Block
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, BLOCK_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            BLOCK_VERSION
//    @initializes(type, BLOCK_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            BLOCK_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NormalBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub transactions: Vec<Transaction>,
}
impl NormalBlockV1 {
    pub const BLOCK_VERSION: u8 = 1;
    pub const BLOCK_TYPE: BlockType = BlockType::NORMAL;
    pub fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    pub fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        for i in 0..self.transactions.len() {
            let x = &self.transactions[i];
            if i + 1 == self.transactions.len() {
                size += x.size();
                break;
            }
            size += (x.size() + 7) & !7;
        }
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let block_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if block_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                block_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
            if payload.len() == 0 {
                break;
            };
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let block_header_reserved_1 = 0u32.to_le_bytes();
        let mut transactions = Vec::new();
        let transactions_len = self.transactions.len();
        for i in 0..transactions_len {
            let x = &self.transactions[i];
            transactions.extend_from_slice(&x.serialize());
            if transactions_len == i + 1 {
                break;
            }
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            block_header_reserved_1.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for NormalBlockV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for NormalBlockV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///binary layout for an importance block header
//name: ImportanceBlockV1
//disposition: None
//fields: <class 'list'>
//    BLOCK_VERSION = make_const(u8, 1)
//        name: BLOCK_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    BLOCK_TYPE = make_const(BlockType, IMPORTANCE)
//        name: BLOCK_TYPE
//        field_type: BlockType
//        value: IMPORTANCE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = BlockType
//        name: type
//        field_type: BlockType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    height = Height
//        name: height
//        field_type: Height
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    timestamp = Timestamp
//        name: timestamp
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    difficulty = Difficulty
//        name: difficulty
//        field_type: Difficulty
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    generation_hash_proof = VrfProof
//        name: generation_hash_proof
//        field_type: VrfProof
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_block_hash = Hash256
//        name: previous_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    receipts_hash = Hash256
//        name: receipts_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    state_hash = Hash256
//        name: state_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    beneficiary_address = Address
//        name: beneficiary_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee_multiplier = BlockFeeMultiplier
//        name: fee_multiplier
//        field_type: BlockFeeMultiplier
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    voting_eligible_accounts_count = u32
//        name: voting_eligible_accounts_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    harvesting_eligible_accounts_count = u64
//        name: harvesting_eligible_accounts_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    total_voting_balance = Amount
//        name: total_voting_balance
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    previous_importance_block_hash = Hash256
//        name: previous_importance_block_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    @alignment(8, not pad_last) transactions = array(Transaction, __FILL__)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Transaction
//            size: 0
//            *alignment: 8
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: False
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @alignment(8, not pad_last)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    not
//                    pad_last
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Block
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, BLOCK_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            BLOCK_VERSION
//    @initializes(type, BLOCK_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            BLOCK_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='version', value='BLOCK_VERSION'), Initializer(target_property_name='type', value='BLOCK_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct ImportanceBlockV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub height: Height,
    pub timestamp: Timestamp,
    pub difficulty: Difficulty,
    pub generation_hash_proof: VrfProof,
    pub previous_block_hash: Hash256,
    pub transactions_hash: Hash256,
    pub receipts_hash: Hash256,
    pub state_hash: Hash256,
    pub beneficiary_address: Address,
    pub fee_multiplier: BlockFeeMultiplier,
    pub voting_eligible_accounts_count: u32,
    pub harvesting_eligible_accounts_count: u64,
    pub total_voting_balance: Amount,
    pub previous_importance_block_hash: Hash256,
    pub transactions: Vec<Transaction>,
}
impl ImportanceBlockV1 {
    pub const BLOCK_VERSION: u8 = 1;
    pub const BLOCK_TYPE: BlockType = BlockType::IMPORTANCE;
    pub fn version(&self) -> u8 {
        Self::BLOCK_VERSION
    }
    pub fn type_(&self) -> BlockType {
        Self::BLOCK_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        height: Height,
        timestamp: Timestamp,
        difficulty: Difficulty,
        generation_hash_proof: VrfProof,
        previous_block_hash: Hash256,
        transactions_hash: Hash256,
        receipts_hash: Hash256,
        state_hash: Hash256,
        beneficiary_address: Address,
        fee_multiplier: BlockFeeMultiplier,
        voting_eligible_accounts_count: u32,
        harvesting_eligible_accounts_count: u64,
        total_voting_balance: Amount,
        previous_importance_block_hash: Hash256,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            height: Height::default(),
            timestamp: Timestamp::default(),
            difficulty: Difficulty::default(),
            generation_hash_proof: VrfProof::default(),
            previous_block_hash: Hash256::default(),
            transactions_hash: Hash256::default(),
            receipts_hash: Hash256::default(),
            state_hash: Hash256::default(),
            beneficiary_address: Address::default(),
            fee_multiplier: BlockFeeMultiplier::default(),
            voting_eligible_accounts_count: u32::default(),
            harvesting_eligible_accounts_count: u64::default(),
            total_voting_balance: Amount::default(),
            previous_importance_block_hash: Hash256::default(),
            transactions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.height.size();
        size += self.timestamp.size();
        size += self.difficulty.size();
        size += self.generation_hash_proof.size();
        size += self.previous_block_hash.size();
        size += self.transactions_hash.size();
        size += self.receipts_hash.size();
        size += self.state_hash.size();
        size += self.beneficiary_address.size();
        size += self.fee_multiplier.size();
        size += 4;
        size += 8;
        size += self.total_voting_balance.size();
        size += self.previous_importance_block_hash.size();
        for i in 0..self.transactions.len() {
            let x = &self.transactions[i];
            if i + 1 == self.transactions.len() {
                size += x.size();
                break;
            }
            size += (x.size() + 7) & !7;
        }
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = BlockType::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let timestamp;
        (timestamp, payload) = Timestamp::deserialize(payload)?;
        let difficulty;
        (difficulty, payload) = Difficulty::deserialize(payload)?;
        let generation_hash_proof;
        (generation_hash_proof, payload) = VrfProof::deserialize(payload)?;
        let previous_block_hash;
        (previous_block_hash, payload) = Hash256::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let receipts_hash;
        (receipts_hash, payload) = Hash256::deserialize(payload)?;
        let state_hash;
        (state_hash, payload) = Hash256::deserialize(payload)?;
        let beneficiary_address;
        (beneficiary_address, payload) = Address::deserialize(payload)?;
        let fee_multiplier;
        (fee_multiplier, payload) = BlockFeeMultiplier::deserialize(payload)?;
        let voting_eligible_accounts_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let harvesting_eligible_accounts_count = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let total_voting_balance;
        (total_voting_balance, payload) = Amount::deserialize(payload)?;
        let previous_importance_block_hash;
        (previous_importance_block_hash, payload) = Hash256::deserialize(payload)?;
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Transaction::deserialize(payload)?;
            transactions.push(element);
            if payload.len() == 0 {
                break;
            };
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            height,
            timestamp,
            difficulty,
            generation_hash_proof,
            previous_block_hash,
            transactions_hash,
            receipts_hash,
            state_hash,
            beneficiary_address,
            fee_multiplier,
            voting_eligible_accounts_count,
            harvesting_eligible_accounts_count,
            total_voting_balance,
            previous_importance_block_hash,
            transactions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let height = self.height.serialize();
        let timestamp = self.timestamp.serialize();
        let difficulty = self.difficulty.serialize();
        let generation_hash_proof = self.generation_hash_proof.serialize();
        let previous_block_hash = self.previous_block_hash.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let receipts_hash = self.receipts_hash.serialize();
        let state_hash = self.state_hash.serialize();
        let beneficiary_address = self.beneficiary_address.serialize();
        let fee_multiplier = self.fee_multiplier.serialize();
        let voting_eligible_accounts_count = self.voting_eligible_accounts_count.to_le_bytes();
        let harvesting_eligible_accounts_count =
            self.harvesting_eligible_accounts_count.to_le_bytes();
        let total_voting_balance = self.total_voting_balance.serialize();
        let previous_importance_block_hash = self.previous_importance_block_hash.serialize();
        let mut transactions = Vec::new();
        let transactions_len = self.transactions.len();
        for i in 0..transactions_len {
            let x = &self.transactions[i];
            transactions.extend_from_slice(&x.serialize());
            if transactions_len == i + 1 {
                break;
            }
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            height.iter(),
            timestamp.iter(),
            difficulty.iter(),
            generation_hash_proof.iter(),
            previous_block_hash.iter(),
            transactions_hash.iter(),
            receipts_hash.iter(),
            state_hash.iter(),
            beneficiary_address.iter(),
            fee_multiplier.iter(),
            voting_eligible_accounts_count.iter(),
            harvesting_eligible_accounts_count.iter(),
            total_voting_balance.iter(),
            previous_importance_block_hash.iter(),
            transactions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for ImportanceBlockV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for ImportanceBlockV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///binary layout for finalization round
//name: FinalizationRound
//disposition: None
//fields: <class 'list'>
//    epoch = FinalizationEpoch
//        name: epoch
//        field_type: FinalizationEpoch
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    point = FinalizationPoint
//        name: point
//        field_type: FinalizationPoint
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct FinalizationRound {
    pub epoch: FinalizationEpoch,
    pub point: FinalizationPoint,
}
impl FinalizationRound {
    pub fn new(epoch: FinalizationEpoch, point: FinalizationPoint) -> Self {
        Self { epoch, point }
    }
    pub fn default() -> Self {
        Self {
            epoch: FinalizationEpoch::default(),
            point: FinalizationPoint::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.epoch.size();
        size += self.point.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let epoch;
        (epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let point;
        (point, payload) = FinalizationPoint::deserialize(payload)?;
        let self_ = Self { epoch, point };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let epoch = self.epoch.serialize();
        let point = self.point.serialize();
        [epoch.iter(), point.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///binary layout for finalized block header
//name: FinalizedBlockHeader
//disposition: None
//fields: <class 'list'>
//    round = FinalizationRound
//        name: round
//        field_type: FinalizationRound
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    height = Height
//        name: height
//        field_type: Height
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    hash = Hash256
//        name: hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct FinalizedBlockHeader {
    pub round: FinalizationRound,
    pub height: Height,
    pub hash: Hash256,
}
impl FinalizedBlockHeader {
    pub fn new(round: FinalizationRound, height: Height, hash: Hash256) -> Self {
        Self {
            round,
            height,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            round: FinalizationRound::default(),
            height: Height::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.round.size();
        size += self.height.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let round;
        (round, payload) = FinalizationRound::deserialize(payload)?;
        let height;
        (height, payload) = Height::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            round,
            height,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let round = self.round.serialize();
        let height = self.height.serialize();
        let hash = self.hash.serialize();
        [round.iter(), height.iter(), hash.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///Enumeration of receipt types.
//name: ReceiptType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint16
//    is_unsigned: True
//    size: 2
//    display_type: DisplayType.INTEGER
//    *name: uint16
//    *sizeref: None
//values: <class 'list'>
//    MOSAIC_RENTAL_FEE = 4685
//        name: MOSAIC_RENTAL_FEE
//        value: 4685
//    NAMESPACE_RENTAL_FEE = 4942
//        name: NAMESPACE_RENTAL_FEE
//        value: 4942
//    HARVEST_FEE = 8515
//        name: HARVEST_FEE
//        value: 8515
//    LOCK_HASH_COMPLETED = 8776
//        name: LOCK_HASH_COMPLETED
//        value: 8776
//    LOCK_HASH_EXPIRED = 9032
//        name: LOCK_HASH_EXPIRED
//        value: 9032
//    LOCK_SECRET_COMPLETED = 8786
//        name: LOCK_SECRET_COMPLETED
//        value: 8786
//    LOCK_SECRET_EXPIRED = 9042
//        name: LOCK_SECRET_EXPIRED
//        value: 9042
//    LOCK_HASH_CREATED = 12616
//        name: LOCK_HASH_CREATED
//        value: 12616
//    LOCK_SECRET_CREATED = 12626
//        name: LOCK_SECRET_CREATED
//        value: 12626
//    MOSAIC_EXPIRED = 16717
//        name: MOSAIC_EXPIRED
//        value: 16717
//    NAMESPACE_EXPIRED = 16718
//        name: NAMESPACE_EXPIRED
//        value: 16718
//    NAMESPACE_DELETED = 16974
//        name: NAMESPACE_DELETED
//        value: 16974
//    INFLATION = 20803
//        name: INFLATION
//        value: 20803
//    TRANSACTION_GROUP = 57667
//        name: TRANSACTION_GROUP
//        value: 57667
//    ADDRESS_ALIAS_RESOLUTION = 61763
//        name: ADDRESS_ALIAS_RESOLUTION
//        value: 61763
//    MOSAIC_ALIAS_RESOLUTION = 62019
//        name: MOSAIC_ALIAS_RESOLUTION
//        value: 62019
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 2
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u16)]
pub enum ReceiptType {
    MOSAIC_RENTAL_FEE = 4685,
    NAMESPACE_RENTAL_FEE = 4942,
    HARVEST_FEE = 8515,
    LOCK_HASH_COMPLETED = 8776,
    LOCK_HASH_EXPIRED = 9032,
    LOCK_SECRET_COMPLETED = 8786,
    LOCK_SECRET_EXPIRED = 9042,
    LOCK_HASH_CREATED = 12616,
    LOCK_SECRET_CREATED = 12626,
    MOSAIC_EXPIRED = 16717,
    NAMESPACE_EXPIRED = 16718,
    NAMESPACE_DELETED = 16974,
    INFLATION = 20803,
    TRANSACTION_GROUP = 57667,
    ADDRESS_ALIAS_RESOLUTION = 61763,
    MOSAIC_ALIAS_RESOLUTION = 62019,
}
impl ReceiptType {
    pub const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::MOSAIC_RENTAL_FEE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            4685 => Ok((ReceiptType::MOSAIC_RENTAL_FEE, rest)),
            4942 => Ok((ReceiptType::NAMESPACE_RENTAL_FEE, rest)),
            8515 => Ok((ReceiptType::HARVEST_FEE, rest)),
            8776 => Ok((ReceiptType::LOCK_HASH_COMPLETED, rest)),
            9032 => Ok((ReceiptType::LOCK_HASH_EXPIRED, rest)),
            8786 => Ok((ReceiptType::LOCK_SECRET_COMPLETED, rest)),
            9042 => Ok((ReceiptType::LOCK_SECRET_EXPIRED, rest)),
            12616 => Ok((ReceiptType::LOCK_HASH_CREATED, rest)),
            12626 => Ok((ReceiptType::LOCK_SECRET_CREATED, rest)),
            16717 => Ok((ReceiptType::MOSAIC_EXPIRED, rest)),
            16718 => Ok((ReceiptType::NAMESPACE_EXPIRED, rest)),
            16974 => Ok((ReceiptType::NAMESPACE_DELETED, rest)),
            20803 => Ok((ReceiptType::INFLATION, rest)),
            57667 => Ok((ReceiptType::TRANSACTION_GROUP, rest)),
            61763 => Ok((ReceiptType::ADDRESS_ALIAS_RESOLUTION, rest)),
            62019 => Ok((ReceiptType::MOSAIC_ALIAS_RESOLUTION, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "ReceiptType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u16).to_le_bytes().to_vec()
    }
}
///Receipts provide proof for every state change not retrievable from the block.
//name: Receipt
//disposition: abstract
//fields: <class 'list'>
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: True
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_factory()
pub enum Receipt {
    HarvestFeeReceipt(HarvestFeeReceipt),
    InflationReceipt(InflationReceipt),
    LockHashCreatedFeeReceipt(LockHashCreatedFeeReceipt),
    LockHashCompletedFeeReceipt(LockHashCompletedFeeReceipt),
    LockHashExpiredFeeReceipt(LockHashExpiredFeeReceipt),
    LockSecretCreatedFeeReceipt(LockSecretCreatedFeeReceipt),
    LockSecretCompletedFeeReceipt(LockSecretCompletedFeeReceipt),
    LockSecretExpiredFeeReceipt(LockSecretExpiredFeeReceipt),
    MosaicExpiredReceipt(MosaicExpiredReceipt),
    MosaicRentalFeeReceipt(MosaicRentalFeeReceipt),
    NamespaceExpiredReceipt(NamespaceExpiredReceipt),
    NamespaceDeletedReceipt(NamespaceDeletedReceipt),
    NamespaceRentalFeeReceipt(NamespaceRentalFeeReceipt),
}
#[allow(unreachable_patterns)]
impl Receipt {
    pub fn size(&self) -> usize {
        match self {
            Self::HarvestFeeReceipt(x) => x.size(),
            Self::InflationReceipt(x) => x.size(),
            Self::LockHashCreatedFeeReceipt(x) => x.size(),
            Self::LockHashCompletedFeeReceipt(x) => x.size(),
            Self::LockHashExpiredFeeReceipt(x) => x.size(),
            Self::LockSecretCreatedFeeReceipt(x) => x.size(),
            Self::LockSecretCompletedFeeReceipt(x) => x.size(),
            Self::LockSecretExpiredFeeReceipt(x) => x.size(),
            Self::MosaicExpiredReceipt(x) => x.size(),
            Self::MosaicRentalFeeReceipt(x) => x.size(),
            Self::NamespaceExpiredReceipt(x) => x.size(),
            Self::NamespaceDeletedReceipt(x) => x.size(),
            Self::NamespaceRentalFeeReceipt(x) => x.size(),
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        let mut _tmp_payload = payload;
        if _tmp_payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: _tmp_payload.len(),
            });
        }
        let _size = u32::from_le_bytes(_tmp_payload[..4].try_into()?);
        _tmp_payload = &_tmp_payload[4..];
        if _size as usize > _tmp_payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![_size as usize],
                real: _tmp_payload.len() + 4,
            });
        }
        let _version = u16::from_le_bytes(_tmp_payload[..2].try_into()?);
        _tmp_payload = &_tmp_payload[2..];
        let _type;
        (_type, _tmp_payload) = ReceiptType::deserialize(_tmp_payload)?;
        match (_type,) {
            (HarvestFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = HarvestFeeReceipt::deserialize(payload)?;
                Ok((Self::HarvestFeeReceipt(product), payload))
            }
            (InflationReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = InflationReceipt::deserialize(payload)?;
                Ok((Self::InflationReceipt(product), payload))
            }
            (LockHashCreatedFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockHashCreatedFeeReceipt::deserialize(payload)?;
                Ok((Self::LockHashCreatedFeeReceipt(product), payload))
            }
            (LockHashCompletedFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockHashCompletedFeeReceipt::deserialize(payload)?;
                Ok((Self::LockHashCompletedFeeReceipt(product), payload))
            }
            (LockHashExpiredFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockHashExpiredFeeReceipt::deserialize(payload)?;
                Ok((Self::LockHashExpiredFeeReceipt(product), payload))
            }
            (LockSecretCreatedFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockSecretCreatedFeeReceipt::deserialize(payload)?;
                Ok((Self::LockSecretCreatedFeeReceipt(product), payload))
            }
            (LockSecretCompletedFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockSecretCompletedFeeReceipt::deserialize(payload)?;
                Ok((Self::LockSecretCompletedFeeReceipt(product), payload))
            }
            (LockSecretExpiredFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = LockSecretExpiredFeeReceipt::deserialize(payload)?;
                Ok((Self::LockSecretExpiredFeeReceipt(product), payload))
            }
            (MosaicExpiredReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = MosaicExpiredReceipt::deserialize(payload)?;
                Ok((Self::MosaicExpiredReceipt(product), payload))
            }
            (MosaicRentalFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = MosaicRentalFeeReceipt::deserialize(payload)?;
                Ok((Self::MosaicRentalFeeReceipt(product), payload))
            }
            (NamespaceExpiredReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = NamespaceExpiredReceipt::deserialize(payload)?;
                Ok((Self::NamespaceExpiredReceipt(product), payload))
            }
            (NamespaceDeletedReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = NamespaceDeletedReceipt::deserialize(payload)?;
                Ok((Self::NamespaceDeletedReceipt(product), payload))
            }
            (NamespaceRentalFeeReceipt::RECEIPT_TYPE,) => {
                let (product, payload) = NamespaceRentalFeeReceipt::deserialize(payload)?;
                Ok((Self::NamespaceRentalFeeReceipt(product), payload))
            }
            (other_type,) => Err(SymbolError::MismatchError {
                pattern: vec![other_type as u32],
                place: "Receipt".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::HarvestFeeReceipt(x) => x.serialize(),
            Self::InflationReceipt(x) => x.serialize(),
            Self::LockHashCreatedFeeReceipt(x) => x.serialize(),
            Self::LockHashCompletedFeeReceipt(x) => x.serialize(),
            Self::LockHashExpiredFeeReceipt(x) => x.serialize(),
            Self::LockSecretCreatedFeeReceipt(x) => x.serialize(),
            Self::LockSecretCompletedFeeReceipt(x) => x.serialize(),
            Self::LockSecretExpiredFeeReceipt(x) => x.serialize(),
            Self::MosaicExpiredReceipt(x) => x.serialize(),
            Self::MosaicRentalFeeReceipt(x) => x.serialize(),
            Self::NamespaceExpiredReceipt(x) => x.serialize(),
            Self::NamespaceDeletedReceipt(x) => x.serialize(),
            Self::NamespaceRentalFeeReceipt(x) => x.serialize(),
        }
    }
}
impl From<HarvestFeeReceipt> for Receipt {
    fn from(value: HarvestFeeReceipt) -> Self {
        Self::HarvestFeeReceipt(value)
    }
}
impl From<InflationReceipt> for Receipt {
    fn from(value: InflationReceipt) -> Self {
        Self::InflationReceipt(value)
    }
}
impl From<LockHashCreatedFeeReceipt> for Receipt {
    fn from(value: LockHashCreatedFeeReceipt) -> Self {
        Self::LockHashCreatedFeeReceipt(value)
    }
}
impl From<LockHashCompletedFeeReceipt> for Receipt {
    fn from(value: LockHashCompletedFeeReceipt) -> Self {
        Self::LockHashCompletedFeeReceipt(value)
    }
}
impl From<LockHashExpiredFeeReceipt> for Receipt {
    fn from(value: LockHashExpiredFeeReceipt) -> Self {
        Self::LockHashExpiredFeeReceipt(value)
    }
}
impl From<LockSecretCreatedFeeReceipt> for Receipt {
    fn from(value: LockSecretCreatedFeeReceipt) -> Self {
        Self::LockSecretCreatedFeeReceipt(value)
    }
}
impl From<LockSecretCompletedFeeReceipt> for Receipt {
    fn from(value: LockSecretCompletedFeeReceipt) -> Self {
        Self::LockSecretCompletedFeeReceipt(value)
    }
}
impl From<LockSecretExpiredFeeReceipt> for Receipt {
    fn from(value: LockSecretExpiredFeeReceipt) -> Self {
        Self::LockSecretExpiredFeeReceipt(value)
    }
}
impl From<MosaicExpiredReceipt> for Receipt {
    fn from(value: MosaicExpiredReceipt) -> Self {
        Self::MosaicExpiredReceipt(value)
    }
}
impl From<MosaicRentalFeeReceipt> for Receipt {
    fn from(value: MosaicRentalFeeReceipt) -> Self {
        Self::MosaicRentalFeeReceipt(value)
    }
}
impl From<NamespaceExpiredReceipt> for Receipt {
    fn from(value: NamespaceExpiredReceipt) -> Self {
        Self::NamespaceExpiredReceipt(value)
    }
}
impl From<NamespaceDeletedReceipt> for Receipt {
    fn from(value: NamespaceDeletedReceipt) -> Self {
        Self::NamespaceDeletedReceipt(value)
    }
}
impl From<NamespaceRentalFeeReceipt> for Receipt {
    fn from(value: NamespaceRentalFeeReceipt) -> Self {
        Self::NamespaceRentalFeeReceipt(value)
    }
}
///Receipt generated when transaction fees are credited to a block harvester.
//name: HarvestFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, HARVEST_FEE)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: HARVEST_FEE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct HarvestFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl HarvestFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::HARVEST_FEE;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Network currency mosaics were created due to [inflation](/concepts/inflation).
//name: InflationReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, INFLATION)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: INFLATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct InflationReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
}
impl InflationReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::INFLATION;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic) -> Self {
        Self { version, mosaic }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let self_ = Self { version, mosaic };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        [size.iter(), version.iter(), type_.iter(), mosaic.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///Receipt generated when hash lock is created.
//name: LockHashCreatedFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_CREATED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_HASH_CREATED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockHashCreatedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashCreatedFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_CREATED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when hash lock is completed.
//name: LockHashCompletedFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_COMPLETED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_HASH_COMPLETED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockHashCompletedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashCompletedFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_COMPLETED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when hash lock is expired.
//name: LockHashExpiredFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_HASH_EXPIRED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_HASH_EXPIRED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockHashExpiredFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockHashExpiredFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_EXPIRED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when secret lock is created.
//name: LockSecretCreatedFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_CREATED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_SECRET_CREATED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockSecretCreatedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretCreatedFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_CREATED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when secret lock is completed.
//name: LockSecretCompletedFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_COMPLETED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_SECRET_COMPLETED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockSecretCompletedFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretCompletedFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_COMPLETED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when secret lock is expired.
//name: LockSecretExpiredFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, LOCK_SECRET_EXPIRED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: LOCK_SECRET_EXPIRED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = Address
//        name: target_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct LockSecretExpiredFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub target_address: Address,
}
impl LockSecretExpiredFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_EXPIRED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, mosaic: Mosaic, target_address: Address) -> Self {
        Self {
            version,
            mosaic,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            target_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let target_address;
        (target_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when a mosaic expires.
//name: MosaicExpiredReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, MOSAIC_EXPIRED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: MOSAIC_EXPIRED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    artifact_id = MosaicId
//        name: artifact_id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicExpiredReceipt {
    pub version: u16,
    pub artifact_id: MosaicId,
}
impl MosaicExpiredReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_EXPIRED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: MosaicId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: MosaicId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = MosaicId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when a mosaic rental fee is paid.
//name: MosaicRentalFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, MOSAIC_RENTAL_FEE)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: MOSAIC_RENTAL_FEE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    sender_address = Address
//        name: sender_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = Address
//        name: recipient_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicRentalFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub sender_address: Address,
    pub recipient_address: Address,
}
impl MosaicRentalFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_RENTAL_FEE;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(
        version: u16,
        mosaic: Mosaic,
        sender_address: Address,
        recipient_address: Address,
    ) -> Self {
        Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            sender_address: Address::default(),
            recipient_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.sender_address.size();
        size += self.recipient_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let sender_address;
        (sender_address, payload) = Address::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let sender_address = self.sender_address.serialize();
        let recipient_address = self.recipient_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            sender_address.iter(),
            recipient_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
//name: NamespaceId
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct NamespaceId(pub u64);
impl NamespaceId {
    pub const SIZE: usize = 8;
    pub fn new(namespaceid: u64) -> Self {
        Self(namespaceid)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Enumeration of namespace registration types.
//name: NamespaceRegistrationType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    ROOT = 0
//        name: ROOT
//        value: 0
//    CHILD = 1
//        name: CHILD
//        value: 1
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum NamespaceRegistrationType {
    ROOT = 0,
    CHILD = 1,
}
impl NamespaceRegistrationType {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::ROOT
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((NamespaceRegistrationType::ROOT, rest)),
            1 => Ok((NamespaceRegistrationType::CHILD, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "NamespaceRegistrationType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Enumeration of alias actions.
//name: AliasAction
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    UNLINK = 0
//        name: UNLINK
//        value: 0
//    LINK = 1
//        name: LINK
//        value: 1
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum AliasAction {
    UNLINK = 0,
    LINK = 1,
}
impl AliasAction {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::UNLINK
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((AliasAction::UNLINK, rest)),
            1 => Ok((AliasAction::LINK, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "AliasAction".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Receipt generated when a [namespace](/concepts/namespace.html) expires.
//name: NamespaceExpiredReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_EXPIRED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: NAMESPACE_EXPIRED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    artifact_id = NamespaceId
//        name: artifact_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NamespaceExpiredReceipt {
    pub version: u16,
    pub artifact_id: NamespaceId,
}
impl NamespaceExpiredReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_EXPIRED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: NamespaceId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: NamespaceId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = NamespaceId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when a [namespace](/concepts/namespace.html) is deleted.
//name: NamespaceDeletedReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_DELETED)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: NAMESPACE_DELETED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    artifact_id = NamespaceId
//        name: artifact_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NamespaceDeletedReceipt {
    pub version: u16,
    pub artifact_id: NamespaceId,
}
impl NamespaceDeletedReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_DELETED;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(version: u16, artifact_id: NamespaceId) -> Self {
        Self {
            version,
            artifact_id,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            artifact_id: NamespaceId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.artifact_id.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let artifact_id;
        (artifact_id, payload) = NamespaceId::deserialize(payload)?;
        let self_ = Self {
            version,
            artifact_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let artifact_id = self.artifact_id.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            artifact_id.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Receipt generated when a namespace rental fee is paid.
//name: NamespaceRentalFeeReceipt
//disposition: None
//fields: <class 'list'>
//    RECEIPT_TYPE = make_const(ReceiptType, NAMESPACE_RENTAL_FEE)
//        name: RECEIPT_TYPE
//        field_type: ReceiptType
//        value: NAMESPACE_RENTAL_FEE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u16
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    type = ReceiptType
//        name: type
//        field_type: ReceiptType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = Mosaic
//        name: mosaic
//        field_type: Mosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    sender_address = Address
//        name: sender_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = Address
//        name: recipient_address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Receipt
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(type, RECEIPT_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            RECEIPT_TYPE
//    @discriminator(type)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type']
//*initializers: [Initializer(target_property_name='type', value='RECEIPT_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NamespaceRentalFeeReceipt {
    pub version: u16,
    pub mosaic: Mosaic,
    pub sender_address: Address,
    pub recipient_address: Address,
}
impl NamespaceRentalFeeReceipt {
    pub const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_RENTAL_FEE;
    pub fn type_(&self) -> ReceiptType {
        Self::RECEIPT_TYPE
    }
    pub fn new(
        version: u16,
        mosaic: Mosaic,
        sender_address: Address,
        recipient_address: Address,
    ) -> Self {
        Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u16::default(),
            mosaic: Mosaic::default(),
            sender_address: Address::default(),
            recipient_address: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 2;
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.sender_address.size();
        size += self.recipient_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let version = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let _type;
        (_type, payload) = ReceiptType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = Mosaic::deserialize(payload)?;
        let sender_address;
        (sender_address, payload) = Address::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            version,
            mosaic,
            sender_address,
            recipient_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let version = self.version.to_le_bytes();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let sender_address = self.sender_address.serialize();
        let recipient_address = self.recipient_address.serialize();
        [
            size.iter(),
            version.iter(),
            type_.iter(),
            mosaic.iter(),
            sender_address.iter(),
            recipient_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///The transaction inside the block that triggered the receipt.
//name: ReceiptSource
//disposition: None
//fields: <class 'list'>
//    primary_id = u32
//        name: primary_id
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    secondary_id = u32
//        name: secondary_id
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct ReceiptSource {
    pub primary_id: u32,
    pub secondary_id: u32,
}
impl ReceiptSource {
    pub fn new(primary_id: u32, secondary_id: u32) -> Self {
        Self {
            primary_id,
            secondary_id,
        }
    }
    pub fn default() -> Self {
        Self {
            primary_id: u32::default(),
            secondary_id: u32::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let primary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let secondary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let self_ = Self {
            primary_id,
            secondary_id,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let primary_id = self.primary_id.to_le_bytes();
        let secondary_id = self.secondary_id.to_le_bytes();
        [primary_id.iter(), secondary_id.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///Actual Address behind a NamespaceId at the time a transaction was confirmed.
//name: AddressResolutionEntry
//disposition: None
//fields: <class 'list'>
//    source = ReceiptSource
//        name: source
//        field_type: ReceiptSource
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    resolved_value = Address
//        name: resolved_value
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AddressResolutionEntry {
    pub source: ReceiptSource,
    pub resolved_value: Address,
}
impl AddressResolutionEntry {
    pub fn new(source: ReceiptSource, resolved_value: Address) -> Self {
        Self {
            source,
            resolved_value,
        }
    }
    pub fn default() -> Self {
        Self {
            source: ReceiptSource::default(),
            resolved_value: Address::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.source.size();
        size += self.resolved_value.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let source;
        (source, payload) = ReceiptSource::deserialize(payload)?;
        let resolved_value;
        (resolved_value, payload) = Address::deserialize(payload)?;
        let self_ = Self {
            source,
            resolved_value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let source = self.source.serialize();
        let resolved_value = self.resolved_value.serialize();
        [source.iter(), resolved_value.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///An Address resolution statement links a namespace alias used in a transaction to the real address **at the time of the transaction**.
//name: AddressResolutionStatement
//disposition: None
//fields: <class 'list'>
//    unresolved = UnresolvedAddress
//        name: unresolved
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    resolution_entries_count = u32
//        name: resolution_entries_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    resolution_entries = array(AddressResolutionEntry, resolution_entries_count)
//        name: resolution_entries
//        field_type: <class 'catparser.ast.Array'>
//            element_type: AddressResolutionEntry
//            size: resolution_entries_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: resolution_entries_count
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AddressResolutionStatement {
    pub unresolved: UnresolvedAddress,
    pub resolution_entries: Vec<AddressResolutionEntry>,
}
impl AddressResolutionStatement {
    pub fn new(
        unresolved: UnresolvedAddress,
        resolution_entries: Vec<AddressResolutionEntry>,
    ) -> Self {
        Self {
            unresolved,
            resolution_entries,
        }
    }
    pub fn default() -> Self {
        Self {
            unresolved: UnresolvedAddress::default(),
            resolution_entries: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.unresolved.size();
        size += 4;
        size += self
            .resolution_entries
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let unresolved;
        (unresolved, payload) = UnresolvedAddress::deserialize(payload)?;
        let resolution_entries_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut resolution_entries = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..resolution_entries_count {
            let element;
            (element, payload) = AddressResolutionEntry::deserialize(payload)?;
            resolution_entries.push(element);
        }
        let self_ = Self {
            unresolved,
            resolution_entries,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let unresolved = self.unresolved.serialize();
        let resolution_entries_count = (self.resolution_entries.len() as u32).to_le_bytes();
        let resolution_entries: Vec<u8> = self
            .resolution_entries
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            unresolved.iter(),
            resolution_entries_count.iter(),
            resolution_entries.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Actual MosaicId behind a NamespaceId at the time a transaction was confirmed.
//name: MosaicResolutionEntry
//disposition: None
//fields: <class 'list'>
//    source = ReceiptSource
//        name: source
//        field_type: ReceiptSource
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    resolved_value = MosaicId
//        name: resolved_value
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicResolutionEntry {
    pub source: ReceiptSource,
    pub resolved_value: MosaicId,
}
impl MosaicResolutionEntry {
    pub fn new(source: ReceiptSource, resolved_value: MosaicId) -> Self {
        Self {
            source,
            resolved_value,
        }
    }
    pub fn default() -> Self {
        Self {
            source: ReceiptSource::default(),
            resolved_value: MosaicId::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.source.size();
        size += self.resolved_value.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let source;
        (source, payload) = ReceiptSource::deserialize(payload)?;
        let resolved_value;
        (resolved_value, payload) = MosaicId::deserialize(payload)?;
        let self_ = Self {
            source,
            resolved_value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let source = self.source.serialize();
        let resolved_value = self.resolved_value.serialize();
        [source.iter(), resolved_value.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
///A Mosaic resolution statement links a namespace alias used in a transaction to the real mosaic id **at the time of the transaction**.
//name: MosaicResolutionStatement
//disposition: None
//fields: <class 'list'>
//    unresolved = UnresolvedMosaicId
//        name: unresolved
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    resolution_entries_count = u32
//        name: resolution_entries_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    resolution_entries = array(MosaicResolutionEntry, resolution_entries_count)
//        name: resolution_entries
//        field_type: <class 'catparser.ast.Array'>
//            element_type: MosaicResolutionEntry
//            size: resolution_entries_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: resolution_entries_count
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicResolutionStatement {
    pub unresolved: UnresolvedMosaicId,
    pub resolution_entries: Vec<MosaicResolutionEntry>,
}
impl MosaicResolutionStatement {
    pub fn new(
        unresolved: UnresolvedMosaicId,
        resolution_entries: Vec<MosaicResolutionEntry>,
    ) -> Self {
        Self {
            unresolved,
            resolution_entries,
        }
    }
    pub fn default() -> Self {
        Self {
            unresolved: UnresolvedMosaicId::default(),
            resolution_entries: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.unresolved.size();
        size += 4;
        size += self
            .resolution_entries
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let unresolved;
        (unresolved, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let resolution_entries_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut resolution_entries = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..resolution_entries_count {
            let element;
            (element, payload) = MosaicResolutionEntry::deserialize(payload)?;
            resolution_entries.push(element);
        }
        let self_ = Self {
            unresolved,
            resolution_entries,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let unresolved = self.unresolved.serialize();
        let resolution_entries_count = (self.resolution_entries.len() as u32).to_le_bytes();
        let resolution_entries: Vec<u8> = self
            .resolution_entries
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            unresolved.iter(),
            resolution_entries_count.iter(),
            resolution_entries.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Collection of receipts scoped to a single source (transaction or block).
//name: TransactionStatement
//disposition: None
//fields: <class 'list'>
//    primary_id = u32
//        name: primary_id
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    secondary_id = u32
//        name: secondary_id
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    receipt_count = u32
//        name: receipt_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    receipts = array(Receipt, receipt_count)
//        name: receipts
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Receipt
//            size: receipt_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: receipt_count
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct TransactionStatement {
    pub primary_id: u32,
    pub secondary_id: u32,
    pub receipts: Vec<Receipt>,
}
impl TransactionStatement {
    pub fn new(primary_id: u32, secondary_id: u32, receipts: Vec<Receipt>) -> Self {
        Self {
            primary_id,
            secondary_id,
            receipts,
        }
    }
    pub fn default() -> Self {
        Self {
            primary_id: u32::default(),
            secondary_id: u32::default(),
            receipts: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += 4;
        size += self.receipts.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let primary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let secondary_id = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let receipt_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut receipts = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..receipt_count {
            let element;
            (element, payload) = Receipt::deserialize(payload)?;
            receipts.push(element);
        }
        let self_ = Self {
            primary_id,
            secondary_id,
            receipts,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let primary_id = self.primary_id.to_le_bytes();
        let secondary_id = self.secondary_id.to_le_bytes();
        let receipt_count = (self.receipts.len() as u32).to_le_bytes();
        let receipts: Vec<u8> = self.receipts.iter().flat_map(|x| x.serialize()).collect();
        [
            primary_id.iter(),
            secondary_id.iter(),
            receipt_count.iter(),
            receipts.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///Collection of statements scoped to a block.
//name: BlockStatement
//disposition: None
//fields: <class 'list'>
//    transaction_statement_count = u32
//        name: transaction_statement_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    transaction_statements = array(TransactionStatement, transaction_statement_count)
//        name: transaction_statements
//        field_type: <class 'catparser.ast.Array'>
//            element_type: TransactionStatement
//            size: transaction_statement_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: transaction_statement_count
//    address_resolution_statement_count = u32
//        name: address_resolution_statement_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    address_resolution_statements = array(AddressResolutionStatement, address_resolution_statement_count)
//        name: address_resolution_statements
//        field_type: <class 'catparser.ast.Array'>
//            element_type: AddressResolutionStatement
//            size: address_resolution_statement_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: address_resolution_statement_count
//    mosaic_resolution_statement_count = u32
//        name: mosaic_resolution_statement_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    mosaic_resolution_statements = array(MosaicResolutionStatement, mosaic_resolution_statement_count)
//        name: mosaic_resolution_statements
//        field_type: <class 'catparser.ast.Array'>
//            element_type: MosaicResolutionStatement
//            size: mosaic_resolution_statement_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: mosaic_resolution_statement_count
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: None
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: None
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct BlockStatement {
    pub transaction_statements: Vec<TransactionStatement>,
    pub address_resolution_statements: Vec<AddressResolutionStatement>,
    pub mosaic_resolution_statements: Vec<MosaicResolutionStatement>,
}
impl BlockStatement {
    pub fn new(
        transaction_statements: Vec<TransactionStatement>,
        address_resolution_statements: Vec<AddressResolutionStatement>,
        mosaic_resolution_statements: Vec<MosaicResolutionStatement>,
    ) -> Self {
        Self {
            transaction_statements,
            address_resolution_statements,
            mosaic_resolution_statements,
        }
    }
    pub fn default() -> Self {
        Self {
            transaction_statements: Vec::new(),
            address_resolution_statements: Vec::new(),
            mosaic_resolution_statements: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += self
            .transaction_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += 4;
        size += self
            .address_resolution_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += 4;
        size += self
            .mosaic_resolution_statements
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let transaction_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut transaction_statements = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..transaction_statement_count {
            let element;
            (element, payload) = TransactionStatement::deserialize(payload)?;
            transaction_statements.push(element);
        }
        let address_resolution_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut address_resolution_statements = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..address_resolution_statement_count {
            let element;
            (element, payload) = AddressResolutionStatement::deserialize(payload)?;
            address_resolution_statements.push(element);
        }
        let mosaic_resolution_statement_count = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let mut mosaic_resolution_statements = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..mosaic_resolution_statement_count {
            let element;
            (element, payload) = MosaicResolutionStatement::deserialize(payload)?;
            mosaic_resolution_statements.push(element);
        }
        let self_ = Self {
            transaction_statements,
            address_resolution_statements,
            mosaic_resolution_statements,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let transaction_statement_count = (self.transaction_statements.len() as u32).to_le_bytes();
        let transaction_statements: Vec<u8> = self
            .transaction_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_resolution_statement_count =
            (self.address_resolution_statements.len() as u32).to_le_bytes();
        let address_resolution_statements: Vec<u8> = self
            .address_resolution_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let mosaic_resolution_statement_count =
            (self.mosaic_resolution_statements.len() as u32).to_le_bytes();
        let mosaic_resolution_statements: Vec<u8> = self
            .mosaic_resolution_statements
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            transaction_statement_count.iter(),
            transaction_statements.iter(),
            address_resolution_statement_count.iter(),
            address_resolution_statements.iter(),
            mosaic_resolution_statement_count.iter(),
            mosaic_resolution_statements.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
///This transaction is required for all accounts wanting to activate remote or delegated harvesting (V1, latest).
///Announce an AccountKeyLinkTransaction to delegate the account importance score to a proxy account.
//name: AccountKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AccountKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl AccountKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AccountKeyLinkTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AccountKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AccountKeyLinkTransaction (V1, latest).
//name: EmbeddedAccountKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAccountKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedAccountKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAccountKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///This transaction is required for all accounts willing to activate delegated harvesting (V1, latest).
///Announce a NodeKeyLinkTransaction to link an account with a public key used by TLS to create sessions.
//name: NodeKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NODE_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NODE_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NodeKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl NodeKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for NodeKeyLinkTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for NodeKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of NodeKeyLinkTransaction (V1, latest).
//name: EmbeddedNodeKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NODE_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NODE_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedNodeKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedNodeKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedNodeKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Cosignature attached to an AggregateCompleteTransaction or AggregateBondedTransaction.
//name: Cosignature
//disposition: None
//fields: <class 'list'>
//    version = u64
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct Cosignature {
    pub version: u64,
    pub signer_public_key: PublicKey,
    pub signature: Signature,
}
impl Cosignature {
    pub fn new(version: u64, signer_public_key: PublicKey) -> Self {
        Self {
            version,
            signer_public_key,
            signature: Signature::default(),
        }
    }
    pub fn default() -> Self {
        Self {
            version: u64::default(),
            signer_public_key: PublicKey::default(),
            signature: Signature::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 8;
        size += self.signer_public_key.size();
        size += self.signature.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let version = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let self_ = Self {
            version,
            signer_public_key,
            signature,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let version = self.version.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let signature = self.signature.serialize();
        [version.iter(), signer_public_key.iter(), signature.iter()]
            .into_iter()
            .flat_map(|a| a)
            .map(|x| *x)
            .collect()
    }
}
impl TraitSignerPublicKey for Cosignature {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

impl TraitSignature for Cosignature {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

///Cosignature detached from an AggregateCompleteTransaction or AggregateBondedTransaction.
//name: DetachedCosignature
//disposition: None
//fields: <class 'list'>
//    version = u64
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    parent_hash = Hash256
//        name: parent_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: None
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: None
//*initializers: []
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: None
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct DetachedCosignature {
    pub version: u64,
    pub signer_public_key: PublicKey,
    pub signature: Signature,
    pub parent_hash: Hash256,
}
impl DetachedCosignature {
    pub fn new(version: u64, signer_public_key: PublicKey, parent_hash: Hash256) -> Self {
        Self {
            version,
            signer_public_key,
            signature: Signature::default(),
            parent_hash,
        }
    }
    pub fn default() -> Self {
        Self {
            version: u64::default(),
            signer_public_key: PublicKey::default(),
            signature: Signature::default(),
            parent_hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 8;
        size += self.signer_public_key.size();
        size += self.signature.size();
        size += self.parent_hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        let version = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let parent_hash;
        (parent_hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            version,
            signer_public_key,
            signature,
            parent_hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let version = self.version.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let signature = self.signature.serialize();
        let parent_hash = self.parent_hash.serialize();
        [
            version.iter(),
            signer_public_key.iter(),
            signature.iter(),
            parent_hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for DetachedCosignature {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

impl TraitSignature for DetachedCosignature {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

///Send transactions in batches to different accounts (V1, deprecated).
///Use this transaction when all required signatures are available when the transaction is created.
//name: AggregateCompleteTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_COMPLETE)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: AGGREGATE_COMPLETE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    payload_size = u32
//        name: payload_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    aggregate_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: aggregate_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: EmbeddedTransaction
//            size: payload_size
//            *alignment: 8
//            *disposition: array sized
//            *is_byte_constrained: True
//            *is_expandable: False
//            *is_last_element_padded: True
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @is_byte_constrained
//                name: is_byte_constrained
//                is_flag: True
//                value: True
//                values: <class 'list'>
//            @alignment(8, None, None)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    None
//                    None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: payload_size
//    cosignatures = array(Cosignature, __FILL__)
//        name: cosignatures
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Cosignature
//            size: 0
//            *alignment: None
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AggregateCompleteTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += (self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7;
        size += self.cosignatures.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while tmp_payload_len - payload.len() < payload_size as usize {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let mut cosignatures = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = (((self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7)
            as u32)
            .to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let mut transactions = Vec::new();
        for x in &self.transactions {
            transactions.extend_from_slice(&x.serialize());
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AggregateCompleteTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AggregateCompleteTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Send transactions in batches to different accounts (V2, latest).
///Use this transaction when all required signatures are available when the transaction is created.
//name: AggregateCompleteTransactionV2
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 2)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 2
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_COMPLETE)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: AGGREGATE_COMPLETE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    payload_size = u32
//        name: payload_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    aggregate_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: aggregate_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: EmbeddedTransaction
//            size: payload_size
//            *alignment: 8
//            *disposition: array sized
//            *is_byte_constrained: True
//            *is_expandable: False
//            *is_last_element_padded: True
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @is_byte_constrained
//                name: is_byte_constrained
//                is_flag: True
//                value: True
//                values: <class 'list'>
//            @alignment(8, None, None)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    None
//                    None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: payload_size
//    cosignatures = array(Cosignature, __FILL__)
//        name: cosignatures
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Cosignature
//            size: 0
//            *alignment: None
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AggregateCompleteTransactionV2 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV2 {
    pub const TRANSACTION_VERSION: u8 = 2;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += (self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7;
        size += self.cosignatures.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while tmp_payload_len - payload.len() < payload_size as usize {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let mut cosignatures = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = (((self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7)
            as u32)
            .to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let mut transactions = Vec::new();
        for x in &self.transactions {
            transactions.extend_from_slice(&x.serialize());
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AggregateCompleteTransactionV2 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AggregateCompleteTransactionV2 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Propose an arrangement of transactions between different accounts (V1, deprecated).
///Use this transaction when not all required signatures are available when the transaction is created.
///Missing signatures must be provided using a Cosignature or DetachedCosignature.
///To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.
//name: AggregateBondedTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_BONDED)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: AGGREGATE_BONDED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    payload_size = u32
//        name: payload_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    aggregate_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: aggregate_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: EmbeddedTransaction
//            size: payload_size
//            *alignment: 8
//            *disposition: array sized
//            *is_byte_constrained: True
//            *is_expandable: False
//            *is_last_element_padded: True
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @is_byte_constrained
//                name: is_byte_constrained
//                is_flag: True
//                value: True
//                values: <class 'list'>
//            @alignment(8, None, None)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    None
//                    None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: payload_size
//    cosignatures = array(Cosignature, __FILL__)
//        name: cosignatures
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Cosignature
//            size: 0
//            *alignment: None
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AggregateBondedTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += (self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7;
        size += self.cosignatures.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while tmp_payload_len - payload.len() < payload_size as usize {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let mut cosignatures = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = (((self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7)
            as u32)
            .to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let mut transactions = Vec::new();
        for x in &self.transactions {
            transactions.extend_from_slice(&x.serialize());
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AggregateBondedTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AggregateBondedTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Propose an arrangement of transactions between different accounts (V2, latest).
///Use this transaction when not all required signatures are available when the transaction is created.
///Missing signatures must be provided using a Cosignature or DetachedCosignature.
///To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.
//name: AggregateBondedTransactionV2
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 2)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 2
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, AGGREGATE_BONDED)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: AGGREGATE_BONDED
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    transactions_hash = Hash256
//        name: transactions_hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    payload_size = u32
//        name: payload_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    aggregate_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: aggregate_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @is_byte_constrained @alignment(8, None, None) transactions = array(EmbeddedTransaction, payload_size)
//        name: transactions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: EmbeddedTransaction
//            size: payload_size
//            *alignment: 8
//            *disposition: array sized
//            *is_byte_constrained: True
//            *is_expandable: False
//            *is_last_element_padded: True
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @is_byte_constrained
//                name: is_byte_constrained
//                is_flag: True
//                value: True
//                values: <class 'list'>
//            @alignment(8, None, None)
//                name: alignment
//                is_flag: False
//                value: 8
//                values: <class 'list'>
//                    8
//                    None
//                    None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: payload_size
//    cosignatures = array(Cosignature, __FILL__)
//        name: cosignatures
//        field_type: <class 'catparser.ast.Array'>
//            element_type: Cosignature
//            size: 0
//            *alignment: None
//            *disposition: array fill
//            *is_byte_constrained: False
//            *is_expandable: True
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: 0
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AggregateBondedTransactionV2 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub transactions_hash: Hash256,
    pub transactions: Vec<EmbeddedTransaction>,
    pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV2 {
    pub const TRANSACTION_VERSION: u8 = 2;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        transactions_hash: Hash256,
        transactions: Vec<EmbeddedTransaction>,
        cosignatures: Vec<Cosignature>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            transactions_hash: Hash256::default(),
            transactions: Vec::new(),
            cosignatures: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.transactions_hash.size();
        size += 4;
        size += 4;
        size += (self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7;
        size += self.cosignatures.iter().map(|x| x.size()).sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let transactions_hash;
        (transactions_hash, payload) = Hash256::deserialize(payload)?;
        let payload_size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        let aggregate_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if aggregate_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                aggregate_transaction_header_reserved_1 as u32,
            ));
        }
        let mut transactions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while tmp_payload_len - payload.len() < payload_size as usize {
            let element;
            (element, payload) = EmbeddedTransaction::deserialize(payload)?;
            transactions.push(element);
            payload = &payload[((8 - (tmp_payload_len - payload.len()) % 8) % 8)..];
        }
        let mut cosignatures = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        while initial_payload_len - payload.len() < size as usize {
            let element;
            (element, payload) = Cosignature::deserialize(payload)?;
            cosignatures.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            transactions_hash,
            transactions,
            cosignatures,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let transactions_hash = self.transactions_hash.serialize();
        let payload_size = (((self.transactions.iter().map(|x| x.size()).sum::<usize>() + 7) & !7)
            as u32)
            .to_le_bytes();
        let aggregate_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let mut transactions = Vec::new();
        for x in &self.transactions {
            transactions.extend_from_slice(&x.serialize());
            let len = transactions.len();
            transactions.resize((len + 7) & !7, 0);
        }
        let cosignatures: Vec<u8> = self
            .cosignatures
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            transactions_hash.iter(),
            payload_size.iter(),
            aggregate_transaction_header_reserved_1.iter(),
            transactions.iter(),
            cosignatures.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AggregateBondedTransactionV2 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AggregateBondedTransactionV2 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Link an account with a public key required for finalization voting (V1, latest).
///This transaction is required for node operators wanting to vote for [finalization](/concepts/block.html#finalization).
///Announce a VotingKeyLinkTransaction to associate a voting key with an account during a fixed period. An account can be linked to up to **3** different voting keys at the same time.
///The recommended production setting is to always have at least **2** linked keys with different ``endPoint`` values to ensure a key is registered after the first one expires.
///See more details in [the manual node setup guide](/guides/network/running-a-symbol-node-manually.html#manual-voting-key-renewal).
//name: VotingKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, VOTING_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: VOTING_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = VotingPublicKey
//        name: linked_public_key
//        field_type: VotingPublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    start_epoch = FinalizationEpoch
//        name: start_epoch
//        field_type: FinalizationEpoch
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    end_epoch = FinalizationEpoch
//        name: end_epoch
//        field_type: FinalizationEpoch
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct VotingKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: VotingPublicKey,
    pub start_epoch: FinalizationEpoch,
    pub end_epoch: FinalizationEpoch,
    pub link_action: LinkAction,
}
impl VotingKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: VotingPublicKey,
        start_epoch: FinalizationEpoch,
        end_epoch: FinalizationEpoch,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: VotingPublicKey::default(),
            start_epoch: FinalizationEpoch::default(),
            end_epoch: FinalizationEpoch::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.start_epoch.size();
        size += self.end_epoch.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = VotingPublicKey::deserialize(payload)?;
        let start_epoch;
        (start_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let end_epoch;
        (end_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let start_epoch = self.start_epoch.serialize();
        let end_epoch = self.end_epoch.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            start_epoch.iter(),
            end_epoch.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for VotingKeyLinkTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for VotingKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of VotingKeyLinkTransaction (V1, latest).
//name: EmbeddedVotingKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, VOTING_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: VOTING_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = VotingPublicKey
//        name: linked_public_key
//        field_type: VotingPublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    start_epoch = FinalizationEpoch
//        name: start_epoch
//        field_type: FinalizationEpoch
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    end_epoch = FinalizationEpoch
//        name: end_epoch
//        field_type: FinalizationEpoch
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedVotingKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: VotingPublicKey,
    pub start_epoch: FinalizationEpoch,
    pub end_epoch: FinalizationEpoch,
    pub link_action: LinkAction,
}
impl EmbeddedVotingKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: VotingPublicKey,
        start_epoch: FinalizationEpoch,
        end_epoch: FinalizationEpoch,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: VotingPublicKey::default(),
            start_epoch: FinalizationEpoch::default(),
            end_epoch: FinalizationEpoch::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.start_epoch.size();
        size += self.end_epoch.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = VotingPublicKey::deserialize(payload)?;
        let start_epoch;
        (start_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let end_epoch;
        (end_epoch, payload) = FinalizationEpoch::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            start_epoch,
            end_epoch,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let start_epoch = self.start_epoch.serialize();
        let end_epoch = self.end_epoch.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            start_epoch.iter(),
            end_epoch.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedVotingKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Link an account with a VRF public key required for harvesting (V1, latest).
///Announce a VrfKeyLinkTransaction to link an account with a VRF public key. The linked key is used to randomize block production and leader/participant selection.
///This transaction is required for all accounts wishing to [harvest](/concepts/harvesting.html).
//name: VrfKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, VRF_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: VRF_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct VrfKeyLinkTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl VrfKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for VrfKeyLinkTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for VrfKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of VrfKeyLinkTransaction (V1, latest).
//name: EmbeddedVrfKeyLinkTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, VRF_KEY_LINK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: VRF_KEY_LINK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    linked_public_key = PublicKey
//        name: linked_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    link_action = LinkAction
//        name: link_action
//        field_type: LinkAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedVrfKeyLinkTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub linked_public_key: PublicKey,
    pub link_action: LinkAction,
}
impl EmbeddedVrfKeyLinkTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        linked_public_key: PublicKey,
        link_action: LinkAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            linked_public_key: PublicKey::default(),
            link_action: LinkAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.linked_public_key.size();
        size += self.link_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let linked_public_key;
        (linked_public_key, payload) = PublicKey::deserialize(payload)?;
        let link_action;
        (link_action, payload) = LinkAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            linked_public_key,
            link_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let linked_public_key = self.linked_public_key.serialize();
        let link_action = self.link_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            linked_public_key.iter(),
            link_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedVrfKeyLinkTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Lock a deposit needed to announce an AggregateBondedTransaction (V1, latest).
///An AggregateBondedTransaction consumes network resources as it is stored in every node's partial cache while it waits to be fully signed. To avoid spam attacks a HashLockTransaction must be announced and confirmed before an AggregateBondedTransaction can be announced. The HashLockTransaction locks a certain amount of funds (**10** XYM by default) until the aggregate is signed.
///Upon completion of the aggregate, the locked funds become available again to the account that signed the HashLockTransaction.
///If the lock expires before the aggregate is signed by all cosignatories (**48h by default), the locked funds become a reward collected by the block harvester at the height where the lock expires.
///\note It is not necessary to sign the aggregate and its HashLockTransaction with the same account. For example, if Bob wants to announce an aggregate and does not have enough funds to announce a HashLockTransaction, he can ask Alice to announce the lock transaction for him by sharing the signed AggregateTransaction hash.
//name: HashLockTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, HASH_LOCK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: HASH_LOCK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    hash = Hash256
//        name: hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct HashLockTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash: Hash256,
}
impl HashLockTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash: Hash256,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic,
            duration,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic,
            duration,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash = self.hash.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic.iter(),
            duration.iter(),
            hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for HashLockTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for HashLockTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of HashLockTransaction.
//name: EmbeddedHashLockTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, HASH_LOCK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: HASH_LOCK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    hash = Hash256
//        name: hash
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedHashLockTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash: Hash256,
}
impl EmbeddedHashLockTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash: Hash256,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic,
            duration,
            hash,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash: Hash256::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash;
        (hash, payload) = Hash256::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic,
            duration,
            hash,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash = self.hash.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic.iter(),
            duration.iter(),
            hash.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedHashLockTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Enumeration of lock hash algorithms.
//name: LockHashAlgorithm
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    SHA3_256 = 0
//        name: SHA3_256
//        value: 0
//    HASH_160 = 1
//        name: HASH_160
//        value: 1
//    HASH_256 = 2
//        name: HASH_256
//        value: 2
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum LockHashAlgorithm {
    SHA3_256 = 0,
    HASH_160 = 1,
    HASH_256 = 2,
}
impl LockHashAlgorithm {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::SHA3_256
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((LockHashAlgorithm::SHA3_256, rest)),
            1 => Ok((LockHashAlgorithm::HASH_160, rest)),
            2 => Ok((LockHashAlgorithm::HASH_256, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "LockHashAlgorithm".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Start a token swap between different chains (V1, latest).
///Use a SecretLockTransaction to transfer mosaics between two accounts. The mosaics sent remain locked until a valid SecretProofTransaction unlocks them.
///The default expiration date is **365 days** after announcement (See the `maxSecretLockDuration` network property). If the lock expires before a valid SecretProofTransaction is announced the locked amount goes back to the initiator of the SecretLockTransaction.
//name: SecretLockTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, SECRET_LOCK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: SECRET_LOCK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    secret = Hash256
//        name: secret
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    hash_algorithm = LockHashAlgorithm
//        name: hash_algorithm
//        field_type: LockHashAlgorithm
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct SecretLockTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash_algorithm: LockHashAlgorithm,
}
impl SecretLockTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash_algorithm: LockHashAlgorithm,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash_algorithm: LockHashAlgorithm::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash_algorithm.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash_algorithm = self.hash_algorithm.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            secret.iter(),
            mosaic.iter(),
            duration.iter(),
            hash_algorithm.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for SecretLockTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for SecretLockTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of SecretLockTransaction (V1, latest).
//name: EmbeddedSecretLockTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, SECRET_LOCK)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: SECRET_LOCK
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    secret = Hash256
//        name: secret
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    hash_algorithm = LockHashAlgorithm
//        name: hash_algorithm
//        field_type: LockHashAlgorithm
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedSecretLockTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub mosaic: UnresolvedMosaic,
    pub duration: BlockDuration,
    pub hash_algorithm: LockHashAlgorithm,
}
impl EmbeddedSecretLockTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        mosaic: UnresolvedMosaic,
        duration: BlockDuration,
        hash_algorithm: LockHashAlgorithm,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            mosaic: UnresolvedMosaic::default(),
            duration: BlockDuration::default(),
            hash_algorithm: LockHashAlgorithm::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += self.mosaic.size();
        size += self.duration.size();
        size += self.hash_algorithm.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            mosaic,
            duration,
            hash_algorithm,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let mosaic = self.mosaic.serialize();
        let duration = self.duration.serialize();
        let hash_algorithm = self.hash_algorithm.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            secret.iter(),
            mosaic.iter(),
            duration.iter(),
            hash_algorithm.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedSecretLockTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Conclude a token swap between different chains (V1, latest).
///Use a SecretProofTransaction to unlock the funds locked by a SecretLockTransaction.
///The transaction must prove knowing the *proof* that unlocks the mosaics.
//name: SecretProofTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, SECRET_PROOF)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: SECRET_PROOF
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    secret = Hash256
//        name: secret
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    proof_size = u16
//        name: proof_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    hash_algorithm = LockHashAlgorithm
//        name: hash_algorithm
//        field_type: LockHashAlgorithm
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    proof = array(u8, proof_size)
//        name: proof
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: proof_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: proof_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct SecretProofTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub hash_algorithm: LockHashAlgorithm,
    pub proof: Vec<u8>,
}
impl SecretProofTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        hash_algorithm: LockHashAlgorithm,
        proof: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            hash_algorithm: LockHashAlgorithm::default(),
            proof: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += 2;
        size += self.hash_algorithm.size();
        size += 1 * self.proof.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let proof_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let mut proof = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..proof_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            proof.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let proof_size = (self.proof.len() as u16).to_le_bytes();
        let hash_algorithm = self.hash_algorithm.serialize();
        let proof: Vec<u8> = self.proof.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            secret.iter(),
            proof_size.iter(),
            hash_algorithm.iter(),
            proof.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for SecretProofTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for SecretProofTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of SecretProofTransaction (V1, latest).
//name: EmbeddedSecretProofTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, SECRET_PROOF)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: SECRET_PROOF
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    secret = Hash256
//        name: secret
//        field_type: Hash256
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    proof_size = u16
//        name: proof_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    hash_algorithm = LockHashAlgorithm
//        name: hash_algorithm
//        field_type: LockHashAlgorithm
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    proof = array(u8, proof_size)
//        name: proof
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: proof_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: proof_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedSecretProofTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub secret: Hash256,
    pub hash_algorithm: LockHashAlgorithm,
    pub proof: Vec<u8>,
}
impl EmbeddedSecretProofTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        secret: Hash256,
        hash_algorithm: LockHashAlgorithm,
        proof: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            secret: Hash256::default(),
            hash_algorithm: LockHashAlgorithm::default(),
            proof: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += self.secret.size();
        size += 2;
        size += self.hash_algorithm.size();
        size += 1 * self.proof.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let secret;
        (secret, payload) = Hash256::deserialize(payload)?;
        let proof_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let hash_algorithm;
        (hash_algorithm, payload) = LockHashAlgorithm::deserialize(payload)?;
        let mut proof = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..proof_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            proof.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            secret,
            hash_algorithm,
            proof,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let secret = self.secret.serialize();
        let proof_size = (self.proof.len() as u16).to_le_bytes();
        let hash_algorithm = self.hash_algorithm.serialize();
        let proof: Vec<u8> = self.proof.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            secret.iter(),
            proof_size.iter(),
            hash_algorithm.iter(),
            proof.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedSecretProofTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Associate a key-value state ([metadata](/concepts/metadata.html)) to an **account** (V1, latest).
///\note This transaction must **always** be wrapped in an AggregateTransaction so that a cosignature from `target_address` can be provided. Without this cosignature the transaction is invalid.
///Compare to MosaicMetadataTransaction and NamespaceMetadataTransaction.
//name: AccountMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AccountMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl AccountMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AccountMetadataTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AccountMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AccountMetadataTransaction (V1, latest).
//name: EmbeddedAccountMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAccountMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedAccountMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAccountMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Associate a key-value state ([metadata](/concepts/metadata.html)) to a **mosaic** (V1, latest).
///Compare to AccountMetadataTransaction and NamespaceMetadataTransaction.
//name: MosaicMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_mosaic_id = UnresolvedMosaicId
//        name: target_mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_mosaic_id: UnresolvedMosaicId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl MosaicMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_mosaic_id: UnresolvedMosaicId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_mosaic_id: UnresolvedMosaicId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += self.target_mosaic_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_mosaic_id;
        (target_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_mosaic_id = self.target_mosaic_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_mosaic_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicMetadataTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicMetadataTransaction (V1, latest).
//name: EmbeddedMosaicMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_mosaic_id = UnresolvedMosaicId
//        name: target_mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_mosaic_id: UnresolvedMosaicId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedMosaicMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_mosaic_id: UnresolvedMosaicId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_mosaic_id: UnresolvedMosaicId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += self.target_mosaic_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_mosaic_id;
        (target_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_mosaic_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_mosaic_id = self.target_mosaic_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_mosaic_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Associate a key-value state ([metadata](/concepts/metadata.html)) to a **namespace** (V1, latest).
///Compare to AccountMetadataTransaction and MosaicMetadataTransaction.
//name: NamespaceMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NAMESPACE_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_namespace_id = NamespaceId
//        name: target_namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NamespaceMetadataTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_namespace_id: NamespaceId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl NamespaceMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_namespace_id: NamespaceId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_namespace_id: NamespaceId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.target_address.size();
        size += 8;
        size += self.target_namespace_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_namespace_id;
        (target_namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_namespace_id = self.target_namespace_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_namespace_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for NamespaceMetadataTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for NamespaceMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of NamespaceMetadataTransaction (V1, latest).
//name: EmbeddedNamespaceMetadataTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_METADATA)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NAMESPACE_METADATA
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    scoped_metadata_key = u64
//        name: scoped_metadata_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_namespace_id = NamespaceId
//        name: target_namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    value_size_delta = i16
//        name: value_size_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i16
//            is_unsigned: False
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: i16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 2
//    value_size = u16
//        name: value_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    value = array(u8, value_size)
//        name: value
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: value_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: value_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedNamespaceMetadataTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub target_address: UnresolvedAddress,
    pub scoped_metadata_key: u64,
    pub target_namespace_id: NamespaceId,
    pub value_size_delta: i16,
    pub value: Vec<u8>,
}
impl EmbeddedNamespaceMetadataTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        target_address: UnresolvedAddress,
        scoped_metadata_key: u64,
        target_namespace_id: NamespaceId,
        value_size_delta: i16,
        value: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            target_address: UnresolvedAddress::default(),
            scoped_metadata_key: u64::default(),
            target_namespace_id: NamespaceId::default(),
            value_size_delta: i16::default(),
            value: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.target_address.size();
        size += 8;
        size += self.target_namespace_id.size();
        size += 2;
        size += 2;
        size += 1 * self.value.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let scoped_metadata_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_namespace_id;
        (target_namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let value_size_delta = i16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let value_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mut value = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..value_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            value.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            target_address,
            scoped_metadata_key,
            target_namespace_id,
            value_size_delta,
            value,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let target_address = self.target_address.serialize();
        let scoped_metadata_key = self.scoped_metadata_key.to_le_bytes();
        let target_namespace_id = self.target_namespace_id.serialize();
        let value_size_delta = self.value_size_delta.to_le_bytes();
        let value_size = (self.value.len() as u16).to_le_bytes();
        let value: Vec<u8> = self.value.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            target_address.iter(),
            scoped_metadata_key.iter(),
            target_namespace_id.iter(),
            value_size_delta.iter(),
            value_size.iter(),
            value.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedNamespaceMetadataTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

//name: MosaicNonce
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint32
//    is_unsigned: True
//    size: 4
//    display_type: DisplayType.INTEGER
//    *name: uint32
//    *sizeref: None
//*is_unsigned: True
//*size: 4
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct MosaicNonce(pub u32);
impl MosaicNonce {
    pub const SIZE: usize = 4;
    pub fn new(mosaicnonce: u32) -> Self {
        Self(mosaicnonce)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u32::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Enumeration of mosaic property flags.
//name: MosaicFlags
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    NONE = 0
//        name: NONE
//        value: 0
//    SUPPLY_MUTABLE = 1
//        name: SUPPLY_MUTABLE
//        value: 1
//    TRANSFERABLE = 2
//        name: TRANSFERABLE
//        value: 2
//    RESTRICTABLE = 4
//        name: RESTRICTABLE
//        value: 4
//    REVOKABLE = 8
//        name: REVOKABLE
//        value: 8
//display_type: DisplayType.ENUM
//attributes: <class 'list'>
//    @is_bitwise
//        name: is_bitwise
//        is_flag: True
//        value: True
//        values: <class 'list'>
//*is_bitwise: True
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum MosaicFlags {
    NONE = 0,
    SUPPLY_MUTABLE = 1,
    TRANSFERABLE = 2,
    RESTRICTABLE = 4,
    REVOKABLE = 8,
    X(u8),
}
impl MosaicFlags {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::NONE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn to_num(&self) -> u8 {
        match self {
            Self::NONE => 0,
            Self::SUPPLY_MUTABLE => 1,
            Self::TRANSFERABLE => 2,
            Self::RESTRICTABLE => 4,
            Self::REVOKABLE => 8,
            Self::X(x) => *x,
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicFlags::NONE, rest)),
            1 => Ok((MosaicFlags::SUPPLY_MUTABLE, rest)),
            2 => Ok((MosaicFlags::TRANSFERABLE, rest)),
            4 => Ok((MosaicFlags::RESTRICTABLE, rest)),
            8 => Ok((MosaicFlags::REVOKABLE, rest)),
            x if (!0 & !1 & !2 & !4 & !8 & x) == 0 => Ok((Self::X(x), rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "MosaicFlags".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::NONE => 0u8.to_le_bytes().to_vec(),
            Self::SUPPLY_MUTABLE => 1u8.to_le_bytes().to_vec(),
            Self::TRANSFERABLE => 2u8.to_le_bytes().to_vec(),
            Self::RESTRICTABLE => 4u8.to_le_bytes().to_vec(),
            Self::REVOKABLE => 8u8.to_le_bytes().to_vec(),
            Self::X(x) => x.to_le_bytes().to_vec(),
        }
    }
}
impl BitOr for MosaicFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() | rhs.to_num())
    }
}
impl BitOrAssign for MosaicFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        *self = *self | rhs;
    }
}
impl BitAnd for MosaicFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() & rhs.to_num())
    }
}
impl BitAndAssign for MosaicFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        *self = *self & rhs;
    }
}
impl BitXor for MosaicFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() ^ rhs.to_num())
    }
}
impl BitXorAssign for MosaicFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = *self ^ rhs;
    }
}
impl Not for MosaicFlags {
    type Output = Self;
    fn not(self) -> Self::Output {
        Self::X(!self.to_num())
    }
}

///Enumeration of mosaic supply change actions.
//name: MosaicSupplyChangeAction
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    DECREASE = 0
//        name: DECREASE
//        value: 0
//    INCREASE = 1
//        name: INCREASE
//        value: 1
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum MosaicSupplyChangeAction {
    DECREASE = 0,
    INCREASE = 1,
}
impl MosaicSupplyChangeAction {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::DECREASE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicSupplyChangeAction::DECREASE, rest)),
            1 => Ok((MosaicSupplyChangeAction::INCREASE, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "MosaicSupplyChangeAction".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Create a new  [mosaic](/concepts/mosaic.html) (V1, latest).
//name: MosaicDefinitionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_DEFINITION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_DEFINITION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    id = MosaicId
//        name: id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    nonce = MosaicNonce
//        name: nonce
//        field_type: MosaicNonce
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    flags = MosaicFlags
//        name: flags
//        field_type: MosaicFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    divisibility = u8
//        name: divisibility
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicDefinitionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub id: MosaicId,
    pub duration: BlockDuration,
    pub nonce: MosaicNonce,
    pub flags: MosaicFlags,
    pub divisibility: u8,
}
impl MosaicDefinitionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        id: MosaicId,
        duration: BlockDuration,
        nonce: MosaicNonce,
        flags: MosaicFlags,
        divisibility: u8,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            id: MosaicId::default(),
            duration: BlockDuration::default(),
            nonce: MosaicNonce::default(),
            flags: MosaicFlags::default(),
            divisibility: u8::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.id.size();
        size += self.duration.size();
        size += self.nonce.size();
        size += self.flags.size();
        size += 1;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let id;
        (id, payload) = MosaicId::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let nonce;
        (nonce, payload) = MosaicNonce::deserialize(payload)?;
        let flags;
        (flags, payload) = MosaicFlags::deserialize(payload)?;
        let divisibility = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let id = self.id.serialize();
        let duration = self.duration.serialize();
        let nonce = self.nonce.serialize();
        let flags = self.flags.serialize();
        let divisibility = self.divisibility.to_le_bytes();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            id.iter(),
            duration.iter(),
            nonce.iter(),
            flags.iter(),
            divisibility.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicDefinitionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicDefinitionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicDefinitionTransaction (V1, latest).
//name: EmbeddedMosaicDefinitionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_DEFINITION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_DEFINITION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    id = MosaicId
//        name: id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration
//        name: duration
//        field_type: BlockDuration
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    nonce = MosaicNonce
//        name: nonce
//        field_type: MosaicNonce
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    flags = MosaicFlags
//        name: flags
//        field_type: MosaicFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    divisibility = u8
//        name: divisibility
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicDefinitionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub id: MosaicId,
    pub duration: BlockDuration,
    pub nonce: MosaicNonce,
    pub flags: MosaicFlags,
    pub divisibility: u8,
}
impl EmbeddedMosaicDefinitionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        id: MosaicId,
        duration: BlockDuration,
        nonce: MosaicNonce,
        flags: MosaicFlags,
        divisibility: u8,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            id: MosaicId::default(),
            duration: BlockDuration::default(),
            nonce: MosaicNonce::default(),
            flags: MosaicFlags::default(),
            divisibility: u8::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.id.size();
        size += self.duration.size();
        size += self.nonce.size();
        size += self.flags.size();
        size += 1;
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let id;
        (id, payload) = MosaicId::deserialize(payload)?;
        let duration;
        (duration, payload) = BlockDuration::deserialize(payload)?;
        let nonce;
        (nonce, payload) = MosaicNonce::deserialize(payload)?;
        let flags;
        (flags, payload) = MosaicFlags::deserialize(payload)?;
        let divisibility = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let self_ = Self {
            signer_public_key,
            network,
            id,
            duration,
            nonce,
            flags,
            divisibility,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let id = self.id.serialize();
        let duration = self.duration.serialize();
        let nonce = self.nonce.serialize();
        let flags = self.flags.serialize();
        let divisibility = self.divisibility.to_le_bytes();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            id.iter(),
            duration.iter(),
            nonce.iter(),
            flags.iter(),
            divisibility.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicDefinitionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Change the total supply of a mosaic (V1, latest).
//name: MosaicSupplyChangeTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_CHANGE)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_SUPPLY_CHANGE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    delta = Amount
//        name: delta
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    action = MosaicSupplyChangeAction
//        name: action
//        field_type: MosaicSupplyChangeAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicSupplyChangeTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub delta: Amount,
    pub action: MosaicSupplyChangeAction,
}
impl MosaicSupplyChangeTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        delta: Amount,
        action: MosaicSupplyChangeAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            delta,
            action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            delta: Amount::default(),
            action: MosaicSupplyChangeAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += self.delta.size();
        size += self.action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let delta;
        (delta, payload) = Amount::deserialize(payload)?;
        let action;
        (action, payload) = MosaicSupplyChangeAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            delta,
            action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let delta = self.delta.serialize();
        let action = self.action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            delta.iter(),
            action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicSupplyChangeTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicSupplyChangeTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicSupplyChangeTransaction (V1, latest).
//name: EmbeddedMosaicSupplyChangeTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_CHANGE)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_SUPPLY_CHANGE
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    delta = Amount
//        name: delta
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    action = MosaicSupplyChangeAction
//        name: action
//        field_type: MosaicSupplyChangeAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicSupplyChangeTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub delta: Amount,
    pub action: MosaicSupplyChangeAction,
}
impl EmbeddedMosaicSupplyChangeTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        delta: Amount,
        action: MosaicSupplyChangeAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            delta,
            action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            delta: Amount::default(),
            action: MosaicSupplyChangeAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += self.delta.size();
        size += self.action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let delta;
        (delta, payload) = Amount::deserialize(payload)?;
        let action;
        (action, payload) = MosaicSupplyChangeAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            delta,
            action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let delta = self.delta.serialize();
        let action = self.action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            delta.iter(),
            action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicSupplyChangeTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Revoke mosaic (V1, latest).
//name: MosaicSupplyRevocationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_REVOCATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_SUPPLY_REVOCATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    source_address = UnresolvedAddress
//        name: source_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicSupplyRevocationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub source_address: UnresolvedAddress,
    pub mosaic: UnresolvedMosaic,
}
impl MosaicSupplyRevocationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        source_address: UnresolvedAddress,
        mosaic: UnresolvedMosaic,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            source_address,
            mosaic,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            source_address: UnresolvedAddress::default(),
            mosaic: UnresolvedMosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.source_address.size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let source_address;
        (source_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            source_address,
            mosaic,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let source_address = self.source_address.serialize();
        let mosaic = self.mosaic.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            source_address.iter(),
            mosaic.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicSupplyRevocationTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicSupplyRevocationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicSupplyRevocationTransaction (V1, latest).
//name: EmbeddedMosaicSupplyRevocationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_SUPPLY_REVOCATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_SUPPLY_REVOCATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    source_address = UnresolvedAddress
//        name: source_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic = UnresolvedMosaic
//        name: mosaic
//        field_type: UnresolvedMosaic
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicSupplyRevocationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub source_address: UnresolvedAddress,
    pub mosaic: UnresolvedMosaic,
}
impl EmbeddedMosaicSupplyRevocationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        source_address: UnresolvedAddress,
        mosaic: UnresolvedMosaic,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            source_address,
            mosaic,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            source_address: UnresolvedAddress::default(),
            mosaic: UnresolvedMosaic::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.source_address.size();
        size += self.mosaic.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let source_address;
        (source_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let mosaic;
        (mosaic, payload) = UnresolvedMosaic::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            source_address,
            mosaic,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let source_address = self.source_address.serialize();
        let mosaic = self.mosaic.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            source_address.iter(),
            mosaic.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicSupplyRevocationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Create or modify a [multi-signature](/concepts/multisig-account.html) account (V1, latest).
///This transaction allows you to: - Transform a regular account into a multisig account. - Change the configurable properties of a multisig account. - Add or delete cosignatories from a multisig account (removing all cosignatories turns a multisig account into a regular account again).
//name: MultisigAccountModificationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MULTISIG_ACCOUNT_MODIFICATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MULTISIG_ACCOUNT_MODIFICATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    min_removal_delta = i8
//        name: min_removal_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i8
//            is_unsigned: False
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: i8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 1
//    min_approval_delta = i8
//        name: min_approval_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i8
//            is_unsigned: False
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: i8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 1
//    address_additions_count = u8
//        name: address_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    address_deletions_count = u8
//        name: address_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    multisig_account_modification_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: multisig_account_modification_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    address_additions = array(UnresolvedAddress, address_additions_count)
//        name: address_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: address_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: address_additions_count
//    address_deletions = array(UnresolvedAddress, address_deletions_count)
//        name: address_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: address_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: address_deletions_count
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MultisigAccountModificationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub min_removal_delta: i8,
    pub min_approval_delta: i8,
    pub address_additions: Vec<UnresolvedAddress>,
    pub address_deletions: Vec<UnresolvedAddress>,
}
impl MultisigAccountModificationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        min_removal_delta: i8,
        min_approval_delta: i8,
        address_additions: Vec<UnresolvedAddress>,
        address_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            min_removal_delta: i8::default(),
            min_approval_delta: i8::default(),
            address_additions: Vec::new(),
            address_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        size += 4;
        size += self
            .address_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .address_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let min_removal_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let min_approval_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let multisig_account_modification_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if multisig_account_modification_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                multisig_account_modification_transaction_body_reserved_1 as u32,
            ));
        }
        let mut address_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..address_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_additions.push(element);
        }
        let mut address_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..address_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let min_removal_delta = self.min_removal_delta.to_le_bytes();
        let min_approval_delta = self.min_approval_delta.to_le_bytes();
        let address_additions_count = (self.address_additions.len() as u8).to_le_bytes();
        let address_deletions_count = (self.address_deletions.len() as u8).to_le_bytes();
        let multisig_account_modification_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let address_additions: Vec<u8> = self
            .address_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_deletions: Vec<u8> = self
            .address_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            min_removal_delta.iter(),
            min_approval_delta.iter(),
            address_additions_count.iter(),
            address_deletions_count.iter(),
            multisig_account_modification_transaction_body_reserved_1.iter(),
            address_additions.iter(),
            address_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MultisigAccountModificationTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MultisigAccountModificationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MultisigAccountModificationTransaction (V1, latest).
//name: EmbeddedMultisigAccountModificationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MULTISIG_ACCOUNT_MODIFICATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MULTISIG_ACCOUNT_MODIFICATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    min_removal_delta = i8
//        name: min_removal_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i8
//            is_unsigned: False
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: i8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 1
//    min_approval_delta = i8
//        name: min_approval_delta
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: i8
//            is_unsigned: False
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: i8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: False
//        *size: 1
//    address_additions_count = u8
//        name: address_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    address_deletions_count = u8
//        name: address_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    multisig_account_modification_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: multisig_account_modification_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    address_additions = array(UnresolvedAddress, address_additions_count)
//        name: address_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: address_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: address_additions_count
//    address_deletions = array(UnresolvedAddress, address_deletions_count)
//        name: address_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: address_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: address_deletions_count
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMultisigAccountModificationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub min_removal_delta: i8,
    pub min_approval_delta: i8,
    pub address_additions: Vec<UnresolvedAddress>,
    pub address_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedMultisigAccountModificationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        min_removal_delta: i8,
        min_approval_delta: i8,
        address_additions: Vec<UnresolvedAddress>,
        address_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            min_removal_delta: i8::default(),
            min_approval_delta: i8::default(),
            address_additions: Vec::new(),
            address_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        size += 4;
        size += self
            .address_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .address_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let min_removal_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let min_approval_delta = i8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let address_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let multisig_account_modification_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if multisig_account_modification_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                multisig_account_modification_transaction_body_reserved_1 as u32,
            ));
        }
        let mut address_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..address_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_additions.push(element);
        }
        let mut address_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..address_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            address_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            min_removal_delta,
            min_approval_delta,
            address_additions,
            address_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let min_removal_delta = self.min_removal_delta.to_le_bytes();
        let min_approval_delta = self.min_approval_delta.to_le_bytes();
        let address_additions_count = (self.address_additions.len() as u8).to_le_bytes();
        let address_deletions_count = (self.address_deletions.len() as u8).to_le_bytes();
        let multisig_account_modification_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let address_additions: Vec<u8> = self
            .address_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let address_deletions: Vec<u8> = self
            .address_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            min_removal_delta.iter(),
            min_approval_delta.iter(),
            address_additions_count.iter(),
            address_deletions_count.iter(),
            multisig_account_modification_transaction_body_reserved_1.iter(),
            address_additions.iter(),
            address_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMultisigAccountModificationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Attach or detach a [namespace](/concepts/namespace.html) (alias) to an account address (V1, latest).
///A namespace can be assigned to any account present in the network (this is, an account which has received at least one transaction).
//name: AddressAliasTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ADDRESS_ALIAS)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ADDRESS_ALIAS
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    namespace_id = NamespaceId
//        name: namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    address = Address
//        name: address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    alias_action = AliasAction
//        name: alias_action
//        field_type: AliasAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AddressAliasTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub namespace_id: NamespaceId,
    pub address: Address,
    pub alias_action: AliasAction,
}
impl AddressAliasTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        namespace_id: NamespaceId,
        address: Address,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            address,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            namespace_id: NamespaceId::default(),
            address: Address::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.namespace_id.size();
        size += self.address.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let address;
        (address, payload) = Address::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            address,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let namespace_id = self.namespace_id.serialize();
        let address = self.address.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            namespace_id.iter(),
            address.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AddressAliasTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AddressAliasTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AddressAliasTransaction (V1, latest).
//name: EmbeddedAddressAliasTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ADDRESS_ALIAS)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ADDRESS_ALIAS
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    namespace_id = NamespaceId
//        name: namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    address = Address
//        name: address
//        field_type: Address
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    alias_action = AliasAction
//        name: alias_action
//        field_type: AliasAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAddressAliasTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub namespace_id: NamespaceId,
    pub address: Address,
    pub alias_action: AliasAction,
}
impl EmbeddedAddressAliasTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        namespace_id: NamespaceId,
        address: Address,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            namespace_id,
            address,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            namespace_id: NamespaceId::default(),
            address: Address::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.namespace_id.size();
        size += self.address.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let address;
        (address, payload) = Address::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            namespace_id,
            address,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let namespace_id = self.namespace_id.serialize();
        let address = self.address.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            namespace_id.iter(),
            address.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAddressAliasTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Attach or detach a [namespace](/concepts/namespace.html) to a Mosaic.(V1, latest)
///Setting an alias to a mosaic is only possible if the account announcing this transaction has also created the namespace and the mosaic involved.
//name: MosaicAliasTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ALIAS)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_ALIAS
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    namespace_id = NamespaceId
//        name: namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = MosaicId
//        name: mosaic_id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    alias_action = AliasAction
//        name: alias_action
//        field_type: AliasAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicAliasTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub namespace_id: NamespaceId,
    pub mosaic_id: MosaicId,
    pub alias_action: AliasAction,
}
impl MosaicAliasTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        namespace_id: NamespaceId,
        mosaic_id: MosaicId,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            mosaic_id,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            namespace_id: NamespaceId::default(),
            mosaic_id: MosaicId::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.namespace_id.size();
        size += self.mosaic_id.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            namespace_id,
            mosaic_id,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let namespace_id = self.namespace_id.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            namespace_id.iter(),
            mosaic_id.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicAliasTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicAliasTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicAliasTransaction (V1, latest).
//name: EmbeddedMosaicAliasTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ALIAS)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_ALIAS
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    namespace_id = NamespaceId
//        name: namespace_id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = MosaicId
//        name: mosaic_id
//        field_type: MosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    alias_action = AliasAction
//        name: alias_action
//        field_type: AliasAction
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicAliasTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub namespace_id: NamespaceId,
    pub mosaic_id: MosaicId,
    pub alias_action: AliasAction,
}
impl EmbeddedMosaicAliasTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        namespace_id: NamespaceId,
        mosaic_id: MosaicId,
        alias_action: AliasAction,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            namespace_id,
            mosaic_id,
            alias_action,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            namespace_id: NamespaceId::default(),
            mosaic_id: MosaicId::default(),
            alias_action: AliasAction::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.namespace_id.size();
        size += self.mosaic_id.size();
        size += self.alias_action.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let namespace_id;
        (namespace_id, payload) = NamespaceId::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = MosaicId::deserialize(payload)?;
        let alias_action;
        (alias_action, payload) = AliasAction::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            namespace_id,
            mosaic_id,
            alias_action,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let namespace_id = self.namespace_id.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let alias_action = self.alias_action.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            namespace_id.iter(),
            mosaic_id.iter(),
            alias_action.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicAliasTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Register (or renew a registration for) a [namespace](/concepts/namespace.html) (V1, latest).
///Namespaces help keep assets organized.
//name: NamespaceRegistrationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_REGISTRATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NAMESPACE_REGISTRATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration if ROOT equals registration_type
//        name: duration
//        field_type: BlockDuration
//        value: <class 'catparser.ast.Conditional'>
//            linked_field_name: registration_type
//            operation: equals
//            value: ROOT
//        disposition: None
//        attributes: None
//        *is_conditional: True
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    parent_id = NamespaceId if CHILD equals registration_type
//        name: parent_id
//        field_type: NamespaceId
//        value: <class 'catparser.ast.Conditional'>
//            linked_field_name: registration_type
//            operation: equals
//            value: CHILD
//        disposition: None
//        attributes: None
//        *is_conditional: True
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    id = NamespaceId
//        name: id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    registration_type = NamespaceRegistrationType
//        name: registration_type
//        field_type: NamespaceRegistrationType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    name_size = u8
//        name: name_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    name = array(u8, name_size)
//        name: name
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: name_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: name_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct NamespaceRegistrationTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub duration: BlockDuration,
    pub parent_id: NamespaceId,
    pub id: NamespaceId,
    pub registration_type: NamespaceRegistrationType,
    pub name: Vec<u8>,
}
impl NamespaceRegistrationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        duration: BlockDuration,
        parent_id: NamespaceId,
        id: NamespaceId,
        registration_type: NamespaceRegistrationType,
        name: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            duration,
            parent_id,
            id,
            registration_type,
            name,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            duration: BlockDuration::default(),
            parent_id: NamespaceId::default(),
            id: NamespaceId::default(),
            registration_type: NamespaceRegistrationType::default(),
            name: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        if self.registration_type == NamespaceRegistrationType::ROOT {
            size += self.duration.size();
        }
        if self.registration_type == NamespaceRegistrationType::CHILD {
            size += self.parent_id.size();
        }
        size += self.id.size();
        size += self.registration_type.size();
        size += 1;
        size += 1 * self.name.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let duration;
        let payload_for_conditional = &payload[..BlockDuration::SIZE];
        payload = &payload[BlockDuration::SIZE..];
        (duration, _) = BlockDuration::deserialize(payload_for_conditional)?;
        let parent_id;
        (parent_id, _) = NamespaceId::deserialize(payload_for_conditional)?;
        let id;
        (id, payload) = NamespaceId::deserialize(payload)?;
        let registration_type;
        (registration_type, payload) = NamespaceRegistrationType::deserialize(payload)?;
        let name_size = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let mut name = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..name_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            name.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            duration,
            parent_id,
            id,
            registration_type,
            name,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let duration = if self.registration_type == NamespaceRegistrationType::ROOT {
            self.duration.serialize()
        } else {
            Vec::new()
        };

        let parent_id = if self.registration_type == NamespaceRegistrationType::CHILD {
            self.parent_id.serialize()
        } else {
            Vec::new()
        };
        let id = self.id.serialize();
        let registration_type = self.registration_type.serialize();
        let name_size = (self.name.len() as u8).to_le_bytes();
        let name: Vec<u8> = self.name.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            duration.iter(),
            parent_id.iter(),
            id.iter(),
            registration_type.iter(),
            name_size.iter(),
            name.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for NamespaceRegistrationTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for NamespaceRegistrationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of NamespaceRegistrationTransaction (V1, latest).
//name: EmbeddedNamespaceRegistrationTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, NAMESPACE_REGISTRATION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: NAMESPACE_REGISTRATION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    duration = BlockDuration if ROOT equals registration_type
//        name: duration
//        field_type: BlockDuration
//        value: <class 'catparser.ast.Conditional'>
//            linked_field_name: registration_type
//            operation: equals
//            value: ROOT
//        disposition: None
//        attributes: None
//        *is_conditional: True
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    parent_id = NamespaceId if CHILD equals registration_type
//        name: parent_id
//        field_type: NamespaceId
//        value: <class 'catparser.ast.Conditional'>
//            linked_field_name: registration_type
//            operation: equals
//            value: CHILD
//        disposition: None
//        attributes: None
//        *is_conditional: True
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    id = NamespaceId
//        name: id
//        field_type: NamespaceId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    registration_type = NamespaceRegistrationType
//        name: registration_type
//        field_type: NamespaceRegistrationType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    name_size = u8
//        name: name_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    name = array(u8, name_size)
//        name: name
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: name_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: name_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedNamespaceRegistrationTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub duration: BlockDuration,
    pub parent_id: NamespaceId,
    pub id: NamespaceId,
    pub registration_type: NamespaceRegistrationType,
    pub name: Vec<u8>,
}
impl EmbeddedNamespaceRegistrationTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        duration: BlockDuration,
        parent_id: NamespaceId,
        id: NamespaceId,
        registration_type: NamespaceRegistrationType,
        name: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            duration,
            parent_id,
            id,
            registration_type,
            name,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            duration: BlockDuration::default(),
            parent_id: NamespaceId::default(),
            id: NamespaceId::default(),
            registration_type: NamespaceRegistrationType::default(),
            name: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        if self.registration_type == NamespaceRegistrationType::ROOT {
            size += self.duration.size();
        }
        if self.registration_type == NamespaceRegistrationType::CHILD {
            size += self.parent_id.size();
        }
        size += self.id.size();
        size += self.registration_type.size();
        size += 1;
        size += 1 * self.name.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let duration;
        let payload_for_conditional = &payload[..BlockDuration::SIZE];
        payload = &payload[BlockDuration::SIZE..];
        (duration, _) = BlockDuration::deserialize(payload_for_conditional)?;
        let parent_id;
        (parent_id, _) = NamespaceId::deserialize(payload_for_conditional)?;
        let id;
        (id, payload) = NamespaceId::deserialize(payload)?;
        let registration_type;
        (registration_type, payload) = NamespaceRegistrationType::deserialize(payload)?;
        let name_size = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let mut name = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..name_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            name.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            duration,
            parent_id,
            id,
            registration_type,
            name,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let duration = if self.registration_type == NamespaceRegistrationType::ROOT {
            self.duration.serialize()
        } else {
            Vec::new()
        };

        let parent_id = if self.registration_type == NamespaceRegistrationType::CHILD {
            self.parent_id.serialize()
        } else {
            Vec::new()
        };
        let id = self.id.serialize();
        let registration_type = self.registration_type.serialize();
        let name_size = (self.name.len() as u8).to_le_bytes();
        let name: Vec<u8> = self.name.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            duration.iter(),
            parent_id.iter(),
            id.iter(),
            registration_type.iter(),
            name_size.iter(),
            name.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedNamespaceRegistrationTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Enumeration of account restriction flags.
//name: AccountRestrictionFlags
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint16
//    is_unsigned: True
//    size: 2
//    display_type: DisplayType.INTEGER
//    *name: uint16
//    *sizeref: None
//values: <class 'list'>
//    ADDRESS = 1
//        name: ADDRESS
//        value: 1
//    MOSAIC_ID = 2
//        name: MOSAIC_ID
//        value: 2
//    TRANSACTION_TYPE = 4
//        name: TRANSACTION_TYPE
//        value: 4
//    OUTGOING = 16384
//        name: OUTGOING
//        value: 16384
//    BLOCK = 32768
//        name: BLOCK
//        value: 32768
//display_type: DisplayType.ENUM
//attributes: <class 'list'>
//    @is_bitwise
//        name: is_bitwise
//        is_flag: True
//        value: True
//        values: <class 'list'>
//*is_bitwise: True
//*is_unsigned: True
//*size: 2
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u16)]
pub enum AccountRestrictionFlags {
    ADDRESS = 1,
    MOSAIC_ID = 2,
    TRANSACTION_TYPE = 4,
    OUTGOING = 16384,
    BLOCK = 32768,
    X(u16),
}
impl AccountRestrictionFlags {
    pub const SIZE: usize = 2;
    pub fn default() -> Self {
        Self::ADDRESS
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn to_num(&self) -> u16 {
        match self {
            Self::ADDRESS => 1,
            Self::MOSAIC_ID => 2,
            Self::TRANSACTION_TYPE => 4,
            Self::OUTGOING => 16384,
            Self::BLOCK => 32768,
            Self::X(x) => *x,
        }
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u16::from_le_bytes(bytes.try_into()?) {
            1 => Ok((AccountRestrictionFlags::ADDRESS, rest)),
            2 => Ok((AccountRestrictionFlags::MOSAIC_ID, rest)),
            4 => Ok((AccountRestrictionFlags::TRANSACTION_TYPE, rest)),
            16384 => Ok((AccountRestrictionFlags::OUTGOING, rest)),
            32768 => Ok((AccountRestrictionFlags::BLOCK, rest)),
            x if (!1 & !2 & !4 & !16384 & !32768 & x) == 0 => Ok((Self::X(x), rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "AccountRestrictionFlags".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        match self {
            Self::ADDRESS => 1u16.to_le_bytes().to_vec(),
            Self::MOSAIC_ID => 2u16.to_le_bytes().to_vec(),
            Self::TRANSACTION_TYPE => 4u16.to_le_bytes().to_vec(),
            Self::OUTGOING => 16384u16.to_le_bytes().to_vec(),
            Self::BLOCK => 32768u16.to_le_bytes().to_vec(),
            Self::X(x) => x.to_le_bytes().to_vec(),
        }
    }
}
impl BitOr for AccountRestrictionFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() | rhs.to_num())
    }
}
impl BitOrAssign for AccountRestrictionFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        *self = *self | rhs;
    }
}
impl BitAnd for AccountRestrictionFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() & rhs.to_num())
    }
}
impl BitAndAssign for AccountRestrictionFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        *self = *self & rhs;
    }
}
impl BitXor for AccountRestrictionFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self::Output {
        Self::X(self.to_num() ^ rhs.to_num())
    }
}
impl BitXorAssign for AccountRestrictionFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = *self ^ rhs;
    }
}
impl Not for AccountRestrictionFlags {
    type Output = Self;
    fn not(self) -> Self::Output {
        Self::X(!self.to_num())
    }
}

///Allow or block incoming and outgoing transactions for a given a set of addresses (V1, latest).
//name: AccountAddressRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_ADDRESS_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_ADDRESS_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(UnresolvedAddress, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(UnresolvedAddress, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AccountAddressRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedAddress>,
    pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl AccountAddressRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedAddress>,
        restriction_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AccountAddressRestrictionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AccountAddressRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AccountAddressRestrictionTransaction (V1, latest).
//name: EmbeddedAccountAddressRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_ADDRESS_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_ADDRESS_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(UnresolvedAddress, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(UnresolvedAddress, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedAddress
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAccountAddressRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedAddress>,
    pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedAccountAddressRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedAddress>,
        restriction_deletions: Vec<UnresolvedAddress>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedAddress::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAccountAddressRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Allow or block incoming transactions containing a given set of mosaics (V1, latest).
//name: AccountMosaicRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_MOSAIC_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_MOSAIC_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(UnresolvedMosaicId, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaicId
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(UnresolvedMosaicId, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaicId
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AccountMosaicRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedMosaicId>,
    pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl AccountMosaicRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedMosaicId>,
        restriction_deletions: Vec<UnresolvedMosaicId>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AccountMosaicRestrictionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AccountMosaicRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AccountMosaicRestrictionTransaction (V1, latest).
//name: EmbeddedAccountMosaicRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_MOSAIC_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_MOSAIC_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(UnresolvedMosaicId, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaicId
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(UnresolvedMosaicId, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaicId
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAccountMosaicRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<UnresolvedMosaicId>,
    pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl EmbeddedAccountMosaicRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<UnresolvedMosaicId>,
        restriction_deletions: Vec<UnresolvedMosaicId>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = UnresolvedMosaicId::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAccountMosaicRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Allow or block outgoing transactions depending on their transaction type (V1, latest).
//name: AccountOperationRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_OPERATION_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_OPERATION_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(TransactionType, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: TransactionType
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(TransactionType, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: TransactionType
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct AccountOperationRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<TransactionType>,
    pub restriction_deletions: Vec<TransactionType>,
}
impl AccountOperationRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<TransactionType>,
        restriction_deletions: Vec<TransactionType>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for AccountOperationRestrictionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for AccountOperationRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of AccountOperationRestrictionTransaction (V1, latest).
//name: EmbeddedAccountOperationRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, ACCOUNT_OPERATION_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: ACCOUNT_OPERATION_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_flags = AccountRestrictionFlags
//        name: restriction_flags
//        field_type: AccountRestrictionFlags
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_additions_count = u8
//        name: restriction_additions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    restriction_deletions_count = u8
//        name: restriction_deletions_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    account_restriction_transaction_body_reserved_1 = make_reserved(u32, 0)
//        name: account_restriction_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    restriction_additions = array(TransactionType, restriction_additions_count)
//        name: restriction_additions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: TransactionType
//            size: restriction_additions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_additions_count
//    restriction_deletions = array(TransactionType, restriction_deletions_count)
//        name: restriction_deletions
//        field_type: <class 'catparser.ast.Array'>
//            element_type: TransactionType
//            size: restriction_deletions_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: restriction_deletions_count
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedAccountOperationRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub restriction_flags: AccountRestrictionFlags,
    pub restriction_additions: Vec<TransactionType>,
    pub restriction_deletions: Vec<TransactionType>,
}
impl EmbeddedAccountOperationRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        restriction_flags: AccountRestrictionFlags,
        restriction_additions: Vec<TransactionType>,
        restriction_deletions: Vec<TransactionType>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            restriction_flags: AccountRestrictionFlags::default(),
            restriction_additions: Vec::new(),
            restriction_deletions: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.restriction_flags.size();
        size += 1;
        size += 1;
        size += 4;
        size += self
            .restriction_additions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size += self
            .restriction_deletions
            .iter()
            .map(|x| x.size())
            .sum::<usize>();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let restriction_flags;
        (restriction_flags, payload) = AccountRestrictionFlags::deserialize(payload)?;
        let restriction_additions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let restriction_deletions_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let account_restriction_transaction_body_reserved_1 =
            u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if account_restriction_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                account_restriction_transaction_body_reserved_1 as u32,
            ));
        }
        let mut restriction_additions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_additions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_additions.push(element);
        }
        let mut restriction_deletions = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..restriction_deletions_count {
            let element;
            (element, payload) = TransactionType::deserialize(payload)?;
            restriction_deletions.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            restriction_flags,
            restriction_additions,
            restriction_deletions,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let restriction_flags = self.restriction_flags.serialize();
        let restriction_additions_count = (self.restriction_additions.len() as u8).to_le_bytes();
        let restriction_deletions_count = (self.restriction_deletions.len() as u8).to_le_bytes();
        let account_restriction_transaction_body_reserved_1 = 0u32.to_le_bytes();
        let restriction_additions: Vec<u8> = self
            .restriction_additions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        let restriction_deletions: Vec<u8> = self
            .restriction_deletions
            .iter()
            .flat_map(|x| x.serialize())
            .collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            restriction_flags.iter(),
            restriction_additions_count.iter(),
            restriction_deletions_count.iter(),
            account_restriction_transaction_body_reserved_1.iter(),
            restriction_additions.iter(),
            restriction_deletions.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedAccountOperationRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Set address specific rules to transfer a restrictable mosaic (V1, latest).
//name: MosaicAddressRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ADDRESS_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_ADDRESS_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_key = u64
//        name: restriction_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_value = u64
//        name: previous_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    new_restriction_value = u64
//        name: new_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicAddressRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub target_address: UnresolvedAddress,
}
impl MosaicAddressRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        target_address: UnresolvedAddress,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            target_address: UnresolvedAddress::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicAddressRestrictionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicAddressRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicAddressRestrictionTransaction (V1, latest).
//name: EmbeddedMosaicAddressRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_ADDRESS_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_ADDRESS_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_key = u64
//        name: restriction_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_value = u64
//        name: previous_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    new_restriction_value = u64
//        name: new_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    target_address = UnresolvedAddress
//        name: target_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicAddressRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub target_address: UnresolvedAddress,
}
impl EmbeddedMosaicAddressRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        target_address: UnresolvedAddress,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            target_address: UnresolvedAddress::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.target_address.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let target_address;
        (target_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            target_address,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let target_address = self.target_address.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            target_address.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicAddressRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

//name: MosaicRestrictionKey
//linked_type: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint64
//    is_unsigned: True
//    size: 8
//    display_type: DisplayType.INTEGER
//    *name: uint64
//    *sizeref: None
//*is_unsigned: True
//*size: 8
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_integer()
#[derive(PartialOrd, Ord, Copy)]
pub struct MosaicRestrictionKey(pub u64);
impl MosaicRestrictionKey {
    pub const SIZE: usize = 8;
    pub fn new(mosaicrestrictionkey: u64) -> Self {
        Self(mosaicrestrictionkey)
    }
    pub fn default() -> Self {
        Self(0)
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        let value = u64::from_le_bytes(bytes.try_into()?);
        Ok((Self(value), rest))
    }
    pub fn serialize(&self) -> Vec<u8> {
        self.0.to_le_bytes().to_vec()
    }
}

///Enumeration of mosaic restriction types.
//name: MosaicRestrictionType
//base: <class 'catparser.ast.FixedSizeInteger'>
//    short_name: uint8
//    is_unsigned: True
//    size: 1
//    display_type: DisplayType.INTEGER
//    *name: uint8
//    *sizeref: None
//values: <class 'list'>
//    NONE = 0
//        name: NONE
//        value: 0
//    EQ = 1
//        name: EQ
//        value: 1
//    NE = 2
//        name: NE
//        value: 2
//    LT = 3
//        name: LT
//        value: 3
//    LE = 4
//        name: LE
//        value: 4
//    GT = 5
//        name: GT
//        value: 5
//    GE = 6
//        name: GE
//        value: 6
//display_type: DisplayType.ENUM
//attributes: None
//*is_bitwise: None
//*is_unsigned: True
//*size: 1
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_enum()
#[derive(PartialOrd, Ord, Copy)]
#[allow(non_camel_case_types)]
#[repr(u8)]
pub enum MosaicRestrictionType {
    NONE = 0,
    EQ = 1,
    NE = 2,
    LT = 3,
    LE = 4,
    GT = 5,
    GE = 6,
}
impl MosaicRestrictionType {
    pub const SIZE: usize = 1;
    pub fn default() -> Self {
        Self::NONE
    }
    pub fn size(&self) -> usize {
        Self::SIZE
    }
    pub fn deserialize(payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        if payload.len() < Self::SIZE {
            return Err(SymbolError::SizeError {
                expect: vec![Self::SIZE],
                real: payload.len(),
            });
        }
        let (bytes, rest) = payload.split_at(Self::SIZE);
        match u8::from_le_bytes(bytes.try_into()?) {
            0 => Ok((MosaicRestrictionType::NONE, rest)),
            1 => Ok((MosaicRestrictionType::EQ, rest)),
            2 => Ok((MosaicRestrictionType::NE, rest)),
            3 => Ok((MosaicRestrictionType::LT, rest)),
            4 => Ok((MosaicRestrictionType::LE, rest)),
            5 => Ok((MosaicRestrictionType::GT, rest)),
            6 => Ok((MosaicRestrictionType::GE, rest)),
            other => Err(SymbolError::MismatchError {
                pattern: vec![other as u32],
                place: "MosaicRestrictionType".to_string(),
            }),
        }
    }
    pub fn serialize(&self) -> Vec<u8> {
        (self.clone() as u8).to_le_bytes().to_vec()
    }
}
///Set global rules to transfer a restrictable mosaic (V1, latest).
//name: MosaicGlobalRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_GLOBAL_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_GLOBAL_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    reference_mosaic_id = UnresolvedMosaicId
//        name: reference_mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_key = u64
//        name: restriction_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_value = u64
//        name: previous_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    new_restriction_value = u64
//        name: new_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_type = MosaicRestrictionType
//        name: previous_restriction_type
//        field_type: MosaicRestrictionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    new_restriction_type = MosaicRestrictionType
//        name: new_restriction_type
//        field_type: MosaicRestrictionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct MosaicGlobalRestrictionTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub mosaic_id: UnresolvedMosaicId,
    pub reference_mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub previous_restriction_type: MosaicRestrictionType,
    pub new_restriction_type: MosaicRestrictionType,
}
impl MosaicGlobalRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        mosaic_id: UnresolvedMosaicId,
        reference_mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        previous_restriction_type: MosaicRestrictionType,
        new_restriction_type: MosaicRestrictionType,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type,
            new_restriction_type,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            reference_mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            previous_restriction_type: MosaicRestrictionType::default(),
            new_restriction_type: MosaicRestrictionType::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.mosaic_id.size();
        size += self.reference_mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.previous_restriction_type.size();
        size += self.new_restriction_type.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let reference_mosaic_id;
        (reference_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_type;
        (previous_restriction_type, payload) = MosaicRestrictionType::deserialize(payload)?;
        let new_restriction_type;
        (new_restriction_type, payload) = MosaicRestrictionType::deserialize(payload)?;
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type,
            new_restriction_type,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let reference_mosaic_id = self.reference_mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let previous_restriction_type = self.previous_restriction_type.serialize();
        let new_restriction_type = self.new_restriction_type.serialize();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            mosaic_id.iter(),
            reference_mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            previous_restriction_type.iter(),
            new_restriction_type.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for MosaicGlobalRestrictionTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for MosaicGlobalRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Embedded version of MosaicGlobalRestrictionTransaction (V1, latest).
//name: EmbeddedMosaicGlobalRestrictionTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, MOSAIC_GLOBAL_RESTRICTION)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: MOSAIC_GLOBAL_RESTRICTION
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    mosaic_id = UnresolvedMosaicId
//        name: mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    reference_mosaic_id = UnresolvedMosaicId
//        name: reference_mosaic_id
//        field_type: UnresolvedMosaicId
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    restriction_key = u64
//        name: restriction_key
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_value = u64
//        name: previous_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    new_restriction_value = u64
//        name: new_restriction_value
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u64
//            is_unsigned: True
//            size: 8
//            display_type: DisplayType.INTEGER
//            *name: u64
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 8
//    previous_restriction_type = MosaicRestrictionType
//        name: previous_restriction_type
//        field_type: MosaicRestrictionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    new_restriction_type = MosaicRestrictionType
//        name: new_restriction_type
//        field_type: MosaicRestrictionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedMosaicGlobalRestrictionTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub mosaic_id: UnresolvedMosaicId,
    pub reference_mosaic_id: UnresolvedMosaicId,
    pub restriction_key: u64,
    pub previous_restriction_value: u64,
    pub new_restriction_value: u64,
    pub previous_restriction_type: MosaicRestrictionType,
    pub new_restriction_type: MosaicRestrictionType,
}
impl EmbeddedMosaicGlobalRestrictionTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        mosaic_id: UnresolvedMosaicId,
        reference_mosaic_id: UnresolvedMosaicId,
        restriction_key: u64,
        previous_restriction_value: u64,
        new_restriction_value: u64,
        previous_restriction_type: MosaicRestrictionType,
        new_restriction_type: MosaicRestrictionType,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type,
            new_restriction_type,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            mosaic_id: UnresolvedMosaicId::default(),
            reference_mosaic_id: UnresolvedMosaicId::default(),
            restriction_key: u64::default(),
            previous_restriction_value: u64::default(),
            new_restriction_value: u64::default(),
            previous_restriction_type: MosaicRestrictionType::default(),
            new_restriction_type: MosaicRestrictionType::default(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.mosaic_id.size();
        size += self.reference_mosaic_id.size();
        size += 8;
        size += 8;
        size += 8;
        size += self.previous_restriction_type.size();
        size += self.new_restriction_type.size();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let mosaic_id;
        (mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let reference_mosaic_id;
        (reference_mosaic_id, payload) = UnresolvedMosaicId::deserialize(payload)?;
        let restriction_key = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let new_restriction_value = u64::from_le_bytes(payload[..8].try_into()?);
        payload = &payload[8..];
        let previous_restriction_type;
        (previous_restriction_type, payload) = MosaicRestrictionType::deserialize(payload)?;
        let new_restriction_type;
        (new_restriction_type, payload) = MosaicRestrictionType::deserialize(payload)?;
        let self_ = Self {
            signer_public_key,
            network,
            mosaic_id,
            reference_mosaic_id,
            restriction_key,
            previous_restriction_value,
            new_restriction_value,
            previous_restriction_type,
            new_restriction_type,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let mosaic_id = self.mosaic_id.serialize();
        let reference_mosaic_id = self.reference_mosaic_id.serialize();
        let restriction_key = self.restriction_key.to_le_bytes();
        let previous_restriction_value = self.previous_restriction_value.to_le_bytes();
        let new_restriction_value = self.new_restriction_value.to_le_bytes();
        let previous_restriction_type = self.previous_restriction_type.serialize();
        let new_restriction_type = self.new_restriction_type.serialize();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            mosaic_id.iter(),
            reference_mosaic_id.iter(),
            restriction_key.iter(),
            previous_restriction_value.iter(),
            new_restriction_value.iter(),
            previous_restriction_type.iter(),
            new_restriction_type.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedMosaicGlobalRestrictionTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

///Send mosaics and messages between two accounts (V1, latest).
//name: TransferTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, TRANSFER)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: TRANSFER
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    verifiable_entity_header_reserved_1 = make_reserved(u32, 0)
//        name: verifiable_entity_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signature = Signature
//        name: signature
//        field_type: Signature
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    fee = Amount
//        name: fee
//        field_type: Amount
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    deadline = Timestamp
//        name: deadline
//        field_type: Timestamp
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    message_size = u16
//        name: message_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    mosaics_count = u8
//        name: mosaics_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    transfer_transaction_body_reserved_1 = make_reserved(u8, 0)
//        name: transfer_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    transfer_transaction_body_reserved_2 = make_reserved(u32, 0)
//        name: transfer_transaction_body_reserved_2
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @sort_key(mosaic_id) mosaics = array(UnresolvedMosaic, mosaics_count)
//        name: mosaics
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaic
//            size: mosaics_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: mosaic_id
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @sort_key(mosaic_id)
//                name: sort_key
//                is_flag: False
//                value: mosaic_id
//                values: <class 'list'>
//                    mosaic_id
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: mosaics_count
//    message = array(u8, message_size)
//        name: message
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: message_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: message_size
//factory_type: Transaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct TransferTransactionV1 {
    pub signature: Signature,
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub fee: Amount,
    pub deadline: Timestamp,
    pub recipient_address: UnresolvedAddress,
    pub mosaics: Vec<UnresolvedMosaic>,
    pub message: Vec<u8>,
}
impl TransferTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        fee: Amount,
        deadline: Timestamp,
        recipient_address: UnresolvedAddress,
        mosaics: Vec<UnresolvedMosaic>,
        message: Vec<u8>,
    ) -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            mosaics,
            message,
        }
    }
    pub fn default() -> Self {
        Self {
            signature: Signature::default(),
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            fee: Amount::default(),
            deadline: Timestamp::default(),
            recipient_address: UnresolvedAddress::default(),
            mosaics: Vec::new(),
            message: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signature.size();
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.fee.size();
        size += self.deadline.size();
        size += self.recipient_address.size();
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        size += self.mosaics.iter().map(|x| x.size()).sum::<usize>();
        size += 1 * self.message.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let verifiable_entity_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if verifiable_entity_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                verifiable_entity_header_reserved_1 as u32,
            ));
        }
        let signature;
        (signature, payload) = Signature::deserialize(payload)?;
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let fee;
        (fee, payload) = Amount::deserialize(payload)?;
        let deadline;
        (deadline, payload) = Timestamp::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let message_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mosaics_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let transfer_transaction_body_reserved_1 = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        if transfer_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_1 as u32,
            ));
        }
        let transfer_transaction_body_reserved_2 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if transfer_transaction_body_reserved_2 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_2 as u32,
            ));
        }
        let mut mosaics = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..mosaics_count {
            let element;
            (element, payload) = UnresolvedMosaic::deserialize(payload)?;
            mosaics.push(element);
        }
        let mut message = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..message_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            message.push(element);
        }
        let self_ = Self {
            signature,
            signer_public_key,
            network,
            fee,
            deadline,
            recipient_address,
            mosaics,
            message,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let verifiable_entity_header_reserved_1 = 0u32.to_le_bytes();
        let signature = self.signature.serialize();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let fee = self.fee.serialize();
        let deadline = self.deadline.serialize();
        let recipient_address = self.recipient_address.serialize();
        let message_size = (self.message.len() as u16).to_le_bytes();
        let mosaics_count = (self.mosaics.len() as u8).to_le_bytes();
        let transfer_transaction_body_reserved_1 = 0u8.to_le_bytes();
        let transfer_transaction_body_reserved_2 = 0u32.to_le_bytes();
        let mosaics: Vec<u8> = self.mosaics.iter().flat_map(|x| x.serialize()).collect();
        let message: Vec<u8> = self.message.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            verifiable_entity_header_reserved_1.iter(),
            signature.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            fee.iter(),
            deadline.iter(),
            recipient_address.iter(),
            message_size.iter(),
            mosaics_count.iter(),
            transfer_transaction_body_reserved_1.iter(),
            transfer_transaction_body_reserved_2.iter(),
            mosaics.iter(),
            message.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignature for TransferTransactionV1 {
    fn get_signature(&self) -> &Signature {
        &self.signature
    }
    fn set_signature(&mut self, signature: Signature) {
        self.signature = signature;
    }
}

impl TraitSignerPublicKey for TransferTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

impl TraitMessage for TransferTransactionV1 {
    fn get_message(&self) -> &Vec<u8> {
        &self.message
    }
    fn set_message(&mut self, message: Vec<u8>) {
        self.message = message;
    }
}

///Embedded version of TransferTransaction (V1, latest).
//name: EmbeddedTransferTransactionV1
//disposition: None
//fields: <class 'list'>
//    TRANSACTION_VERSION = make_const(u8, 1)
//        name: TRANSACTION_VERSION
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 1
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    TRANSACTION_TYPE = make_const(TransactionType, TRANSFER)
//        name: TRANSACTION_TYPE
//        field_type: TransactionType
//        value: TRANSFER
//        disposition: const
//        attributes: None
//        *is_conditional: False
//        *is_const: True
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    size = u32
//        name: size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    embedded_transaction_header_reserved_1 = make_reserved(u32, 0)
//        name: embedded_transaction_header_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    signer_public_key = PublicKey
//        name: signer_public_key
//        field_type: PublicKey
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    entity_body_reserved_1 = make_reserved(u32, 0)
//        name: entity_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    version = u8
//        name: version
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    network = NetworkType
//        name: network
//        field_type: NetworkType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    type = TransactionType
//        name: type
//        field_type: TransactionType
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    recipient_address = UnresolvedAddress
//        name: recipient_address
//        field_type: UnresolvedAddress
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: None
//    message_size = u16
//        name: message_size
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u16
//            is_unsigned: True
//            size: 2
//            display_type: DisplayType.INTEGER
//            *name: u16
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 2
//    mosaics_count = u8
//        name: mosaics_count
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    transfer_transaction_body_reserved_1 = make_reserved(u8, 0)
//        name: transfer_transaction_body_reserved_1
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u8
//            is_unsigned: True
//            size: 1
//            display_type: DisplayType.INTEGER
//            *name: u8
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 1
//    transfer_transaction_body_reserved_2 = make_reserved(u32, 0)
//        name: transfer_transaction_body_reserved_2
//        field_type: <class 'catparser.ast.FixedSizeInteger'>
//            short_name: u32
//            is_unsigned: True
//            size: 4
//            display_type: DisplayType.INTEGER
//            *name: u32
//            *sizeref: None
//        value: 0
//        disposition: reserved
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: True
//        *is_size_reference: False
//        *is_unsigned: True
//        *size: 4
//    @sort_key(mosaic_id) mosaics = array(UnresolvedMosaic, mosaics_count)
//        name: mosaics
//        field_type: <class 'catparser.ast.Array'>
//            element_type: UnresolvedMosaic
//            size: mosaics_count
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: mosaic_id
//        value: None
//        disposition: None
//        attributes: <class 'list'>
//            @sort_key(mosaic_id)
//                name: sort_key
//                is_flag: False
//                value: mosaic_id
//                values: <class 'list'>
//                    mosaic_id
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: mosaics_count
//    message = array(u8, message_size)
//        name: message
//        field_type: <class 'catparser.ast.Array'>
//            element_type: <class 'catparser.ast.FixedSizeInteger'>
//                short_name: u8
//                is_unsigned: True
//                size: 1
//                display_type: DisplayType.INTEGER
//                *name: u8
//                *sizeref: None
//            size: message_size
//            *alignment: None
//            *disposition: array
//            *is_byte_constrained: False
//            *is_expandable: False
//            *is_last_element_padded: None
//            *sort_key: None
//        value: None
//        disposition: None
//        attributes: None
//        *is_conditional: False
//        *is_const: False
//        *is_reserved: False
//        *is_size_reference: False
//        *is_unsigned: None
//        *size: message_size
//factory_type: EmbeddedTransaction
//display_type: DisplayType.STRUCT
//attributes: <class 'list'>
//    @size(size)
//        name: size
//        is_flag: False
//        value: size
//        values: <class 'list'>
//            size
//    @initializes(version, TRANSACTION_VERSION)
//        name: initializes
//        is_flag: False
//        value: version
//        values: <class 'list'>
//            version
//            TRANSACTION_VERSION
//    @initializes(type, TRANSACTION_TYPE)
//        name: initializes
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            TRANSACTION_TYPE
//    @discriminator(type, version)
//        name: discriminator
//        is_flag: False
//        value: type
//        values: <class 'list'>
//            type
//            version
//    @is_aligned
//        name: is_aligned
//        is_flag: True
//        value: True
//        values: <class 'list'>
//requires_unaligned: False
//*comparer: None
//*discriminator: ['type', 'version']
//*initializers: [Initializer(target_property_name='version', value='TRANSACTION_VERSION'), Initializer(target_property_name='type', value='TRANSACTION_TYPE')]
//*is_abstract: False
//*is_aligned: True
//*is_inline: False
//*is_size_implicit: None
//*size: size
#[derive(Debug, Clone, PartialEq, Eq)]
// generated from generate_struct()
pub struct EmbeddedTransferTransactionV1 {
    pub signer_public_key: PublicKey,
    pub network: NetworkType,
    pub recipient_address: UnresolvedAddress,
    pub mosaics: Vec<UnresolvedMosaic>,
    pub message: Vec<u8>,
}
impl EmbeddedTransferTransactionV1 {
    pub const TRANSACTION_VERSION: u8 = 1;
    pub const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
    pub fn version(&self) -> u8 {
        Self::TRANSACTION_VERSION
    }
    pub fn type_(&self) -> TransactionType {
        Self::TRANSACTION_TYPE
    }
    pub fn new(
        signer_public_key: PublicKey,
        network: NetworkType,
        recipient_address: UnresolvedAddress,
        mosaics: Vec<UnresolvedMosaic>,
        message: Vec<u8>,
    ) -> Self {
        Self {
            signer_public_key,
            network,
            recipient_address,
            mosaics,
            message,
        }
    }
    pub fn default() -> Self {
        Self {
            signer_public_key: PublicKey::default(),
            network: NetworkType::default(),
            recipient_address: UnresolvedAddress::default(),
            mosaics: Vec::new(),
            message: Vec::new(),
        }
    }
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += 4;
        size += 4;
        size += self.signer_public_key.size();
        size += 4;
        size += 1;
        size += self.network.size();
        size += self.type_().size();
        size += self.recipient_address.size();
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        size += self.mosaics.iter().map(|x| x.size()).sum::<usize>();
        size += 1 * self.message.len();
        size
    }
    pub fn deserialize(mut payload: &[u8]) -> Result<(Self, &[u8]), SymbolError> {
        #[allow(unused)]
        let initial_payload_len = payload.len();
        if payload.len() < 4 {
            return Err(SymbolError::SizeError {
                expect: vec![4],
                real: payload.len(),
            });
        }
        let size = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if size as usize > payload.len() + 4 {
            return Err(SymbolError::SizeError {
                expect: vec![size as usize],
                real: payload.len() + 4,
            });
        }
        let embedded_transaction_header_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if embedded_transaction_header_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                embedded_transaction_header_reserved_1 as u32,
            ));
        }
        let signer_public_key;
        (signer_public_key, payload) = PublicKey::deserialize(payload)?;
        let entity_body_reserved_1 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if entity_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                entity_body_reserved_1 as u32,
            ));
        }
        let _version = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let network;
        (network, payload) = NetworkType::deserialize(payload)?;
        let _type;
        (_type, payload) = TransactionType::deserialize(payload)?;
        let recipient_address;
        (recipient_address, payload) = UnresolvedAddress::deserialize(payload)?;
        let message_size = u16::from_le_bytes(payload[..2].try_into()?);
        payload = &payload[2..];
        let mosaics_count = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        let transfer_transaction_body_reserved_1 = u8::from_le_bytes(payload[..1].try_into()?);
        payload = &payload[1..];
        if transfer_transaction_body_reserved_1 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_1 as u32,
            ));
        }
        let transfer_transaction_body_reserved_2 = u32::from_le_bytes(payload[..4].try_into()?);
        payload = &payload[4..];
        if transfer_transaction_body_reserved_2 != 0 {
            return Err(SymbolError::ReservedIsNotZeroError(
                transfer_transaction_body_reserved_2 as u32,
            ));
        }
        let mut mosaics = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..mosaics_count {
            let element;
            (element, payload) = UnresolvedMosaic::deserialize(payload)?;
            mosaics.push(element);
        }
        let mut message = Vec::new();
        #[allow(unused)]
        let tmp_payload_len = payload.len();
        for _ in 0..message_size {
            let mut bytes = [0u8; 1];
            bytes.copy_from_slice(&payload[..1]);
            let element = u8::from_le_bytes(bytes);
            payload = &payload[1..];
            message.push(element);
        }
        let self_ = Self {
            signer_public_key,
            network,
            recipient_address,
            mosaics,
            message,
        };
        Ok((self_, payload))
    }
    pub fn serialize(&self) -> Vec<u8> {
        let size = (self.size() as u32).to_le_bytes();
        let embedded_transaction_header_reserved_1 = 0u32.to_le_bytes();
        let signer_public_key = self.signer_public_key.serialize();
        let entity_body_reserved_1 = 0u32.to_le_bytes();
        let version = (self.version() as u8).to_le_bytes();
        let network = self.network.serialize();
        let type_ = self.type_().serialize();
        let recipient_address = self.recipient_address.serialize();
        let message_size = (self.message.len() as u16).to_le_bytes();
        let mosaics_count = (self.mosaics.len() as u8).to_le_bytes();
        let transfer_transaction_body_reserved_1 = 0u8.to_le_bytes();
        let transfer_transaction_body_reserved_2 = 0u32.to_le_bytes();
        let mosaics: Vec<u8> = self.mosaics.iter().flat_map(|x| x.serialize()).collect();
        let message: Vec<u8> = self.message.iter().flat_map(|x| x.to_le_bytes()).collect();
        [
            size.iter(),
            embedded_transaction_header_reserved_1.iter(),
            signer_public_key.iter(),
            entity_body_reserved_1.iter(),
            version.iter(),
            network.iter(),
            type_.iter(),
            recipient_address.iter(),
            message_size.iter(),
            mosaics_count.iter(),
            transfer_transaction_body_reserved_1.iter(),
            transfer_transaction_body_reserved_2.iter(),
            mosaics.iter(),
            message.iter(),
        ]
        .into_iter()
        .flat_map(|a| a)
        .map(|x| *x)
        .collect()
    }
}
impl TraitSignerPublicKey for EmbeddedTransferTransactionV1 {
    fn get_signer_public_key(&self) -> &PublicKey {
        &self.signer_public_key
    }
    fn set_signer_public_key(&mut self, signer_public_key: PublicKey) {
        self.signer_public_key = signer_public_key;
    }
}

impl TraitMessage for EmbeddedTransferTransactionV1 {
    fn get_message(&self) -> &Vec<u8> {
        &self.message
    }
    fn set_message(&mut self, message: Vec<u8>) {
        self.message = message;
    }
}
