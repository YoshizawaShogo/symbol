// rust
use hex;

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct Amount {
	value: u64
}
impl Amount {
	const SIZE: usize = 8;
	pub fn new(amount: u64) -> Self {
		Self {
			value: amount
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct BlockDuration {
	value: u64
}
impl BlockDuration {
	const SIZE: usize = 8;
	pub fn new(blockduration: u64) -> Self {
		Self {
			value: blockduration
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct BlockFeeMultiplier {
	value: u32
}
impl BlockFeeMultiplier {
	const SIZE: usize = 4;
	pub fn new(blockfeemultiplier: u32) -> Self {
		Self {
			value: blockfeemultiplier
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct Difficulty {
	value: u64
}
impl Difficulty {
	const SIZE: usize = 8;
	pub fn new(difficulty: u64) -> Self {
		Self {
			value: difficulty
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct FinalizationEpoch {
	value: u32
}
impl FinalizationEpoch {
	const SIZE: usize = 4;
	pub fn new(finalizationepoch: u32) -> Self {
		Self {
			value: finalizationepoch
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct FinalizationPoint {
	value: u32
}
impl FinalizationPoint {
	const SIZE: usize = 4;
	pub fn new(finalizationpoint: u32) -> Self {
		Self {
			value: finalizationpoint
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct Height {
	value: u64
}
impl Height {
	const SIZE: usize = 8;
	pub fn new(height: u64) -> Self {
		Self {
			value: height
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct Importance {
	value: u64
}
impl Importance {
	const SIZE: usize = 8;
	pub fn new(importance: u64) -> Self {
		Self {
			value: importance
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct ImportanceHeight {
	value: u64
}
impl ImportanceHeight {
	const SIZE: usize = 8;
	pub fn new(importanceheight: u64) -> Self {
		Self {
			value: importanceheight
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct UnresolvedMosaicId {
	value: u64
}
impl UnresolvedMosaicId {
	const SIZE: usize = 8;
	pub fn new(unresolvedmosaicid: u64) -> Self {
		Self {
			value: unresolvedmosaicid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct MosaicId {
	value: u64
}
impl MosaicId {
	const SIZE: usize = 8;
	pub fn new(mosaicid: u64) -> Self {
		Self {
			value: mosaicid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct Timestamp {
	value: u64
}
impl Timestamp {
	const SIZE: usize = 8;
	pub fn new(timestamp: u64) -> Self {
		Self {
			value: timestamp
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct UnresolvedAddress {
	bytes: [u8; 24]
}
impl UnresolvedAddress {
	const SIZE: usize = 24;
	pub fn new(unresolvedaddress: [u8; 24]) -> Self {
		Self {
			bytes: unresolvedaddress
		}
	}
	pub fn default() -> Self {
		Self::new([0; 24])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(unresolvedaddress: [u8; 24]) -> Self {
		Self::new(unresolvedaddress)
	}
	pub fn serialize(&self) -> [u8; 24] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct Address {
	bytes: [u8; 24]
}
impl Address {
	const SIZE: usize = 24;
	pub fn new(address: [u8; 24]) -> Self {
		Self {
			bytes: address
		}
	}
	pub fn default() -> Self {
		Self::new([0; 24])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(address: [u8; 24]) -> Self {
		Self::new(address)
	}
	pub fn serialize(&self) -> [u8; 24] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct Hash256 {
	bytes: [u8; 32]
}
impl Hash256 {
	const SIZE: usize = 32;
	pub fn new(hash256: [u8; 32]) -> Self {
		Self {
			bytes: hash256
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(hash256: [u8; 32]) -> Self {
		Self::new(hash256)
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct Hash512 {
	bytes: [u8; 64]
}
impl Hash512 {
	const SIZE: usize = 64;
	pub fn new(hash512: [u8; 64]) -> Self {
		Self {
			bytes: hash512
		}
	}
	pub fn default() -> Self {
		Self::new([0; 64])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(hash512: [u8; 64]) -> Self {
		Self::new(hash512)
	}
	pub fn serialize(&self) -> [u8; 64] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct PublicKey {
	bytes: [u8; 32]
}
impl PublicKey {
	const SIZE: usize = 32;
	pub fn new(publickey: [u8; 32]) -> Self {
		Self {
			bytes: publickey
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(publickey: [u8; 32]) -> Self {
		Self::new(publickey)
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct VotingPublicKey {
	bytes: [u8; 32]
}
impl VotingPublicKey {
	const SIZE: usize = 32;
	pub fn new(votingpublickey: [u8; 32]) -> Self {
		Self {
			bytes: votingpublickey
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(votingpublickey: [u8; 32]) -> Self {
		Self::new(votingpublickey)
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct Signature {
	bytes: [u8; 64]
}
impl Signature {
	const SIZE: usize = 64;
	pub fn new(signature: [u8; 64]) -> Self {
		Self {
			bytes: signature
		}
	}
	pub fn default() -> Self {
		Self::new([0; 64])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(signature: [u8; 64]) -> Self {
		Self::new(signature)
	}
	pub fn serialize(&self) -> [u8; 64] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Mosaic {
	pub mosaic_id: MosaicId,
	pub amount: Amount,
}
impl Mosaic {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct UnresolvedMosaic {
	pub mosaic_id: UnresolvedMosaicId,
	pub amount: Amount,
}
impl UnresolvedMosaic {

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum LinkAction {
	UNLINK = 0,
	LINK = 1,
}
impl LinkAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::UNLINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(LinkAction::UNLINK),
			1 => Some(LinkAction::LINK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("LinkAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum NetworkType {
	MAINNET = 104,
	TESTNET = 152,
}
impl NetworkType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::MAINNET
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			104 => Some(NetworkType::MAINNET),
			152 => Some(NetworkType::TESTNET),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("NetworkType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum TransactionType {
	ACCOUNT_KEY_LINK = 16716,
	NODE_KEY_LINK = 16972,
	AGGREGATE_COMPLETE = 16705,
	AGGREGATE_BONDED = 16961,
	VOTING_KEY_LINK = 16707,
	VRF_KEY_LINK = 16963,
	HASH_LOCK = 16712,
	SECRET_LOCK = 16722,
	SECRET_PROOF = 16978,
	ACCOUNT_METADATA = 16708,
	MOSAIC_METADATA = 16964,
	NAMESPACE_METADATA = 17220,
	MOSAIC_DEFINITION = 16717,
	MOSAIC_SUPPLY_CHANGE = 16973,
	MOSAIC_SUPPLY_REVOCATION = 17229,
	MULTISIG_ACCOUNT_MODIFICATION = 16725,
	ADDRESS_ALIAS = 16974,
	MOSAIC_ALIAS = 17230,
	NAMESPACE_REGISTRATION = 16718,
	ACCOUNT_ADDRESS_RESTRICTION = 16720,
	ACCOUNT_MOSAIC_RESTRICTION = 16976,
	ACCOUNT_OPERATION_RESTRICTION = 17232,
	MOSAIC_ADDRESS_RESTRICTION = 16977,
	MOSAIC_GLOBAL_RESTRICTION = 16721,
	TRANSFER = 16724,
}
impl TransactionType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::ACCOUNT_KEY_LINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload) {
			16716 => Some(TransactionType::ACCOUNT_KEY_LINK),
			16972 => Some(TransactionType::NODE_KEY_LINK),
			16705 => Some(TransactionType::AGGREGATE_COMPLETE),
			16961 => Some(TransactionType::AGGREGATE_BONDED),
			16707 => Some(TransactionType::VOTING_KEY_LINK),
			16963 => Some(TransactionType::VRF_KEY_LINK),
			16712 => Some(TransactionType::HASH_LOCK),
			16722 => Some(TransactionType::SECRET_LOCK),
			16978 => Some(TransactionType::SECRET_PROOF),
			16708 => Some(TransactionType::ACCOUNT_METADATA),
			16964 => Some(TransactionType::MOSAIC_METADATA),
			17220 => Some(TransactionType::NAMESPACE_METADATA),
			16717 => Some(TransactionType::MOSAIC_DEFINITION),
			16973 => Some(TransactionType::MOSAIC_SUPPLY_CHANGE),
			17229 => Some(TransactionType::MOSAIC_SUPPLY_REVOCATION),
			16725 => Some(TransactionType::MULTISIG_ACCOUNT_MODIFICATION),
			16974 => Some(TransactionType::ADDRESS_ALIAS),
			17230 => Some(TransactionType::MOSAIC_ALIAS),
			16718 => Some(TransactionType::NAMESPACE_REGISTRATION),
			16720 => Some(TransactionType::ACCOUNT_ADDRESS_RESTRICTION),
			16976 => Some(TransactionType::ACCOUNT_MOSAIC_RESTRICTION),
			17232 => Some(TransactionType::ACCOUNT_OPERATION_RESTRICTION),
			16977 => Some(TransactionType::MOSAIC_ADDRESS_RESTRICTION),
			16721 => Some(TransactionType::MOSAIC_GLOBAL_RESTRICTION),
			16724 => Some(TransactionType::TRANSFER),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(*self as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("TransactionType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Transaction {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
}
impl Transaction {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedTransaction {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
}
impl EmbeddedTransaction {

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct ProofGamma {
	bytes: [u8; 32]
}
impl ProofGamma {
	const SIZE: usize = 32;
	pub fn new(proofgamma: [u8; 32]) -> Self {
		Self {
			bytes: proofgamma
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofgamma: [u8; 32]) -> Self {
		Self::new(proofgamma)
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct ProofVerificationHash {
	bytes: [u8; 16]
}
impl ProofVerificationHash {
	const SIZE: usize = 16;
	pub fn new(proofverificationhash: [u8; 16]) -> Self {
		Self {
			bytes: proofverificationhash
		}
	}
	pub fn default() -> Self {
		Self::new([0; 16])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofverificationhash: [u8; 16]) -> Self {
		Self::new(proofverificationhash)
	}
	pub fn serialize(&self) -> [u8; 16] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug)]
pub struct ProofScalar {
	bytes: [u8; 32]
}
impl ProofScalar {
	const SIZE: usize = 32;
	pub fn new(proofscalar: [u8; 32]) -> Self {
		Self {
			bytes: proofscalar
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofscalar: [u8; 32]) -> Self {
		Self::new(proofscalar)
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum BlockType {
	NEMESIS = 32835,
	NORMAL = 33091,
	IMPORTANCE = 33347,
}
impl BlockType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::NEMESIS
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload) {
			32835 => Some(BlockType::NEMESIS),
			33091 => Some(BlockType::NORMAL),
			33347 => Some(BlockType::IMPORTANCE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(*self as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("BlockType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VrfProof {
	pub gamma: ProofGamma,
	pub verification_hash: ProofVerificationHash,
	pub scalar: ProofScalar,
}
impl VrfProof {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Block {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
}
impl Block {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NemesisBlockV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub voting_eligible_accounts_count: u32,
	pub harvesting_eligible_accounts_count: u64,
	pub total_voting_balance: Amount,
	pub previous_importance_block_hash: Hash256,
	pub transactions: array(Transaction, __FILL__),
}
impl NemesisBlockV1 {
	const BLOCK_VERSION: u8 = 	const BLOCK_TYPE: BlockType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NormalBlockV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub block_header_reserved_1: u32,
	pub transactions: array(Transaction, __FILL__),
}
impl NormalBlockV1 {
	const BLOCK_VERSION: u8 = 	const BLOCK_TYPE: BlockType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct ImportanceBlockV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub voting_eligible_accounts_count: u32,
	pub harvesting_eligible_accounts_count: u64,
	pub total_voting_balance: Amount,
	pub previous_importance_block_hash: Hash256,
	pub transactions: array(Transaction, __FILL__),
}
impl ImportanceBlockV1 {
	const BLOCK_VERSION: u8 = 	const BLOCK_TYPE: BlockType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct FinalizationRound {
	pub epoch: FinalizationEpoch,
	pub point: FinalizationPoint,
}
impl FinalizationRound {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct FinalizedBlockHeader {
	pub round: FinalizationRound,
	pub height: Height,
	pub hash: Hash256,
}
impl FinalizedBlockHeader {

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum ReceiptType {
	MOSAIC_RENTAL_FEE = 4685,
	NAMESPACE_RENTAL_FEE = 4942,
	HARVEST_FEE = 8515,
	LOCK_HASH_COMPLETED = 8776,
	LOCK_HASH_EXPIRED = 9032,
	LOCK_SECRET_COMPLETED = 8786,
	LOCK_SECRET_EXPIRED = 9042,
	LOCK_HASH_CREATED = 12616,
	LOCK_SECRET_CREATED = 12626,
	MOSAIC_EXPIRED = 16717,
	NAMESPACE_EXPIRED = 16718,
	NAMESPACE_DELETED = 16974,
	INFLATION = 20803,
	TRANSACTION_GROUP = 57667,
	ADDRESS_ALIAS_RESOLUTION = 61763,
	MOSAIC_ALIAS_RESOLUTION = 62019,
}
impl ReceiptType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::MOSAIC_RENTAL_FEE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload) {
			4685 => Some(ReceiptType::MOSAIC_RENTAL_FEE),
			4942 => Some(ReceiptType::NAMESPACE_RENTAL_FEE),
			8515 => Some(ReceiptType::HARVEST_FEE),
			8776 => Some(ReceiptType::LOCK_HASH_COMPLETED),
			9032 => Some(ReceiptType::LOCK_HASH_EXPIRED),
			8786 => Some(ReceiptType::LOCK_SECRET_COMPLETED),
			9042 => Some(ReceiptType::LOCK_SECRET_EXPIRED),
			12616 => Some(ReceiptType::LOCK_HASH_CREATED),
			12626 => Some(ReceiptType::LOCK_SECRET_CREATED),
			16717 => Some(ReceiptType::MOSAIC_EXPIRED),
			16718 => Some(ReceiptType::NAMESPACE_EXPIRED),
			16974 => Some(ReceiptType::NAMESPACE_DELETED),
			20803 => Some(ReceiptType::INFLATION),
			57667 => Some(ReceiptType::TRANSACTION_GROUP),
			61763 => Some(ReceiptType::ADDRESS_ALIAS_RESOLUTION),
			62019 => Some(ReceiptType::MOSAIC_ALIAS_RESOLUTION),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(*self as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("ReceiptType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Receipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
}
impl Receipt {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct HarvestFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl HarvestFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct InflationReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
}
impl InflationReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashCreatedFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashCreatedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashCompletedFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashCompletedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashExpiredFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashExpiredFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretCreatedFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretCreatedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretCompletedFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretCompletedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretExpiredFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretExpiredFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicExpiredReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub artifact_id: MosaicId,
}
impl MosaicExpiredReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicRentalFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub sender_address: Address,
	pub recipient_address: Address,
}
impl MosaicRentalFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct NamespaceId {
	value: u64
}
impl NamespaceId {
	const SIZE: usize = 8;
	pub fn new(namespaceid: u64) -> Self {
		Self {
			value: namespaceid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum NamespaceRegistrationType {
	ROOT = 0,
	CHILD = 1,
}
impl NamespaceRegistrationType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::ROOT
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(NamespaceRegistrationType::ROOT),
			1 => Some(NamespaceRegistrationType::CHILD),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("NamespaceRegistrationType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum AliasAction {
	UNLINK = 0,
	LINK = 1,
}
impl AliasAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::UNLINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(AliasAction::UNLINK),
			1 => Some(AliasAction::LINK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("AliasAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceExpiredReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub artifact_id: NamespaceId,
}
impl NamespaceExpiredReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceDeletedReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub artifact_id: NamespaceId,
}
impl NamespaceDeletedReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceRentalFeeReceipt {
	pub size: u32,
	pub version: u16,
	pub type: ReceiptType,
	pub mosaic: Mosaic,
	pub sender_address: Address,
	pub recipient_address: Address,
}
impl NamespaceRentalFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct ReceiptSource {
	pub primary_id: u32,
	pub secondary_id: u32,
}
impl ReceiptSource {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressResolutionEntry {
	pub source: ReceiptSource,
	pub resolved_value: Address,
}
impl AddressResolutionEntry {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressResolutionStatement {
	pub unresolved: UnresolvedAddress,
	pub resolution_entries_count: u32,
	pub resolution_entries: array(AddressResolutionEntry, resolution_entries_count),
}
impl AddressResolutionStatement {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicResolutionEntry {
	pub source: ReceiptSource,
	pub resolved_value: MosaicId,
}
impl MosaicResolutionEntry {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicResolutionStatement {
	pub unresolved: UnresolvedMosaicId,
	pub resolution_entries_count: u32,
	pub resolution_entries: array(MosaicResolutionEntry, resolution_entries_count),
}
impl MosaicResolutionStatement {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct TransactionStatement {
	pub primary_id: u32,
	pub secondary_id: u32,
	pub receipt_count: u32,
	pub receipts: array(Receipt, receipt_count),
}
impl TransactionStatement {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct BlockStatement {
	pub transaction_statement_count: u32,
	pub transaction_statements: array(TransactionStatement, transaction_statement_count),
	pub address_resolution_statement_count: u32,
	pub address_resolution_statements: array(AddressResolutionStatement, address_resolution_statement_count),
	pub mosaic_resolution_statement_count: u32,
	pub mosaic_resolution_statements: array(MosaicResolutionStatement, mosaic_resolution_statement_count),
}
impl BlockStatement {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountKeyLinkTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl AccountKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountKeyLinkTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedAccountKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NodeKeyLinkTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl NodeKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNodeKeyLinkTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedNodeKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Cosignature {
	pub version: u64,
	pub signer_public_key: PublicKey,
	pub signature: Signature,
}
impl Cosignature {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct DetachedCosignature {
	pub version: u64,
	pub signer_public_key: PublicKey,
	pub signature: Signature,
	pub parent_hash: Hash256,
}
impl DetachedCosignature {

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateCompleteTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub payload_size: u32,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: array(EmbeddedTransaction, payload_size),
	pub cosignatures: array(Cosignature, __FILL__),
}
impl AggregateCompleteTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateCompleteTransactionV2 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub payload_size: u32,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: array(EmbeddedTransaction, payload_size),
	pub cosignatures: array(Cosignature, __FILL__),
}
impl AggregateCompleteTransactionV2 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateBondedTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub payload_size: u32,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: array(EmbeddedTransaction, payload_size),
	pub cosignatures: array(Cosignature, __FILL__),
}
impl AggregateBondedTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateBondedTransactionV2 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub payload_size: u32,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: array(EmbeddedTransaction, payload_size),
	pub cosignatures: array(Cosignature, __FILL__),
}
impl AggregateBondedTransactionV2 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VotingKeyLinkTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: VotingPublicKey,
	pub start_epoch: FinalizationEpoch,
	pub end_epoch: FinalizationEpoch,
	pub link_action: LinkAction,
}
impl VotingKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedVotingKeyLinkTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub linked_public_key: VotingPublicKey,
	pub start_epoch: FinalizationEpoch,
	pub end_epoch: FinalizationEpoch,
	pub link_action: LinkAction,
}
impl EmbeddedVotingKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VrfKeyLinkTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl VrfKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedVrfKeyLinkTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedVrfKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct HashLockTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash: Hash256,
}
impl HashLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedHashLockTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash: Hash256,
}
impl EmbeddedHashLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum LockHashAlgorithm {
	SHA3_256 = 0,
	HASH_160 = 1,
	HASH_256 = 2,
}
impl LockHashAlgorithm {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::SHA3_256
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(LockHashAlgorithm::SHA3_256),
			1 => Some(LockHashAlgorithm::HASH_160),
			2 => Some(LockHashAlgorithm::HASH_256),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("LockHashAlgorithm::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct SecretLockTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash_algorithm: LockHashAlgorithm,
}
impl SecretLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedSecretLockTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash_algorithm: LockHashAlgorithm,
}
impl EmbeddedSecretLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct SecretProofTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub proof_size: u16,
	pub hash_algorithm: LockHashAlgorithm,
	pub proof: array(uint8, proof_size),
}
impl SecretProofTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedSecretProofTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub proof_size: u16,
	pub hash_algorithm: LockHashAlgorithm,
	pub proof: array(uint8, proof_size),
}
impl EmbeddedSecretProofTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountMetadataTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl AccountMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountMetadataTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl EmbeddedAccountMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicMetadataTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_mosaic_id: UnresolvedMosaicId,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl MosaicMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicMetadataTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_mosaic_id: UnresolvedMosaicId,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl EmbeddedMosaicMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceMetadataTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_namespace_id: NamespaceId,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl NamespaceMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNamespaceMetadataTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_namespace_id: NamespaceId,
	pub value_size_delta: i16,
	pub value_size: u16,
	pub value: array(uint8, value_size),
}
impl EmbeddedNamespaceMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct MosaicNonce {
	value: u32
}
impl MosaicNonce {
	const SIZE: usize = 4;
	pub fn new(mosaicnonce: u32) -> Self {
		Self {
			value: mosaicnonce
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum MosaicFlags {
	NONE = 0,
	SUPPLY_MUTABLE = 1,
	TRANSFERABLE = 2,
	RESTRICTABLE = 4,
	REVOKABLE = 8,
}
impl MosaicFlags {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::NONE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(MosaicFlags::NONE),
			1 => Some(MosaicFlags::SUPPLY_MUTABLE),
			2 => Some(MosaicFlags::TRANSFERABLE),
			4 => Some(MosaicFlags::RESTRICTABLE),
			8 => Some(MosaicFlags::REVOKABLE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicFlags::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum MosaicSupplyChangeAction {
	DECREASE = 0,
	INCREASE = 1,
}
impl MosaicSupplyChangeAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::DECREASE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(MosaicSupplyChangeAction::DECREASE),
			1 => Some(MosaicSupplyChangeAction::INCREASE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicSupplyChangeAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicDefinitionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub id: MosaicId,
	pub duration: BlockDuration,
	pub nonce: MosaicNonce,
	pub flags: MosaicFlags,
	pub divisibility: u8,
}
impl MosaicDefinitionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicDefinitionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub id: MosaicId,
	pub duration: BlockDuration,
	pub nonce: MosaicNonce,
	pub flags: MosaicFlags,
	pub divisibility: u8,
}
impl EmbeddedMosaicDefinitionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicSupplyChangeTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub delta: Amount,
	pub action: MosaicSupplyChangeAction,
}
impl MosaicSupplyChangeTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicSupplyChangeTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub delta: Amount,
	pub action: MosaicSupplyChangeAction,
}
impl EmbeddedMosaicSupplyChangeTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicSupplyRevocationTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub source_address: UnresolvedAddress,
	pub mosaic: UnresolvedMosaic,
}
impl MosaicSupplyRevocationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicSupplyRevocationTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub source_address: UnresolvedAddress,
	pub mosaic: UnresolvedMosaic,
}
impl EmbeddedMosaicSupplyRevocationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MultisigAccountModificationTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub min_removal_delta: i8,
	pub min_approval_delta: i8,
	pub address_additions_count: u8,
	pub address_deletions_count: u8,
	pub multisig_account_modification_transaction_body_reserved_1: u32,
	pub address_additions: array(UnresolvedAddress, address_additions_count),
	pub address_deletions: array(UnresolvedAddress, address_deletions_count),
}
impl MultisigAccountModificationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMultisigAccountModificationTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub min_removal_delta: i8,
	pub min_approval_delta: i8,
	pub address_additions_count: u8,
	pub address_deletions_count: u8,
	pub multisig_account_modification_transaction_body_reserved_1: u32,
	pub address_additions: array(UnresolvedAddress, address_additions_count),
	pub address_deletions: array(UnresolvedAddress, address_deletions_count),
}
impl EmbeddedMultisigAccountModificationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressAliasTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub namespace_id: NamespaceId,
	pub address: Address,
	pub alias_action: AliasAction,
}
impl AddressAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAddressAliasTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub namespace_id: NamespaceId,
	pub address: Address,
	pub alias_action: AliasAction,
}
impl EmbeddedAddressAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicAliasTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub namespace_id: NamespaceId,
	pub mosaic_id: MosaicId,
	pub alias_action: AliasAction,
}
impl MosaicAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicAliasTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub namespace_id: NamespaceId,
	pub mosaic_id: MosaicId,
	pub alias_action: AliasAction,
}
impl EmbeddedMosaicAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceRegistrationTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub duration: BlockDuration,
	pub parent_id: NamespaceId,
	pub id: NamespaceId,
	pub registration_type: NamespaceRegistrationType,
	pub name_size: u8,
	pub name: array(uint8, name_size),
}
impl NamespaceRegistrationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNamespaceRegistrationTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub duration: BlockDuration,
	pub parent_id: NamespaceId,
	pub id: NamespaceId,
	pub registration_type: NamespaceRegistrationType,
	pub name_size: u8,
	pub name: array(uint8, name_size),
}
impl EmbeddedNamespaceRegistrationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum AccountRestrictionFlags {
	ADDRESS = 1,
	MOSAIC_ID = 2,
	TRANSACTION_TYPE = 4,
	OUTGOING = 16384,
	BLOCK = 32768,
}
impl AccountRestrictionFlags {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::ADDRESS
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload) {
			1 => Some(AccountRestrictionFlags::ADDRESS),
			2 => Some(AccountRestrictionFlags::MOSAIC_ID),
			4 => Some(AccountRestrictionFlags::TRANSACTION_TYPE),
			16384 => Some(AccountRestrictionFlags::OUTGOING),
			32768 => Some(AccountRestrictionFlags::BLOCK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(*self as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("AccountRestrictionFlags::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountAddressRestrictionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(UnresolvedAddress, restriction_additions_count),
	pub restriction_deletions: array(UnresolvedAddress, restriction_deletions_count),
}
impl AccountAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountAddressRestrictionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(UnresolvedAddress, restriction_additions_count),
	pub restriction_deletions: array(UnresolvedAddress, restriction_deletions_count),
}
impl EmbeddedAccountAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountMosaicRestrictionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(UnresolvedMosaicId, restriction_additions_count),
	pub restriction_deletions: array(UnresolvedMosaicId, restriction_deletions_count),
}
impl AccountMosaicRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountMosaicRestrictionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(UnresolvedMosaicId, restriction_additions_count),
	pub restriction_deletions: array(UnresolvedMosaicId, restriction_deletions_count),
}
impl EmbeddedAccountMosaicRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountOperationRestrictionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(TransactionType, restriction_additions_count),
	pub restriction_deletions: array(TransactionType, restriction_deletions_count),
}
impl AccountOperationRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountOperationRestrictionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub restriction_additions_count: u8,
	pub restriction_deletions_count: u8,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: array(TransactionType, restriction_additions_count),
	pub restriction_deletions: array(TransactionType, restriction_deletions_count),
}
impl EmbeddedAccountOperationRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicAddressRestrictionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub target_address: UnresolvedAddress,
}
impl MosaicAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicAddressRestrictionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub target_address: UnresolvedAddress,
}
impl EmbeddedMosaicAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug)]
pub struct MosaicRestrictionKey {
	value: u64
}
impl MosaicRestrictionKey {
	const SIZE: usize = 8;
	pub fn new(mosaicrestrictionkey: u64) -> Self {
		Self {
			value: mosaicrestrictionkey
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum MosaicRestrictionType {
	NONE = 0,
	EQ = 1,
	NE = 2,
	LT = 3,
	LE = 4,
	GT = 5,
	GE = 6,
}
impl MosaicRestrictionType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::NONE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: [u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload) {
			0 => Some(MosaicRestrictionType::NONE),
			1 => Some(MosaicRestrictionType::EQ),
			2 => Some(MosaicRestrictionType::NE),
			3 => Some(MosaicRestrictionType::LT),
			4 => Some(MosaicRestrictionType::LE),
			5 => Some(MosaicRestrictionType::GT),
			6 => Some(MosaicRestrictionType::GE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(*self as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicRestrictionType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicGlobalRestrictionTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub reference_mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub previous_restriction_type: MosaicRestrictionType,
	pub new_restriction_type: MosaicRestrictionType,
}
impl MosaicGlobalRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicGlobalRestrictionTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub reference_mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub previous_restriction_type: MosaicRestrictionType,
	pub new_restriction_type: MosaicRestrictionType,
}
impl EmbeddedMosaicGlobalRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct TransferTransactionV1 {
	pub size: u32,
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub message_size: u16,
	pub mosaics_count: u8,
	pub transfer_transaction_body_reserved_1: u8,
	pub transfer_transaction_body_reserved_2: u32,
	pub mosaics: array(UnresolvedMosaic, mosaics_count),
	pub message: array(uint8, message_size),
}
impl TransferTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedTransferTransactionV1 {
	pub size: u32,
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub message_size: u16,
	pub mosaics_count: u8,
	pub transfer_transaction_body_reserved_1: u8,
	pub transfer_transaction_body_reserved_2: u32,
	pub mosaics: array(UnresolvedMosaic, mosaics_count),
	pub message: array(uint8, message_size),
}
impl EmbeddedTransferTransactionV1 {
	const TRANSACTION_VERSION: u8 = 	const TRANSACTION_TYPE: TransactionType = 
class TransactionFactory:
	@classmethod
	def deserialize(cls, payload: bytes) -> Transaction:
		buffer = bytes(payload)
		parent = Transaction.deserialize(buffer)
		mapping = {
			(AccountKeyLinkTransactionV1.TRANSACTION_TYPE, AccountKeyLinkTransactionV1.TRANSACTION_VERSION): AccountKeyLinkTransactionV1,
			(NodeKeyLinkTransactionV1.TRANSACTION_TYPE, NodeKeyLinkTransactionV1.TRANSACTION_VERSION): NodeKeyLinkTransactionV1,
			(AggregateCompleteTransactionV1.TRANSACTION_TYPE, AggregateCompleteTransactionV1.TRANSACTION_VERSION): AggregateCompleteTransactionV1,
			(AggregateCompleteTransactionV2.TRANSACTION_TYPE, AggregateCompleteTransactionV2.TRANSACTION_VERSION): AggregateCompleteTransactionV2,
			(AggregateBondedTransactionV1.TRANSACTION_TYPE, AggregateBondedTransactionV1.TRANSACTION_VERSION): AggregateBondedTransactionV1,
			(AggregateBondedTransactionV2.TRANSACTION_TYPE, AggregateBondedTransactionV2.TRANSACTION_VERSION): AggregateBondedTransactionV2,
			(VotingKeyLinkTransactionV1.TRANSACTION_TYPE, VotingKeyLinkTransactionV1.TRANSACTION_VERSION): VotingKeyLinkTransactionV1,
			(VrfKeyLinkTransactionV1.TRANSACTION_TYPE, VrfKeyLinkTransactionV1.TRANSACTION_VERSION): VrfKeyLinkTransactionV1,
			(HashLockTransactionV1.TRANSACTION_TYPE, HashLockTransactionV1.TRANSACTION_VERSION): HashLockTransactionV1,
			(SecretLockTransactionV1.TRANSACTION_TYPE, SecretLockTransactionV1.TRANSACTION_VERSION): SecretLockTransactionV1,
			(SecretProofTransactionV1.TRANSACTION_TYPE, SecretProofTransactionV1.TRANSACTION_VERSION): SecretProofTransactionV1,
			(AccountMetadataTransactionV1.TRANSACTION_TYPE, AccountMetadataTransactionV1.TRANSACTION_VERSION): AccountMetadataTransactionV1,
			(MosaicMetadataTransactionV1.TRANSACTION_TYPE, MosaicMetadataTransactionV1.TRANSACTION_VERSION): MosaicMetadataTransactionV1,
			(NamespaceMetadataTransactionV1.TRANSACTION_TYPE, NamespaceMetadataTransactionV1.TRANSACTION_VERSION): NamespaceMetadataTransactionV1,
			(MosaicDefinitionTransactionV1.TRANSACTION_TYPE, MosaicDefinitionTransactionV1.TRANSACTION_VERSION): MosaicDefinitionTransactionV1,
			(MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE, MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION): MosaicSupplyChangeTransactionV1,
			(MosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE, MosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION): MosaicSupplyRevocationTransactionV1,
			(MultisigAccountModificationTransactionV1.TRANSACTION_TYPE, MultisigAccountModificationTransactionV1.TRANSACTION_VERSION): MultisigAccountModificationTransactionV1,
			(AddressAliasTransactionV1.TRANSACTION_TYPE, AddressAliasTransactionV1.TRANSACTION_VERSION): AddressAliasTransactionV1,
			(MosaicAliasTransactionV1.TRANSACTION_TYPE, MosaicAliasTransactionV1.TRANSACTION_VERSION): MosaicAliasTransactionV1,
			(NamespaceRegistrationTransactionV1.TRANSACTION_TYPE, NamespaceRegistrationTransactionV1.TRANSACTION_VERSION): NamespaceRegistrationTransactionV1,
			(AccountAddressRestrictionTransactionV1.TRANSACTION_TYPE, AccountAddressRestrictionTransactionV1.TRANSACTION_VERSION): AccountAddressRestrictionTransactionV1,
			(AccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE, AccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION): AccountMosaicRestrictionTransactionV1,
			(AccountOperationRestrictionTransactionV1.TRANSACTION_TYPE, AccountOperationRestrictionTransactionV1.TRANSACTION_VERSION): AccountOperationRestrictionTransactionV1,
			(MosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE, MosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION): MosaicAddressRestrictionTransactionV1,
			(MosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE, MosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION): MosaicGlobalRestrictionTransactionV1,
			(TransferTransactionV1.TRANSACTION_TYPE, TransferTransactionV1.TRANSACTION_VERSION): TransferTransactionV1
		}
		discriminator = (parent.type_, parent.version)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)

	@classmethod
	def create_by_name(cls, entity_name: str) -> Transaction:
		mapping = {
			'account_key_link_transaction_v1': AccountKeyLinkTransactionV1,
			'node_key_link_transaction_v1': NodeKeyLinkTransactionV1,
			'aggregate_complete_transaction_v1': AggregateCompleteTransactionV1,
			'aggregate_complete_transaction_v2': AggregateCompleteTransactionV2,
			'aggregate_bonded_transaction_v1': AggregateBondedTransactionV1,
			'aggregate_bonded_transaction_v2': AggregateBondedTransactionV2,
			'voting_key_link_transaction_v1': VotingKeyLinkTransactionV1,
			'vrf_key_link_transaction_v1': VrfKeyLinkTransactionV1,
			'hash_lock_transaction_v1': HashLockTransactionV1,
			'secret_lock_transaction_v1': SecretLockTransactionV1,
			'secret_proof_transaction_v1': SecretProofTransactionV1,
			'account_metadata_transaction_v1': AccountMetadataTransactionV1,
			'mosaic_metadata_transaction_v1': MosaicMetadataTransactionV1,
			'namespace_metadata_transaction_v1': NamespaceMetadataTransactionV1,
			'mosaic_definition_transaction_v1': MosaicDefinitionTransactionV1,
			'mosaic_supply_change_transaction_v1': MosaicSupplyChangeTransactionV1,
			'mosaic_supply_revocation_transaction_v1': MosaicSupplyRevocationTransactionV1,
			'multisig_account_modification_transaction_v1': MultisigAccountModificationTransactionV1,
			'address_alias_transaction_v1': AddressAliasTransactionV1,
			'mosaic_alias_transaction_v1': MosaicAliasTransactionV1,
			'namespace_registration_transaction_v1': NamespaceRegistrationTransactionV1,
			'account_address_restriction_transaction_v1': AccountAddressRestrictionTransactionV1,
			'account_mosaic_restriction_transaction_v1': AccountMosaicRestrictionTransactionV1,
			'account_operation_restriction_transaction_v1': AccountOperationRestrictionTransactionV1,
			'mosaic_address_restriction_transaction_v1': MosaicAddressRestrictionTransactionV1,
			'mosaic_global_restriction_transaction_v1': MosaicGlobalRestrictionTransactionV1,
			'transfer_transaction_v1': TransferTransactionV1
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown Transaction type {entity_name}')

		return mapping[entity_name]()
class EmbeddedTransactionFactory:
	@classmethod
	def deserialize(cls, payload: bytes) -> EmbeddedTransaction:
		buffer = bytes(payload)
		parent = EmbeddedTransaction.deserialize(buffer)
		mapping = {
			(EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_TYPE, EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_VERSION): EmbeddedAccountKeyLinkTransactionV1,
			(EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_TYPE, EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_VERSION): EmbeddedNodeKeyLinkTransactionV1,
			(EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_TYPE, EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_VERSION): EmbeddedVotingKeyLinkTransactionV1,
			(EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_TYPE, EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_VERSION): EmbeddedVrfKeyLinkTransactionV1,
			(EmbeddedHashLockTransactionV1.TRANSACTION_TYPE, EmbeddedHashLockTransactionV1.TRANSACTION_VERSION): EmbeddedHashLockTransactionV1,
			(EmbeddedSecretLockTransactionV1.TRANSACTION_TYPE, EmbeddedSecretLockTransactionV1.TRANSACTION_VERSION): EmbeddedSecretLockTransactionV1,
			(EmbeddedSecretProofTransactionV1.TRANSACTION_TYPE, EmbeddedSecretProofTransactionV1.TRANSACTION_VERSION): EmbeddedSecretProofTransactionV1,
			(EmbeddedAccountMetadataTransactionV1.TRANSACTION_TYPE, EmbeddedAccountMetadataTransactionV1.TRANSACTION_VERSION): EmbeddedAccountMetadataTransactionV1,
			(EmbeddedMosaicMetadataTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicMetadataTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicMetadataTransactionV1,
			(EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_TYPE, EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_VERSION): EmbeddedNamespaceMetadataTransactionV1,
			(EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicDefinitionTransactionV1,
			(EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicSupplyChangeTransactionV1,
			(EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicSupplyRevocationTransactionV1,
			(EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_TYPE, EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_VERSION): EmbeddedMultisigAccountModificationTransactionV1,
			(EmbeddedAddressAliasTransactionV1.TRANSACTION_TYPE, EmbeddedAddressAliasTransactionV1.TRANSACTION_VERSION): EmbeddedAddressAliasTransactionV1,
			(EmbeddedMosaicAliasTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicAliasTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicAliasTransactionV1,
			(EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_TYPE, EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_VERSION): EmbeddedNamespaceRegistrationTransactionV1,
			(EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_TYPE, EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_VERSION): EmbeddedAccountAddressRestrictionTransactionV1,
			(EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE, EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION): EmbeddedAccountMosaicRestrictionTransactionV1,
			(EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_TYPE, EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_VERSION): EmbeddedAccountOperationRestrictionTransactionV1,
			(EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicAddressRestrictionTransactionV1,
			(EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE, EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION): EmbeddedMosaicGlobalRestrictionTransactionV1,
			(EmbeddedTransferTransactionV1.TRANSACTION_TYPE, EmbeddedTransferTransactionV1.TRANSACTION_VERSION): EmbeddedTransferTransactionV1
		}
		discriminator = (parent.type_, parent.version)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)

	@classmethod
	def create_by_name(cls, entity_name: str) -> EmbeddedTransaction:
		mapping = {
			'account_key_link_transaction_v1': EmbeddedAccountKeyLinkTransactionV1,
			'node_key_link_transaction_v1': EmbeddedNodeKeyLinkTransactionV1,
			'voting_key_link_transaction_v1': EmbeddedVotingKeyLinkTransactionV1,
			'vrf_key_link_transaction_v1': EmbeddedVrfKeyLinkTransactionV1,
			'hash_lock_transaction_v1': EmbeddedHashLockTransactionV1,
			'secret_lock_transaction_v1': EmbeddedSecretLockTransactionV1,
			'secret_proof_transaction_v1': EmbeddedSecretProofTransactionV1,
			'account_metadata_transaction_v1': EmbeddedAccountMetadataTransactionV1,
			'mosaic_metadata_transaction_v1': EmbeddedMosaicMetadataTransactionV1,
			'namespace_metadata_transaction_v1': EmbeddedNamespaceMetadataTransactionV1,
			'mosaic_definition_transaction_v1': EmbeddedMosaicDefinitionTransactionV1,
			'mosaic_supply_change_transaction_v1': EmbeddedMosaicSupplyChangeTransactionV1,
			'mosaic_supply_revocation_transaction_v1': EmbeddedMosaicSupplyRevocationTransactionV1,
			'multisig_account_modification_transaction_v1': EmbeddedMultisigAccountModificationTransactionV1,
			'address_alias_transaction_v1': EmbeddedAddressAliasTransactionV1,
			'mosaic_alias_transaction_v1': EmbeddedMosaicAliasTransactionV1,
			'namespace_registration_transaction_v1': EmbeddedNamespaceRegistrationTransactionV1,
			'account_address_restriction_transaction_v1': EmbeddedAccountAddressRestrictionTransactionV1,
			'account_mosaic_restriction_transaction_v1': EmbeddedAccountMosaicRestrictionTransactionV1,
			'account_operation_restriction_transaction_v1': EmbeddedAccountOperationRestrictionTransactionV1,
			'mosaic_address_restriction_transaction_v1': EmbeddedMosaicAddressRestrictionTransactionV1,
			'mosaic_global_restriction_transaction_v1': EmbeddedMosaicGlobalRestrictionTransactionV1,
			'transfer_transaction_v1': EmbeddedTransferTransactionV1
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown EmbeddedTransaction type {entity_name}')

		return mapping[entity_name]()
class BlockFactory:
	@classmethod
	def deserialize(cls, payload: bytes) -> Block:
		buffer = bytes(payload)
		parent = Block.deserialize(buffer)
		mapping = {
			(NemesisBlockV1.BLOCK_TYPE): NemesisBlockV1,
			(NormalBlockV1.BLOCK_TYPE): NormalBlockV1,
			(ImportanceBlockV1.BLOCK_TYPE): ImportanceBlockV1
		}
		discriminator = (parent.type_)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)

	@classmethod
	def create_by_name(cls, entity_name: str) -> Block:
		mapping = {
			'nemesis_block_v1': NemesisBlockV1,
			'normal_block_v1': NormalBlockV1,
			'importance_block_v1': ImportanceBlockV1
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown Block type {entity_name}')

		return mapping[entity_name]()
class ReceiptFactory:
	@classmethod
	def deserialize(cls, payload: bytes) -> Receipt:
		buffer = bytes(payload)
		parent = Receipt.deserialize(buffer)
		mapping = {
			(HarvestFeeReceipt.RECEIPT_TYPE): HarvestFeeReceipt,
			(InflationReceipt.RECEIPT_TYPE): InflationReceipt,
			(LockHashCreatedFeeReceipt.RECEIPT_TYPE): LockHashCreatedFeeReceipt,
			(LockHashCompletedFeeReceipt.RECEIPT_TYPE): LockHashCompletedFeeReceipt,
			(LockHashExpiredFeeReceipt.RECEIPT_TYPE): LockHashExpiredFeeReceipt,
			(LockSecretCreatedFeeReceipt.RECEIPT_TYPE): LockSecretCreatedFeeReceipt,
			(LockSecretCompletedFeeReceipt.RECEIPT_TYPE): LockSecretCompletedFeeReceipt,
			(LockSecretExpiredFeeReceipt.RECEIPT_TYPE): LockSecretExpiredFeeReceipt,
			(MosaicExpiredReceipt.RECEIPT_TYPE): MosaicExpiredReceipt,
			(MosaicRentalFeeReceipt.RECEIPT_TYPE): MosaicRentalFeeReceipt,
			(NamespaceExpiredReceipt.RECEIPT_TYPE): NamespaceExpiredReceipt,
			(NamespaceDeletedReceipt.RECEIPT_TYPE): NamespaceDeletedReceipt,
			(NamespaceRentalFeeReceipt.RECEIPT_TYPE): NamespaceRentalFeeReceipt
		}
		discriminator = (parent.type_)
		factory_class = mapping[discriminator]
		return factory_class.deserialize(buffer)

	@classmethod
	def create_by_name(cls, entity_name: str) -> Receipt:
		mapping = {
			'harvest_fee_receipt': HarvestFeeReceipt,
			'inflation_receipt': InflationReceipt,
			'lock_hash_created_fee_receipt': LockHashCreatedFeeReceipt,
			'lock_hash_completed_fee_receipt': LockHashCompletedFeeReceipt,
			'lock_hash_expired_fee_receipt': LockHashExpiredFeeReceipt,
			'lock_secret_created_fee_receipt': LockSecretCreatedFeeReceipt,
			'lock_secret_completed_fee_receipt': LockSecretCompletedFeeReceipt,
			'lock_secret_expired_fee_receipt': LockSecretExpiredFeeReceipt,
			'mosaic_expired_receipt': MosaicExpiredReceipt,
			'mosaic_rental_fee_receipt': MosaicRentalFeeReceipt,
			'namespace_expired_receipt': NamespaceExpiredReceipt,
			'namespace_deleted_receipt': NamespaceDeletedReceipt,
			'namespace_rental_fee_receipt': NamespaceRentalFeeReceipt
		}

		if entity_name not in mapping:
			raise ValueError(f'unknown Receipt type {entity_name}')

		return mapping[entity_name]()
