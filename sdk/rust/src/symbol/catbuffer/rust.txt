// rust
use hex;

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct Amount {
	value: u64
}
impl Amount {
	const SIZE: usize = 8;
	pub fn new(amount: u64) -> Self {
		Self {
			value: amount
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct BlockDuration {
	value: u64
}
impl BlockDuration {
	const SIZE: usize = 8;
	pub fn new(blockduration: u64) -> Self {
		Self {
			value: blockduration
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct BlockFeeMultiplier {
	value: u32
}
impl BlockFeeMultiplier {
	const SIZE: usize = 4;
	pub fn new(blockfeemultiplier: u32) -> Self {
		Self {
			value: blockfeemultiplier
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct Difficulty {
	value: u64
}
impl Difficulty {
	const SIZE: usize = 8;
	pub fn new(difficulty: u64) -> Self {
		Self {
			value: difficulty
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct FinalizationEpoch {
	value: u32
}
impl FinalizationEpoch {
	const SIZE: usize = 4;
	pub fn new(finalizationepoch: u32) -> Self {
		Self {
			value: finalizationepoch
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct FinalizationPoint {
	value: u32
}
impl FinalizationPoint {
	const SIZE: usize = 4;
	pub fn new(finalizationpoint: u32) -> Self {
		Self {
			value: finalizationpoint
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct Height {
	value: u64
}
impl Height {
	const SIZE: usize = 8;
	pub fn new(height: u64) -> Self {
		Self {
			value: height
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct Importance {
	value: u64
}
impl Importance {
	const SIZE: usize = 8;
	pub fn new(importance: u64) -> Self {
		Self {
			value: importance
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct ImportanceHeight {
	value: u64
}
impl ImportanceHeight {
	const SIZE: usize = 8;
	pub fn new(importanceheight: u64) -> Self {
		Self {
			value: importanceheight
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct UnresolvedMosaicId {
	value: u64
}
impl UnresolvedMosaicId {
	const SIZE: usize = 8;
	pub fn new(unresolvedmosaicid: u64) -> Self {
		Self {
			value: unresolvedmosaicid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct MosaicId {
	value: u64
}
impl MosaicId {
	const SIZE: usize = 8;
	pub fn new(mosaicid: u64) -> Self {
		Self {
			value: mosaicid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct Timestamp {
	value: u64
}
impl Timestamp {
	const SIZE: usize = 8;
	pub fn new(timestamp: u64) -> Self {
		Self {
			value: timestamp
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct UnresolvedAddress {
	bytes: [u8; 24]
}
impl UnresolvedAddress {
	const SIZE: usize = 24;
	pub fn new(unresolvedaddress: [u8; 24]) -> Self {
		Self {
			bytes: unresolvedaddress
		}
	}
	pub fn default() -> Self {
		Self::new([0; 24])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(unresolvedaddress: &[u8; 24]) -> Self {
		Self::new(unresolvedaddress.clone())
	}
	pub fn serialize(&self) -> [u8; 24] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct Address {
	bytes: [u8; 24]
}
impl Address {
	const SIZE: usize = 24;
	pub fn new(address: [u8; 24]) -> Self {
		Self {
			bytes: address
		}
	}
	pub fn default() -> Self {
		Self::new([0; 24])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(address: &[u8; 24]) -> Self {
		Self::new(address.clone())
	}
	pub fn serialize(&self) -> [u8; 24] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct Hash256 {
	bytes: [u8; 32]
}
impl Hash256 {
	const SIZE: usize = 32;
	pub fn new(hash256: [u8; 32]) -> Self {
		Self {
			bytes: hash256
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(hash256: &[u8; 32]) -> Self {
		Self::new(hash256.clone())
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct Hash512 {
	bytes: [u8; 64]
}
impl Hash512 {
	const SIZE: usize = 64;
	pub fn new(hash512: [u8; 64]) -> Self {
		Self {
			bytes: hash512
		}
	}
	pub fn default() -> Self {
		Self::new([0; 64])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(hash512: &[u8; 64]) -> Self {
		Self::new(hash512.clone())
	}
	pub fn serialize(&self) -> [u8; 64] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct PublicKey {
	bytes: [u8; 32]
}
impl PublicKey {
	const SIZE: usize = 32;
	pub fn new(publickey: [u8; 32]) -> Self {
		Self {
			bytes: publickey
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(publickey: &[u8; 32]) -> Self {
		Self::new(publickey.clone())
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct VotingPublicKey {
	bytes: [u8; 32]
}
impl VotingPublicKey {
	const SIZE: usize = 32;
	pub fn new(votingpublickey: [u8; 32]) -> Self {
		Self {
			bytes: votingpublickey
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(votingpublickey: &[u8; 32]) -> Self {
		Self::new(votingpublickey.clone())
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct Signature {
	bytes: [u8; 64]
}
impl Signature {
	const SIZE: usize = 64;
	pub fn new(signature: [u8; 64]) -> Self {
		Self {
			bytes: signature
		}
	}
	pub fn default() -> Self {
		Self::new([0; 64])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(signature: &[u8; 64]) -> Self {
		Self::new(signature.clone())
	}
	pub fn serialize(&self) -> [u8; 64] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Mosaic {
	pub mosaic_id: MosaicId,
	pub amount: Amount,
}
impl Mosaic {
	pub fn new() -> Self {
		Self {
			mosaic_id: MosaicId::default(),
			amount: Amount::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += MosaicId::SIZE;
		size += Amount::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct UnresolvedMosaic {
	pub mosaic_id: UnresolvedMosaicId,
	pub amount: Amount,
}
impl UnresolvedMosaic {
	pub fn new() -> Self {
		Self {
			mosaic_id: UnresolvedMosaicId::default(),
			amount: Amount::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += UnresolvedMosaicId::SIZE;
		size += Amount::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum LinkAction {
	UNLINK = 0,
	LINK = 1,
}
impl LinkAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::UNLINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(LinkAction::UNLINK),
			1 => Some(LinkAction::LINK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("LinkAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum NetworkType {
	MAINNET = 104,
	TESTNET = 152,
}
impl NetworkType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::MAINNET
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			104 => Some(NetworkType::MAINNET),
			152 => Some(NetworkType::TESTNET),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("NetworkType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum TransactionType {
	ACCOUNT_KEY_LINK = 16716,
	NODE_KEY_LINK = 16972,
	AGGREGATE_COMPLETE = 16705,
	AGGREGATE_BONDED = 16961,
	VOTING_KEY_LINK = 16707,
	VRF_KEY_LINK = 16963,
	HASH_LOCK = 16712,
	SECRET_LOCK = 16722,
	SECRET_PROOF = 16978,
	ACCOUNT_METADATA = 16708,
	MOSAIC_METADATA = 16964,
	NAMESPACE_METADATA = 17220,
	MOSAIC_DEFINITION = 16717,
	MOSAIC_SUPPLY_CHANGE = 16973,
	MOSAIC_SUPPLY_REVOCATION = 17229,
	MULTISIG_ACCOUNT_MODIFICATION = 16725,
	ADDRESS_ALIAS = 16974,
	MOSAIC_ALIAS = 17230,
	NAMESPACE_REGISTRATION = 16718,
	ACCOUNT_ADDRESS_RESTRICTION = 16720,
	ACCOUNT_MOSAIC_RESTRICTION = 16976,
	ACCOUNT_OPERATION_RESTRICTION = 17232,
	MOSAIC_ADDRESS_RESTRICTION = 16977,
	MOSAIC_GLOBAL_RESTRICTION = 16721,
	TRANSFER = 16724,
}
impl TransactionType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::ACCOUNT_KEY_LINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload.clone()) {
			16716 => Some(TransactionType::ACCOUNT_KEY_LINK),
			16972 => Some(TransactionType::NODE_KEY_LINK),
			16705 => Some(TransactionType::AGGREGATE_COMPLETE),
			16961 => Some(TransactionType::AGGREGATE_BONDED),
			16707 => Some(TransactionType::VOTING_KEY_LINK),
			16963 => Some(TransactionType::VRF_KEY_LINK),
			16712 => Some(TransactionType::HASH_LOCK),
			16722 => Some(TransactionType::SECRET_LOCK),
			16978 => Some(TransactionType::SECRET_PROOF),
			16708 => Some(TransactionType::ACCOUNT_METADATA),
			16964 => Some(TransactionType::MOSAIC_METADATA),
			17220 => Some(TransactionType::NAMESPACE_METADATA),
			16717 => Some(TransactionType::MOSAIC_DEFINITION),
			16973 => Some(TransactionType::MOSAIC_SUPPLY_CHANGE),
			17229 => Some(TransactionType::MOSAIC_SUPPLY_REVOCATION),
			16725 => Some(TransactionType::MULTISIG_ACCOUNT_MODIFICATION),
			16974 => Some(TransactionType::ADDRESS_ALIAS),
			17230 => Some(TransactionType::MOSAIC_ALIAS),
			16718 => Some(TransactionType::NAMESPACE_REGISTRATION),
			16720 => Some(TransactionType::ACCOUNT_ADDRESS_RESTRICTION),
			16976 => Some(TransactionType::ACCOUNT_MOSAIC_RESTRICTION),
			17232 => Some(TransactionType::ACCOUNT_OPERATION_RESTRICTION),
			16977 => Some(TransactionType::MOSAIC_ADDRESS_RESTRICTION),
			16721 => Some(TransactionType::MOSAIC_GLOBAL_RESTRICTION),
			16724 => Some(TransactionType::TRANSFER),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(self.clone() as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("TransactionType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Transaction {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
}
impl Transaction {
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: 0,
			network: NetworkType::default(),
			type_: TransactionType::default(),
			fee: Amount::default(),
			deadline: Timestamp::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedTransaction {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
}
impl EmbeddedTransaction {
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: 0,
			network: NetworkType::default(),
			type_: TransactionType::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct ProofGamma {
	bytes: [u8; 32]
}
impl ProofGamma {
	const SIZE: usize = 32;
	pub fn new(proofgamma: [u8; 32]) -> Self {
		Self {
			bytes: proofgamma
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofgamma: &[u8; 32]) -> Self {
		Self::new(proofgamma.clone())
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct ProofVerificationHash {
	bytes: [u8; 16]
}
impl ProofVerificationHash {
	const SIZE: usize = 16;
	pub fn new(proofverificationhash: [u8; 16]) -> Self {
		Self {
			bytes: proofverificationhash
		}
	}
	pub fn default() -> Self {
		Self::new([0; 16])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofverificationhash: &[u8; 16]) -> Self {
		Self::new(proofverificationhash.clone())
	}
	pub fn serialize(&self) -> [u8; 16] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.BYTE_ARRAY
#[derive(Debug, Clone)]
pub struct ProofScalar {
	bytes: [u8; 32]
}
impl ProofScalar {
	const SIZE: usize = 32;
	pub fn new(proofscalar: [u8; 32]) -> Self {
		Self {
			bytes: proofscalar
		}
	}
	pub fn default() -> Self {
		Self::new([0; 32])
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(proofscalar: &[u8; 32]) -> Self {
		Self::new(proofscalar.clone())
	}
	pub fn serialize(&self) -> [u8; 32] {
		self.bytes
	}
	pub fn to_string(&self) -> String {
		"0x".to_string() + &hex::encode(self.bytes)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum BlockType {
	NEMESIS = 32835,
	NORMAL = 33091,
	IMPORTANCE = 33347,
}
impl BlockType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::NEMESIS
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload.clone()) {
			32835 => Some(BlockType::NEMESIS),
			33091 => Some(BlockType::NORMAL),
			33347 => Some(BlockType::IMPORTANCE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(self.clone() as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("BlockType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VrfProof {
	pub gamma: ProofGamma,
	pub verification_hash: ProofVerificationHash,
	pub scalar: ProofScalar,
}
impl VrfProof {
	pub fn new() -> Self {
		Self {
			gamma: ProofGamma::default(),
			verification_hash: ProofVerificationHash::default(),
			scalar: ProofScalar::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += ProofGamma::SIZE;
		size += ProofVerificationHash::SIZE;
		size += ProofScalar::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Block {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
}
impl Block {
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: 0,
			network: NetworkType::default(),
			type_: BlockType::default(),
			height: Height::default(),
			timestamp: Timestamp::default(),
			difficulty: Difficulty::default(),
			generation_hash_proof: VrfProof::default(),
			previous_block_hash: Hash256::default(),
			transactions_hash: Hash256::default(),
			receipts_hash: Hash256::default(),
			state_hash: Hash256::default(),
			beneficiary_address: Address::default(),
			fee_multiplier: BlockFeeMultiplier::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += BlockType::SIZE;
		size += Height::SIZE;
		size += Timestamp::SIZE;
		size += Difficulty::SIZE;
		size += VrfProof::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Address::SIZE;
		size += BlockFeeMultiplier::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NemesisBlockV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub voting_eligible_accounts_count: u32,
	pub harvesting_eligible_accounts_count: u64,
	pub total_voting_balance: Amount,
	pub previous_importance_block_hash: Hash256,
	pub transactions: Vec<Transaction>,
}
impl NemesisBlockV1 {
	const BLOCK_VERSION: u8 = 1;
	const BLOCK_TYPE: BlockType = BlockType::NEMESIS;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::BLOCK_VERSION,
			network: NetworkType::default(),
			type_: Self::BLOCK_TYPE,
			height: Height::default(),
			timestamp: Timestamp::default(),
			difficulty: Difficulty::default(),
			generation_hash_proof: VrfProof::default(),
			previous_block_hash: Hash256::default(),
			transactions_hash: Hash256::default(),
			receipts_hash: Hash256::default(),
			state_hash: Hash256::default(),
			beneficiary_address: Address::default(),
			fee_multiplier: BlockFeeMultiplier::default(),
			voting_eligible_accounts_count: 0,
			harvesting_eligible_accounts_count: 0,
			total_voting_balance: Amount::default(),
			previous_importance_block_hash: Hash256::default(),
			transactions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += BlockType::SIZE;
		size += Height::SIZE;
		size += Timestamp::SIZE;
		size += Difficulty::SIZE;
		size += VrfProof::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Address::SIZE;
		size += BlockFeeMultiplier::SIZE;
		size += 4;
		size += 8;
		size += Amount::SIZE;
		size += Hash256::SIZE;
		size += self.transactions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NormalBlockV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub block_header_reserved_1: u32,
	pub transactions: Vec<Transaction>,
}
impl NormalBlockV1 {
	const BLOCK_VERSION: u8 = 1;
	const BLOCK_TYPE: BlockType = BlockType::NORMAL;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::BLOCK_VERSION,
			network: NetworkType::default(),
			type_: Self::BLOCK_TYPE,
			height: Height::default(),
			timestamp: Timestamp::default(),
			difficulty: Difficulty::default(),
			generation_hash_proof: VrfProof::default(),
			previous_block_hash: Hash256::default(),
			transactions_hash: Hash256::default(),
			receipts_hash: Hash256::default(),
			state_hash: Hash256::default(),
			beneficiary_address: Address::default(),
			fee_multiplier: BlockFeeMultiplier::default(),
			block_header_reserved_1: 0,
			transactions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += BlockType::SIZE;
		size += Height::SIZE;
		size += Timestamp::SIZE;
		size += Difficulty::SIZE;
		size += VrfProof::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Address::SIZE;
		size += BlockFeeMultiplier::SIZE;
		size += 4;
		size += self.transactions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct ImportanceBlockV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: BlockType,
	pub height: Height,
	pub timestamp: Timestamp,
	pub difficulty: Difficulty,
	pub generation_hash_proof: VrfProof,
	pub previous_block_hash: Hash256,
	pub transactions_hash: Hash256,
	pub receipts_hash: Hash256,
	pub state_hash: Hash256,
	pub beneficiary_address: Address,
	pub fee_multiplier: BlockFeeMultiplier,
	pub voting_eligible_accounts_count: u32,
	pub harvesting_eligible_accounts_count: u64,
	pub total_voting_balance: Amount,
	pub previous_importance_block_hash: Hash256,
	pub transactions: Vec<Transaction>,
}
impl ImportanceBlockV1 {
	const BLOCK_VERSION: u8 = 1;
	const BLOCK_TYPE: BlockType = BlockType::IMPORTANCE;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::BLOCK_VERSION,
			network: NetworkType::default(),
			type_: Self::BLOCK_TYPE,
			height: Height::default(),
			timestamp: Timestamp::default(),
			difficulty: Difficulty::default(),
			generation_hash_proof: VrfProof::default(),
			previous_block_hash: Hash256::default(),
			transactions_hash: Hash256::default(),
			receipts_hash: Hash256::default(),
			state_hash: Hash256::default(),
			beneficiary_address: Address::default(),
			fee_multiplier: BlockFeeMultiplier::default(),
			voting_eligible_accounts_count: 0,
			harvesting_eligible_accounts_count: 0,
			total_voting_balance: Amount::default(),
			previous_importance_block_hash: Hash256::default(),
			transactions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += BlockType::SIZE;
		size += Height::SIZE;
		size += Timestamp::SIZE;
		size += Difficulty::SIZE;
		size += VrfProof::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Hash256::SIZE;
		size += Address::SIZE;
		size += BlockFeeMultiplier::SIZE;
		size += 4;
		size += 8;
		size += Amount::SIZE;
		size += Hash256::SIZE;
		size += self.transactions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct FinalizationRound {
	pub epoch: FinalizationEpoch,
	pub point: FinalizationPoint,
}
impl FinalizationRound {
	pub fn new() -> Self {
		Self {
			epoch: FinalizationEpoch::default(),
			point: FinalizationPoint::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += FinalizationEpoch::SIZE;
		size += FinalizationPoint::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct FinalizedBlockHeader {
	pub round: FinalizationRound,
	pub height: Height,
	pub hash: Hash256,
}
impl FinalizedBlockHeader {
	pub fn new() -> Self {
		Self {
			round: FinalizationRound::default(),
			height: Height::default(),
			hash: Hash256::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += FinalizationRound::SIZE;
		size += Height::SIZE;
		size += Hash256::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum ReceiptType {
	MOSAIC_RENTAL_FEE = 4685,
	NAMESPACE_RENTAL_FEE = 4942,
	HARVEST_FEE = 8515,
	LOCK_HASH_COMPLETED = 8776,
	LOCK_HASH_EXPIRED = 9032,
	LOCK_SECRET_COMPLETED = 8786,
	LOCK_SECRET_EXPIRED = 9042,
	LOCK_HASH_CREATED = 12616,
	LOCK_SECRET_CREATED = 12626,
	MOSAIC_EXPIRED = 16717,
	NAMESPACE_EXPIRED = 16718,
	NAMESPACE_DELETED = 16974,
	INFLATION = 20803,
	TRANSACTION_GROUP = 57667,
	ADDRESS_ALIAS_RESOLUTION = 61763,
	MOSAIC_ALIAS_RESOLUTION = 62019,
}
impl ReceiptType {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::MOSAIC_RENTAL_FEE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload.clone()) {
			4685 => Some(ReceiptType::MOSAIC_RENTAL_FEE),
			4942 => Some(ReceiptType::NAMESPACE_RENTAL_FEE),
			8515 => Some(ReceiptType::HARVEST_FEE),
			8776 => Some(ReceiptType::LOCK_HASH_COMPLETED),
			9032 => Some(ReceiptType::LOCK_HASH_EXPIRED),
			8786 => Some(ReceiptType::LOCK_SECRET_COMPLETED),
			9042 => Some(ReceiptType::LOCK_SECRET_EXPIRED),
			12616 => Some(ReceiptType::LOCK_HASH_CREATED),
			12626 => Some(ReceiptType::LOCK_SECRET_CREATED),
			16717 => Some(ReceiptType::MOSAIC_EXPIRED),
			16718 => Some(ReceiptType::NAMESPACE_EXPIRED),
			16974 => Some(ReceiptType::NAMESPACE_DELETED),
			20803 => Some(ReceiptType::INFLATION),
			57667 => Some(ReceiptType::TRANSACTION_GROUP),
			61763 => Some(ReceiptType::ADDRESS_ALIAS_RESOLUTION),
			62019 => Some(ReceiptType::MOSAIC_ALIAS_RESOLUTION),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(self.clone() as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("ReceiptType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Receipt {
	pub version: u16,
	pub type_: ReceiptType,
}
impl Receipt {
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: ReceiptType::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct HarvestFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl HarvestFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::HARVEST_FEE;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct InflationReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
}
impl InflationReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::INFLATION;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashCreatedFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashCreatedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_CREATED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashCompletedFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashCompletedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_COMPLETED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockHashExpiredFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockHashExpiredFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_HASH_EXPIRED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretCreatedFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretCreatedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_CREATED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretCompletedFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretCompletedFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_COMPLETED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct LockSecretExpiredFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub target_address: Address,
}
impl LockSecretExpiredFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::LOCK_SECRET_EXPIRED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			target_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicExpiredReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub artifact_id: MosaicId,
}
impl MosaicExpiredReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_EXPIRED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			artifact_id: MosaicId::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += MosaicId::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicRentalFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub sender_address: Address,
	pub recipient_address: Address,
}
impl MosaicRentalFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::MOSAIC_RENTAL_FEE;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			sender_address: Address::default(),
			recipient_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct NamespaceId {
	value: u64
}
impl NamespaceId {
	const SIZE: usize = 8;
	pub fn new(namespaceid: u64) -> Self {
		Self {
			value: namespaceid
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum NamespaceRegistrationType {
	ROOT = 0,
	CHILD = 1,
}
impl NamespaceRegistrationType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::ROOT
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(NamespaceRegistrationType::ROOT),
			1 => Some(NamespaceRegistrationType::CHILD),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("NamespaceRegistrationType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum AliasAction {
	UNLINK = 0,
	LINK = 1,
}
impl AliasAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::UNLINK
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(AliasAction::UNLINK),
			1 => Some(AliasAction::LINK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("AliasAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceExpiredReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub artifact_id: NamespaceId,
}
impl NamespaceExpiredReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_EXPIRED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			artifact_id: NamespaceId::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += NamespaceId::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceDeletedReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub artifact_id: NamespaceId,
}
impl NamespaceDeletedReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_DELETED;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			artifact_id: NamespaceId::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += NamespaceId::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceRentalFeeReceipt {
	pub version: u16,
	pub type_: ReceiptType,
	pub mosaic: Mosaic,
	pub sender_address: Address,
	pub recipient_address: Address,
}
impl NamespaceRentalFeeReceipt {
	const RECEIPT_TYPE: ReceiptType = ReceiptType::NAMESPACE_RENTAL_FEE;
	pub fn new() -> Self {
		Self {
			version: 0,
			type_: Self::RECEIPT_TYPE,
			mosaic: Mosaic::default(),
			sender_address: Address::default(),
			recipient_address: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 2;
		size += ReceiptType::SIZE;
		size += Mosaic::SIZE;
		size += Address::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct ReceiptSource {
	pub primary_id: u32,
	pub secondary_id: u32,
}
impl ReceiptSource {
	pub fn new() -> Self {
		Self {
			primary_id: 0,
			secondary_id: 0,
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressResolutionEntry {
	pub source: ReceiptSource,
	pub resolved_value: Address,
}
impl AddressResolutionEntry {
	pub fn new() -> Self {
		Self {
			source: ReceiptSource::default(),
			resolved_value: Address::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += ReceiptSource::SIZE;
		size += Address::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressResolutionStatement {
	pub unresolved: UnresolvedAddress,
	pub resolution_entries: Vec<AddressResolutionEntry>,
}
impl AddressResolutionStatement {
	pub fn new() -> Self {
		Self {
			unresolved: UnresolvedAddress::default(),
			resolution_entries: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += UnresolvedAddress::SIZE;
		size += 4;
		size += self.resolution_entries.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicResolutionEntry {
	pub source: ReceiptSource,
	pub resolved_value: MosaicId,
}
impl MosaicResolutionEntry {
	pub fn new() -> Self {
		Self {
			source: ReceiptSource::default(),
			resolved_value: MosaicId::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += ReceiptSource::SIZE;
		size += MosaicId::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicResolutionStatement {
	pub unresolved: UnresolvedMosaicId,
	pub resolution_entries: Vec<MosaicResolutionEntry>,
}
impl MosaicResolutionStatement {
	pub fn new() -> Self {
		Self {
			unresolved: UnresolvedMosaicId::default(),
			resolution_entries: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += UnresolvedMosaicId::SIZE;
		size += 4;
		size += self.resolution_entries.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct TransactionStatement {
	pub primary_id: u32,
	pub secondary_id: u32,
	pub receipts: Vec<Receipt>,
}
impl TransactionStatement {
	pub fn new() -> Self {
		Self {
			primary_id: 0,
			secondary_id: 0,
			receipts: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += 4;
		size += self.receipts.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct BlockStatement {
	pub transaction_statements: Vec<TransactionStatement>,
	pub address_resolution_statements: Vec<AddressResolutionStatement>,
	pub mosaic_resolution_statements: Vec<MosaicResolutionStatement>,
}
impl BlockStatement {
	pub fn new() -> Self {
		Self {
			transaction_statements: Vec::new(),
			address_resolution_statements: Vec::new(),
			mosaic_resolution_statements: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += self.transaction_statements.len();
		size += 4;
		size += self.address_resolution_statements.len();
		size += 4;
		size += self.mosaic_resolution_statements.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountKeyLinkTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl AccountKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountKeyLinkTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedAccountKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_KEY_LINK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NodeKeyLinkTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl NodeKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNodeKeyLinkTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedNodeKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NODE_KEY_LINK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct Cosignature {
	pub version: u64,
	pub signer_public_key: PublicKey,
	pub signature: Signature,
}
impl Cosignature {
	pub fn new() -> Self {
		Self {
			version: 0,
			signer_public_key: PublicKey::default(),
			signature: Signature::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 8;
		size += PublicKey::SIZE;
		size += Signature::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct DetachedCosignature {
	pub version: u64,
	pub signer_public_key: PublicKey,
	pub signature: Signature,
	pub parent_hash: Hash256,
}
impl DetachedCosignature {
	pub fn new() -> Self {
		Self {
			version: 0,
			signer_public_key: PublicKey::default(),
			signature: Signature::default(),
			parent_hash: Hash256::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 8;
		size += PublicKey::SIZE;
		size += Signature::SIZE;
		size += Hash256::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateCompleteTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: Vec<EmbeddedTransaction>,
	pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			transactions_hash: Hash256::default(),
			aggregate_transaction_header_reserved_1: 0,
			transactions: Vec::new(),
			cosignatures: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += Hash256::SIZE;
		size += 4;
		size += 4;
		size += self.transactions.len();
		size += self.cosignatures.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateCompleteTransactionV2 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: Vec<EmbeddedTransaction>,
	pub cosignatures: Vec<Cosignature>,
}
impl AggregateCompleteTransactionV2 {
	const TRANSACTION_VERSION: u8 = 2;
	const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_COMPLETE;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			transactions_hash: Hash256::default(),
			aggregate_transaction_header_reserved_1: 0,
			transactions: Vec::new(),
			cosignatures: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += Hash256::SIZE;
		size += 4;
		size += 4;
		size += self.transactions.len();
		size += self.cosignatures.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateBondedTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: Vec<EmbeddedTransaction>,
	pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			transactions_hash: Hash256::default(),
			aggregate_transaction_header_reserved_1: 0,
			transactions: Vec::new(),
			cosignatures: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += Hash256::SIZE;
		size += 4;
		size += 4;
		size += self.transactions.len();
		size += self.cosignatures.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AggregateBondedTransactionV2 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub transactions_hash: Hash256,
	pub aggregate_transaction_header_reserved_1: u32,
	pub transactions: Vec<EmbeddedTransaction>,
	pub cosignatures: Vec<Cosignature>,
}
impl AggregateBondedTransactionV2 {
	const TRANSACTION_VERSION: u8 = 2;
	const TRANSACTION_TYPE: TransactionType = TransactionType::AGGREGATE_BONDED;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			transactions_hash: Hash256::default(),
			aggregate_transaction_header_reserved_1: 0,
			transactions: Vec::new(),
			cosignatures: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += Hash256::SIZE;
		size += 4;
		size += 4;
		size += self.transactions.len();
		size += self.cosignatures.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VotingKeyLinkTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: VotingPublicKey,
	pub start_epoch: FinalizationEpoch,
	pub end_epoch: FinalizationEpoch,
	pub link_action: LinkAction,
}
impl VotingKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			linked_public_key: VotingPublicKey::default(),
			start_epoch: FinalizationEpoch::default(),
			end_epoch: FinalizationEpoch::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += VotingPublicKey::SIZE;
		size += FinalizationEpoch::SIZE;
		size += FinalizationEpoch::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedVotingKeyLinkTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub linked_public_key: VotingPublicKey,
	pub start_epoch: FinalizationEpoch,
	pub end_epoch: FinalizationEpoch,
	pub link_action: LinkAction,
}
impl EmbeddedVotingKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::VOTING_KEY_LINK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			linked_public_key: VotingPublicKey::default(),
			start_epoch: FinalizationEpoch::default(),
			end_epoch: FinalizationEpoch::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += VotingPublicKey::SIZE;
		size += FinalizationEpoch::SIZE;
		size += FinalizationEpoch::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct VrfKeyLinkTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl VrfKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedVrfKeyLinkTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub linked_public_key: PublicKey,
	pub link_action: LinkAction,
}
impl EmbeddedVrfKeyLinkTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::VRF_KEY_LINK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			linked_public_key: PublicKey::default(),
			link_action: LinkAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += PublicKey::SIZE;
		size += LinkAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct HashLockTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash: Hash256,
}
impl HashLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			mosaic: UnresolvedMosaic::default(),
			duration: BlockDuration::default(),
			hash: Hash256::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedMosaic::SIZE;
		size += BlockDuration::SIZE;
		size += Hash256::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedHashLockTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash: Hash256,
}
impl EmbeddedHashLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::HASH_LOCK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			mosaic: UnresolvedMosaic::default(),
			duration: BlockDuration::default(),
			hash: Hash256::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedMosaic::SIZE;
		size += BlockDuration::SIZE;
		size += Hash256::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum LockHashAlgorithm {
	SHA3_256 = 0,
	HASH_160 = 1,
	HASH_256 = 2,
}
impl LockHashAlgorithm {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::SHA3_256
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(LockHashAlgorithm::SHA3_256),
			1 => Some(LockHashAlgorithm::HASH_160),
			2 => Some(LockHashAlgorithm::HASH_256),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("LockHashAlgorithm::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct SecretLockTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash_algorithm: LockHashAlgorithm,
}
impl SecretLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			recipient_address: UnresolvedAddress::default(),
			secret: Hash256::default(),
			mosaic: UnresolvedMosaic::default(),
			duration: BlockDuration::default(),
			hash_algorithm: LockHashAlgorithm::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += Hash256::SIZE;
		size += UnresolvedMosaic::SIZE;
		size += BlockDuration::SIZE;
		size += LockHashAlgorithm::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedSecretLockTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub mosaic: UnresolvedMosaic,
	pub duration: BlockDuration,
	pub hash_algorithm: LockHashAlgorithm,
}
impl EmbeddedSecretLockTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_LOCK;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			recipient_address: UnresolvedAddress::default(),
			secret: Hash256::default(),
			mosaic: UnresolvedMosaic::default(),
			duration: BlockDuration::default(),
			hash_algorithm: LockHashAlgorithm::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += Hash256::SIZE;
		size += UnresolvedMosaic::SIZE;
		size += BlockDuration::SIZE;
		size += LockHashAlgorithm::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct SecretProofTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub hash_algorithm: LockHashAlgorithm,
	pub proof: Vec<u8>,
}
impl SecretProofTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			recipient_address: UnresolvedAddress::default(),
			secret: Hash256::default(),
			hash_algorithm: LockHashAlgorithm::default(),
			proof: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += Hash256::SIZE;
		size += 2;
		size += LockHashAlgorithm::SIZE;
		size += self.proof.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedSecretProofTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub secret: Hash256,
	pub hash_algorithm: LockHashAlgorithm,
	pub proof: Vec<u8>,
}
impl EmbeddedSecretProofTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::SECRET_PROOF;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			recipient_address: UnresolvedAddress::default(),
			secret: Hash256::default(),
			hash_algorithm: LockHashAlgorithm::default(),
			proof: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += Hash256::SIZE;
		size += 2;
		size += LockHashAlgorithm::SIZE;
		size += self.proof.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountMetadataTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl AccountMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountMetadataTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl EmbeddedAccountMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_METADATA;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicMetadataTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_mosaic_id: UnresolvedMosaicId,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl MosaicMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			target_mosaic_id: UnresolvedMosaicId::default(),
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += UnresolvedMosaicId::SIZE;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicMetadataTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_mosaic_id: UnresolvedMosaicId,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl EmbeddedMosaicMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_METADATA;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			target_mosaic_id: UnresolvedMosaicId::default(),
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += UnresolvedMosaicId::SIZE;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceMetadataTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_namespace_id: NamespaceId,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl NamespaceMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			target_namespace_id: NamespaceId::default(),
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += NamespaceId::SIZE;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNamespaceMetadataTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub target_address: UnresolvedAddress,
	pub scoped_metadata_key: u64,
	pub target_namespace_id: NamespaceId,
	pub value_size_delta: i16,
	pub value: Vec<u8>,
}
impl EmbeddedNamespaceMetadataTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_METADATA;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			target_address: UnresolvedAddress::default(),
			scoped_metadata_key: 0,
			target_namespace_id: NamespaceId::default(),
			value_size_delta: 0,
			value: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 8;
		size += NamespaceId::SIZE;
		size += 2;
		size += 2;
		size += self.value.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct MosaicNonce {
	value: u32
}
impl MosaicNonce {
	const SIZE: usize = 4;
	pub fn new(mosaicnonce: u32) -> Self {
		Self {
			value: mosaicnonce
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 4]) -> Self {
		Self::new(u32::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 4] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:08x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum MosaicFlags {
	NONE = 0,
	SUPPLY_MUTABLE = 1,
	TRANSFERABLE = 2,
	RESTRICTABLE = 4,
	REVOKABLE = 8,
}
impl MosaicFlags {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::NONE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(MosaicFlags::NONE),
			1 => Some(MosaicFlags::SUPPLY_MUTABLE),
			2 => Some(MosaicFlags::TRANSFERABLE),
			4 => Some(MosaicFlags::RESTRICTABLE),
			8 => Some(MosaicFlags::REVOKABLE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicFlags::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum MosaicSupplyChangeAction {
	DECREASE = 0,
	INCREASE = 1,
}
impl MosaicSupplyChangeAction {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::DECREASE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(MosaicSupplyChangeAction::DECREASE),
			1 => Some(MosaicSupplyChangeAction::INCREASE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicSupplyChangeAction::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicDefinitionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub id: MosaicId,
	pub duration: BlockDuration,
	pub nonce: MosaicNonce,
	pub flags: MosaicFlags,
	pub divisibility: u8,
}
impl MosaicDefinitionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			id: MosaicId::default(),
			duration: BlockDuration::default(),
			nonce: MosaicNonce::default(),
			flags: MosaicFlags::default(),
			divisibility: 0,
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += MosaicId::SIZE;
		size += BlockDuration::SIZE;
		size += MosaicNonce::SIZE;
		size += MosaicFlags::SIZE;
		size += 1;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicDefinitionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub id: MosaicId,
	pub duration: BlockDuration,
	pub nonce: MosaicNonce,
	pub flags: MosaicFlags,
	pub divisibility: u8,
}
impl EmbeddedMosaicDefinitionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_DEFINITION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			id: MosaicId::default(),
			duration: BlockDuration::default(),
			nonce: MosaicNonce::default(),
			flags: MosaicFlags::default(),
			divisibility: 0,
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += MosaicId::SIZE;
		size += BlockDuration::SIZE;
		size += MosaicNonce::SIZE;
		size += MosaicFlags::SIZE;
		size += 1;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicSupplyChangeTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub delta: Amount,
	pub action: MosaicSupplyChangeAction,
}
impl MosaicSupplyChangeTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			mosaic_id: UnresolvedMosaicId::default(),
			delta: Amount::default(),
			action: MosaicSupplyChangeAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += Amount::SIZE;
		size += MosaicSupplyChangeAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicSupplyChangeTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub delta: Amount,
	pub action: MosaicSupplyChangeAction,
}
impl EmbeddedMosaicSupplyChangeTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_CHANGE;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			mosaic_id: UnresolvedMosaicId::default(),
			delta: Amount::default(),
			action: MosaicSupplyChangeAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += Amount::SIZE;
		size += MosaicSupplyChangeAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicSupplyRevocationTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub source_address: UnresolvedAddress,
	pub mosaic: UnresolvedMosaic,
}
impl MosaicSupplyRevocationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			source_address: UnresolvedAddress::default(),
			mosaic: UnresolvedMosaic::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += UnresolvedMosaic::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicSupplyRevocationTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub source_address: UnresolvedAddress,
	pub mosaic: UnresolvedMosaic,
}
impl EmbeddedMosaicSupplyRevocationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_SUPPLY_REVOCATION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			source_address: UnresolvedAddress::default(),
			mosaic: UnresolvedMosaic::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += UnresolvedMosaic::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MultisigAccountModificationTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub min_removal_delta: i8,
	pub min_approval_delta: i8,
	pub multisig_account_modification_transaction_body_reserved_1: u32,
	pub address_additions: Vec<UnresolvedAddress>,
	pub address_deletions: Vec<UnresolvedAddress>,
}
impl MultisigAccountModificationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			min_removal_delta: 0,
			min_approval_delta: 0,
			multisig_account_modification_transaction_body_reserved_1: 0,
			address_additions: Vec::new(),
			address_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += 1;
		size += 1;
		size += 1;
		size += 1;
		size += 4;
		size += self.address_additions.len();
		size += self.address_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMultisigAccountModificationTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub min_removal_delta: i8,
	pub min_approval_delta: i8,
	pub multisig_account_modification_transaction_body_reserved_1: u32,
	pub address_additions: Vec<UnresolvedAddress>,
	pub address_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedMultisigAccountModificationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MULTISIG_ACCOUNT_MODIFICATION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			min_removal_delta: 0,
			min_approval_delta: 0,
			multisig_account_modification_transaction_body_reserved_1: 0,
			address_additions: Vec::new(),
			address_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += 1;
		size += 1;
		size += 1;
		size += 1;
		size += 4;
		size += self.address_additions.len();
		size += self.address_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AddressAliasTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub namespace_id: NamespaceId,
	pub address: Address,
	pub alias_action: AliasAction,
}
impl AddressAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			namespace_id: NamespaceId::default(),
			address: Address::default(),
			alias_action: AliasAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += NamespaceId::SIZE;
		size += Address::SIZE;
		size += AliasAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAddressAliasTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub namespace_id: NamespaceId,
	pub address: Address,
	pub alias_action: AliasAction,
}
impl EmbeddedAddressAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ADDRESS_ALIAS;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			namespace_id: NamespaceId::default(),
			address: Address::default(),
			alias_action: AliasAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += NamespaceId::SIZE;
		size += Address::SIZE;
		size += AliasAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicAliasTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub namespace_id: NamespaceId,
	pub mosaic_id: MosaicId,
	pub alias_action: AliasAction,
}
impl MosaicAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			namespace_id: NamespaceId::default(),
			mosaic_id: MosaicId::default(),
			alias_action: AliasAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += NamespaceId::SIZE;
		size += MosaicId::SIZE;
		size += AliasAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicAliasTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub namespace_id: NamespaceId,
	pub mosaic_id: MosaicId,
	pub alias_action: AliasAction,
}
impl EmbeddedMosaicAliasTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ALIAS;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			namespace_id: NamespaceId::default(),
			mosaic_id: MosaicId::default(),
			alias_action: AliasAction::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += NamespaceId::SIZE;
		size += MosaicId::SIZE;
		size += AliasAction::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct NamespaceRegistrationTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub duration: BlockDuration,
	pub parent_id: NamespaceId,
	pub id: NamespaceId,
	pub registration_type: NamespaceRegistrationType,
	pub name: Vec<u8>,
}
impl NamespaceRegistrationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			duration: BlockDuration::default(),
			parent_id: NamespaceId::default(),
			id: NamespaceId::default(),
			registration_type: NamespaceRegistrationType::default(),
			name: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += BlockDuration::SIZE;
		size += NamespaceId::SIZE;
		size += NamespaceId::SIZE;
		size += NamespaceRegistrationType::SIZE;
		size += 1;
		size += self.name.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedNamespaceRegistrationTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub duration: BlockDuration,
	pub parent_id: NamespaceId,
	pub id: NamespaceId,
	pub registration_type: NamespaceRegistrationType,
	pub name: Vec<u8>,
}
impl EmbeddedNamespaceRegistrationTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::NAMESPACE_REGISTRATION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			duration: BlockDuration::default(),
			parent_id: NamespaceId::default(),
			id: NamespaceId::default(),
			registration_type: NamespaceRegistrationType::default(),
			name: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += BlockDuration::SIZE;
		size += NamespaceId::SIZE;
		size += NamespaceId::SIZE;
		size += NamespaceRegistrationType::SIZE;
		size += 1;
		size += self.name.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum AccountRestrictionFlags {
	ADDRESS = 1,
	MOSAIC_ID = 2,
	TRANSACTION_TYPE = 4,
	OUTGOING = 16384,
	BLOCK = 32768,
}
impl AccountRestrictionFlags {
	const SIZE: usize = 2;
	pub fn default() -> Self {
		Self::ADDRESS
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 2]) -> Option<Self> {
		match u16::from_le_bytes(payload.clone()) {
			1 => Some(AccountRestrictionFlags::ADDRESS),
			2 => Some(AccountRestrictionFlags::MOSAIC_ID),
			4 => Some(AccountRestrictionFlags::TRANSACTION_TYPE),
			16384 => Some(AccountRestrictionFlags::OUTGOING),
			32768 => Some(AccountRestrictionFlags::BLOCK),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 2] {
		(self.clone() as u16).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("AccountRestrictionFlags::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountAddressRestrictionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<UnresolvedAddress>,
	pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl AccountAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountAddressRestrictionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<UnresolvedAddress>,
	pub restriction_deletions: Vec<UnresolvedAddress>,
}
impl EmbeddedAccountAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_ADDRESS_RESTRICTION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountMosaicRestrictionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<UnresolvedMosaicId>,
	pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl AccountMosaicRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountMosaicRestrictionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<UnresolvedMosaicId>,
	pub restriction_deletions: Vec<UnresolvedMosaicId>,
}
impl EmbeddedAccountMosaicRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_MOSAIC_RESTRICTION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct AccountOperationRestrictionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<TransactionType>,
	pub restriction_deletions: Vec<TransactionType>,
}
impl AccountOperationRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedAccountOperationRestrictionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub restriction_flags: AccountRestrictionFlags,
	pub account_restriction_transaction_body_reserved_1: u32,
	pub restriction_additions: Vec<TransactionType>,
	pub restriction_deletions: Vec<TransactionType>,
}
impl EmbeddedAccountOperationRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::ACCOUNT_OPERATION_RESTRICTION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			restriction_flags: AccountRestrictionFlags::default(),
			account_restriction_transaction_body_reserved_1: 0,
			restriction_additions: Vec::new(),
			restriction_deletions: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += AccountRestrictionFlags::SIZE;
		size += 1;
		size += 1;
		size += 4;
		size += self.restriction_additions.len();
		size += self.restriction_deletions.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicAddressRestrictionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub target_address: UnresolvedAddress,
}
impl MosaicAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			mosaic_id: UnresolvedMosaicId::default(),
			restriction_key: 0,
			previous_restriction_value: 0,
			new_restriction_value: 0,
			target_address: UnresolvedAddress::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += 8;
		size += 8;
		size += 8;
		size += UnresolvedAddress::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicAddressRestrictionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub target_address: UnresolvedAddress,
}
impl EmbeddedMosaicAddressRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_ADDRESS_RESTRICTION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			mosaic_id: UnresolvedMosaicId::default(),
			restriction_key: 0,
			previous_restriction_value: 0,
			new_restriction_value: 0,
			target_address: UnresolvedAddress::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += 8;
		size += 8;
		size += 8;
		size += UnresolvedAddress::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.INTEGER
#[derive(Debug, Clone)]
pub struct MosaicRestrictionKey {
	value: u64
}
impl MosaicRestrictionKey {
	const SIZE: usize = 8;
	pub fn new(mosaicrestrictionkey: u64) -> Self {
		Self {
			value: mosaicrestrictionkey
		}
	}
	pub fn default() -> Self {
		Self::new(0)
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 8]) -> Self {
		Self::new(u64::from_le_bytes(payload.clone()))
	}
	pub fn serialize(&self) -> [u8; 8] {
		self.value.to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("0x{:016x}", self.value)
	}
}

/// ast_model.display_type == DisplayType.ENUM
#[derive(Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum MosaicRestrictionType {
	NONE = 0,
	EQ = 1,
	NE = 2,
	LT = 3,
	LE = 4,
	GT = 5,
	GE = 6,
}
impl MosaicRestrictionType {
	const SIZE: usize = 1;
	pub fn default() -> Self {
		Self::NONE
	}
	pub fn size(&self) -> usize {
		Self::SIZE
	}
	pub fn deserialize(payload: &[u8; 1]) -> Option<Self> {
		match u8::from_le_bytes(payload.clone()) {
			0 => Some(MosaicRestrictionType::NONE),
			1 => Some(MosaicRestrictionType::EQ),
			2 => Some(MosaicRestrictionType::NE),
			3 => Some(MosaicRestrictionType::LT),
			4 => Some(MosaicRestrictionType::LE),
			5 => Some(MosaicRestrictionType::GT),
			6 => Some(MosaicRestrictionType::GE),
			_ => None,
		}
	}
	pub fn serialize(&self) -> [u8; 1] {
		(self.clone() as u8).to_le_bytes()
	}
	pub fn to_string(&self) -> String {
		format!("MosaicRestrictionType::{:?}", self)
	}
}

/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct MosaicGlobalRestrictionTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub mosaic_id: UnresolvedMosaicId,
	pub reference_mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub previous_restriction_type: MosaicRestrictionType,
	pub new_restriction_type: MosaicRestrictionType,
}
impl MosaicGlobalRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			mosaic_id: UnresolvedMosaicId::default(),
			reference_mosaic_id: UnresolvedMosaicId::default(),
			restriction_key: 0,
			previous_restriction_value: 0,
			new_restriction_value: 0,
			previous_restriction_type: MosaicRestrictionType::default(),
			new_restriction_type: MosaicRestrictionType::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += 8;
		size += 8;
		size += 8;
		size += MosaicRestrictionType::SIZE;
		size += MosaicRestrictionType::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedMosaicGlobalRestrictionTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub mosaic_id: UnresolvedMosaicId,
	pub reference_mosaic_id: UnresolvedMosaicId,
	pub restriction_key: u64,
	pub previous_restriction_value: u64,
	pub new_restriction_value: u64,
	pub previous_restriction_type: MosaicRestrictionType,
	pub new_restriction_type: MosaicRestrictionType,
}
impl EmbeddedMosaicGlobalRestrictionTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::MOSAIC_GLOBAL_RESTRICTION;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			mosaic_id: UnresolvedMosaicId::default(),
			reference_mosaic_id: UnresolvedMosaicId::default(),
			restriction_key: 0,
			previous_restriction_value: 0,
			new_restriction_value: 0,
			previous_restriction_type: MosaicRestrictionType::default(),
			new_restriction_type: MosaicRestrictionType::default(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += UnresolvedMosaicId::SIZE;
		size += 8;
		size += 8;
		size += 8;
		size += MosaicRestrictionType::SIZE;
		size += MosaicRestrictionType::SIZE;
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct TransferTransactionV1 {
	pub verifiable_entity_header_reserved_1: u32,
	pub signature: Signature,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub fee: Amount,
	pub deadline: Timestamp,
	pub recipient_address: UnresolvedAddress,
	pub transfer_transaction_body_reserved_1: u8,
	pub transfer_transaction_body_reserved_2: u32,
	pub mosaics: Vec<UnresolvedMosaic>,
	pub message: Vec<u8>,
}
impl TransferTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
	pub fn new() -> Self {
		Self {
			verifiable_entity_header_reserved_1: 0,
			signature: Signature::default(),
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			fee: Amount::default(),
			deadline: Timestamp::default(),
			recipient_address: UnresolvedAddress::default(),
			transfer_transaction_body_reserved_1: 0,
			transfer_transaction_body_reserved_2: 0,
			mosaics: Vec::new(),
			message: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += Signature::SIZE;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += Amount::SIZE;
		size += Timestamp::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 2;
		size += 1;
		size += 1;
		size += 4;
		size += self.mosaics.len();
		size += self.message.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


/// ast_model.display_type == DisplayType.STRUCT
#[derive(Debug)]
pub struct EmbeddedTransferTransactionV1 {
	pub embedded_transaction_header_reserved_1: u32,
	pub signer_public_key: PublicKey,
	pub entity_body_reserved_1: u32,
	pub version: u8,
	pub network: NetworkType,
	pub type_: TransactionType,
	pub recipient_address: UnresolvedAddress,
	pub transfer_transaction_body_reserved_1: u8,
	pub transfer_transaction_body_reserved_2: u32,
	pub mosaics: Vec<UnresolvedMosaic>,
	pub message: Vec<u8>,
}
impl EmbeddedTransferTransactionV1 {
	const TRANSACTION_VERSION: u8 = 1;
	const TRANSACTION_TYPE: TransactionType = TransactionType::TRANSFER;
	pub fn new() -> Self {
		Self {
			embedded_transaction_header_reserved_1: 0,
			signer_public_key: PublicKey::default(),
			entity_body_reserved_1: 0,
			version: Self::TRANSACTION_VERSION,
			network: NetworkType::default(),
			type_: Self::TRANSACTION_TYPE,
			recipient_address: UnresolvedAddress::default(),
			transfer_transaction_body_reserved_1: 0,
			transfer_transaction_body_reserved_2: 0,
			mosaics: Vec::new(),
			message: Vec::new(),
		}
	}
	pub fn default() -> Self {
		Self::new()
	}
	pub fn size(&self) -> usize {
		let mut size = 0;
		size += 4;
		size += 4;
		size += PublicKey::SIZE;
		size += 4;
		size += 1;
		size += NetworkType::SIZE;
		size += TransactionType::SIZE;
		size += UnresolvedAddress::SIZE;
		size += 2;
		size += 1;
		size += 1;
		size += 4;
		size += self.mosaics.len();
		size += self.message.len();
		size
	}
	pub fn deserialize(payload: &[u8]) -> Self {
		let size = u32::from_le_bytes(payload[..4].clone());
		assert_eq!(size, payload.len());
		let payload = &payload[4..];	}
}


